
import * as assert from 'assert';

import {OrderedMap} from './ordered_map';
import * as util from './util';

/**
 * A tree schema is specified as a collection of typedefs,
 * enums, and node declarations.
 *
 * One or more node declarations must be marked `Root`.
 * 
 */
export class TreeSchema {
    readonly decls: OrderedMap<TypeName, Declaration>;

    constructor(declArray: Array<Declaration>) {
        const decls = new OrderedMap<TypeName,
                                     Declaration>();
        for (let decl of declArray) {
            decls.set(decl.name, decl);
        }
        this.decls = decls;
        Object.freeze(this);
    }

    getDecl(tn: TypeName): Declaration {
        assert(this.decls.has(tn));
        return this.decls.get(tn);
    }

    /**
     * Dump this schema to a TypeScript file
     * in a form that exposes both a direct
     * coding API and associated reflective
     * data.
     */
    dumpTypescript(): string {
        const accum: Array<string> = [];

        accum.push(...[
            "/*** TypeScript API ***/",
            "",
            "/* Autogenerated in `tree_schema.ts.`",
            " * See `dumpTypescript` methods.",
            " */",
            "",
            "import * as assert from 'assert';",
            "import * as S from 'binast-schema';",
            "",
            "export type UInt = number;",
            "export type Int = number;",
            "export type Opt<T> = (null | T);",
            "export type Ro<T> = Readonly<T>;",
            "export type Arr<T> = Array<T>;",
            "export type RoArr<T> = ReadonlyArray<T>;",
            "",
            "",
            "abstract class BaseNode {",
            "}",
            "",
        ]);

        // Emit builder function for reflected schema.

        // Normalize the schema for the reflected
        // schema builder.
        const normalized = this.normalize();

        const builds: Array<string> = [];
        builds.push(...[
            "/*** Reflected Schema Builder ***/",
            "",
            "",
            "/* Helpers. */",
            "function TOpt(inner: S.FieldType)"
              + ": S.FieldTypeOpt {",
            "   return S.FieldTypeOpt.make(inner);",
            "}",
            "",
            "function TArray(inner: S.FieldType)"
              + ": S.FieldTypeArray {",
            "   return S.FieldTypeArray.make(inner);",
            "}",
            "",
            "function TUnion(inners: Array<S.FieldType>)"
              + ": S.FieldTypeUnion {",
            "   return S.FieldTypeUnion.make(" +
                        "Object.freeze(inners));",
            "}",
            "",
            "function TNamed(name: string)"
              + ": S.FieldTypeNamed {",
            "   return S.FieldTypeNamed.make(" +
                        "S.TypeName.make(name));",
            "}",
            "",
            "const TBool = S.FieldTypePrimitive.Bool;",
            "const TUint = S.FieldTypePrimitive.Uint;",
            "const TInt = S.FieldTypePrimitive.Int;",
            "const TF64 = S.FieldTypePrimitive.F64;",
            "const TStr = S.FieldTypePrimitive.Str;",
            "",
            "function mkEVN(enumName: string, name: string)"
              + ": S.EnumVariantName {",
            "   const tn = S.TypeName.make(enumName);",
            "   return S.EnumVariantName.make(tn, name);",
            "}",
            "",
            "export const ReflectedSchema = {",
        ]);
        for (let decl of normalized.decls.values()) {
            const buildDecl = new Array<string>();
            decl.dumpReflection(buildDecl);
            const buildDeclTabbed =
                buildDecl.map(d => '    ' + d);
            assert(buildDeclTabbed.length > 0);
            buildDeclTabbed.push(
                buildDeclTabbed.pop() + ',');
            builds.push(...buildDeclTabbed);
            builds.push('', '');
        }
        builds.push(...[
        `    get schema(): S.TreeSchema {`,
        `        if (!this['_schema']) {`,
        `            const d = `,
        `                new Array<S.Declaration>();`,
        ]);

        for (let decl of normalized.decls.values()) {
            const nm = decl.name.name;
            builds.push(...[
            `            d.push(ReflectedSchema.${nm});`
            ]);
        }

        builds.push(...[
        `            this['_schema'] = ` +
                                `new S.TreeSchema(d);`,
        `        }`,
        `        assert(this['_schema'] ` +
                            `instanceof S.TreeSchema);`,
        `        return this['_schema'] as S.TreeSchema;`,
        `    },`,
        `} // ReflectedSchema;`,
        ]);
        accum.push(...builds);
        accum.push("", "");

        // Typed definitions for nodes and enums
        // and typedefs.
        const defns: Array<string> = [];
        defns.push(...[
            "/*** Typed Interfaces ***/",
            "",
            // Typed definitions to follow.
        ]);
        for (let decl of this.decls.values()) {
            decl.dumpTypescript(defns);
            defns.push("", "");
        }
        accum.push(...defns);

        return accum.join('\n');
    }

    /**
     * Produce a new, normalized tree schema.
     */
    normalize(): TreeSchema {
        const newDecls =
            new OrderedMap<TypeName, Declaration>();

        // First, resolve all references to typenames
        // down to primitive, enum, or iface
        // references.
        this.resolveNames(newDecls);

        // Re-order the normalized decls by the
        // same order they occured in the old schema.
        const ordDecls = Array.from(newDecls.values());
        return new TreeSchema(ordDecls);
    }

    private resolveNames(
        newDecls: OrderedMap<TypeName, Declaration>)
    {
        for (let decl of this.decls.values()) {
            this.resolveDecl(decl, newDecls);
        }
    }

    private resolveDecl(decl: Declaration,
            newDecls: OrderedMap<TypeName, Declaration>)
    {
        if (!newDecls.has(decl.name)) {
            newDecls.set(decl.name,
                decl.resolveNames(this, newDecls));
        }
    }

    resolveType(typeName: TypeName,
            newDecls: OrderedMap<TypeName, Declaration>)
      : FieldType
    {
        // Look up the type.
        const decl = this.getDecl(typeName);

        // Ifaces and enums just produce named types.
        if ((decl instanceof Iface) ||
            (decl instanceof Enum))
        {
            return FieldTypeNamed.make(typeName);
        }

        assert(decl instanceof Typedef);
        this.resolveDecl(decl, newDecls);

        let newDecl = newDecls.get(typeName);
        return (newDecl as Typedef).aliased;
    }

    prettyString(): string {
        const declArray = Array.from(this.decls.values());

        const declPretties =
            declArray.map(d => d.prettyString())
                     .map(s => util.shiftString(s, 2));

        return `Schema {\n${declPretties.join('\n\n')}\n}`;
    }
}

export enum DeclarationKind {
    Typedef = 'Typedef',
    Enum    = 'Enum',
    Iface   = 'Iface'
}

export abstract class Declaration {
    readonly name: TypeName;

    protected constructor(name: TypeName) {
        this.name = name;
    }

    abstract prettyString(): string;
    abstract resolveNames(
            schema: TreeSchema,
            newDecls: OrderedMap<TypeName, Declaration>)
      : Declaration;
    abstract dumpTypescript(defns: Array<string>);
    abstract dumpReflection(defns: Array<string>);
}

export class Typedef extends Declaration {
    readonly aliased: FieldType;

    constructor(name: TypeName, aliased: FieldType) {
        super(name);
        this.aliased = aliased;
        Object.freeze(this);
    }

    prettyString(): string {
        return `typedef ${this.name.prettyString()} =` +
               ` ${this.aliased.prettyString()};`;
    }

    resolveNames(
        schema: TreeSchema,
        newDecls: OrderedMap<TypeName, Declaration>)
      : Typedef
    {
        const resolved = this.aliased.resolveNames(
                                schema, newDecls);
        return new Typedef(this.name, resolved);
    }
    dumpTypescript(defns: Array<string>) {
        const nm = this.name.name;

        // Declare the typedef directly.
        const tStr = this.aliased.typescriptString();
        defns.push(...[
            `export type ${nm} = ${tStr};`
        ]);
    }
    dumpReflection(builds: Array<string>) {
        const nm = this.name.name;
        const nmStr = JSON.stringify(nm);
        const cnmStr = JSON.stringify('c_' + nm);

        const typeNameEx = `S.TypeName.make(${nmStr})`;
        const aliasedEx = this.aliased.reflectedString();
        builds.push(...[
        `get ${nm}(): S.Typedef {`,
        `    if (!this[${cnmStr}]) {`,
        `        const typeName = ${typeNameEx};`,
        `        const aliased = ${aliasedEx};`,
        `        this[${cnmStr}] = new S.Typedef(`,
        `                           typeName, aliased)`,
        `    }`,
        `    assert(this[${cnmStr}] instanceof S.Typedef);`,
        `    return this[${cnmStr}] as S.Typedef;`,
        `},`,
        `get typeof_${nm}(): S.FieldType {`,
        `    return this.${nm}.aliased;`,
        `}`,
        ]);
    }
}

export class EnumVariant {
    readonly enumName: TypeName;
    readonly name: EnumVariantName;
    readonly idx: number;
    readonly value: string;

    constructor(enumName, name, idx, value) {
        this.enumName = enumName;
        this.name = name;
        this.idx = idx;
        this.value = value;
        Object.freeze(this);
    }

    prettyString(): string {
        return `${this.enumName.name}.${this.name}`;
    }
}

export class Enum extends Declaration {
    readonly variants: ReadonlyArray<EnumVariant>;
    readonly variantMap: Map<string, number>;
    readonly valueMap: Map<string, number>;

    constructor(name: TypeName,
                variantNames: Array<EnumVariantName>,
                values: Array<string>)
    {
        assert(variantNames.length > 0);
        assert(variantNames.length === values.length);

        super(name);
        const variants: Array<EnumVariant> = new Array();

        this.variants = variants;
        this.variantMap = new Map();
        this.valueMap = new Map();

        variantNames.forEach((variantName, i: number) => {
            const value = values[i];
            const v = new EnumVariant(name, variantName,
                                      i, value);
            variants.push(v);
        });

        for (let i = 0; i < values.length; i++) {
            const name = variantNames[i];
            const value = values[i];
            this.variantMap.set(name.fullName, i);
            this.valueMap.set(value, i);
        }
        Object.freeze(variants);
        Object.freeze(this.variantMap);
        Object.freeze(this.valueMap);
        Object.freeze(this);
    }

    containsName(name: string): boolean {
        return this.variantMap.has(name);
    }

    lookupValue<E>(value: string): E {
        assert(this.valueMap.has(value));
        const idx = this.valueMap.get(value);

        assert(idx >= 0 && idx < this.variants.length);
        return (this.variants[idx] as any) as E;
    }

    prettyString(): string {
        const parts: Array<string> = [];
        this.valueMap.forEach((idx, value) => {
            const variant = this.variants[idx];
            const variantStr = variant.name.name;
            parts.push(`  ${variantStr} => '${value}'`);
        });
        return `enum ${this.name.prettyString()} {\n` +
               parts.join('\n') + '\n' +
               '};';
    }

    resolveNames(
        schema: TreeSchema,
        newDecls: OrderedMap<TypeName, Declaration>)
      : Enum
    {
        return this;
    }

    dumpTypescript(defns: Array<string>) {
        // On the interface, bind the typedef
        // name as a method yielding the Typedef
        // declaration.
        const nm = this.name.name;
        const refl = `ReflectedSchema.${nm}`;

        defns.push(`export enum ${nm} {`);
        for (let variant of this.variants) {
            const vname = variant.name.name;
            const vstr = variant.name.fullName;
            const vstrEx = JSON.stringify(vstr);
            defns.push(`   ${vname} = ${vstrEx},`);
        }
        defns.push(...[
            `} // enum ${nm}`,
            ``,
            `export function lift${nm}(s: string): ${nm} {`,
            `    switch (s) {`
        ]);
        for (let variant of this.variants) {
            const vvalX = JSON.stringify(variant.value);
            const vnm = variant.name.name;
            defns.push(...[
                `      case ${vvalX}: return ${nm}.${vnm};`,
            ]);
        }
        defns.push(...[
            `    }`,
            `    throw new Error("NOT ENUM!: " + s);`,
            `}`,
            ``,
        ]);
    }
    dumpReflection(builds: Array<string>) {
        const nm = this.name.name;
        const nmStr = JSON.stringify(nm);
        const cnmStr = JSON.stringify('c_' + nm);

        const typeNameEx = `S.TypeName.make(${nmStr})`;

        builds.push(...[
        `get ${nm}(): S.Enum {`,
        `    if (!this[${cnmStr}]) {`,
        `        const typeName = ${typeNameEx};`,
        `        const vnames: Array<S.EnumVariantName>`
          + ` = [];`,
        `        const vvals: Array<string> = [];`,
        ]);
        for (let v of this.variants) {
            const vnStr = JSON.stringify(v.name.name);
            const evnStr = `mkEVN(${nmStr}, ${vnStr})`;
            const vStr = JSON.stringify(v.value);
            builds.push('    '.repeat(2) +
                `vnames.push(${evnStr})`);
            builds.push('    '.repeat(2) +
                `vvals.push(${vStr});`);
            builds.push('');
        }
        builds.push(...[
        `        this[${cnmStr}] = new S.Enum(`
                      + `typeName, vnames, vvals);`,
        `    }`,
        `    assert(this[${cnmStr}] instanceof S.Enum);`,
        `    return this[${cnmStr}] as S.Enum;`,
        `},`,
        `get typeof_${nm}(): S.FieldType {`,
        `    const fieldName = this.${nm}.name;`,
        `    return S.FieldTypeNamed.make(fieldName);`,
        `}`,
        ]);
    }
}

export class Iface extends Declaration {
    readonly fields: ReadonlyArray<IfaceField>;
    readonly isNode: boolean;

    constructor(name: TypeName,
                fields: Array<IfaceField>,
                isNode: boolean)
    {
        super(name);
        this.fields = Object.freeze(fields);
        this.isNode = isNode;
        Object.freeze(this);
    }

    prettyString() {
        return `iface ${this.name.prettyString()} {\n` +
             this.fields.map(f => f.prettyString())
                        .join("\n") + "\n" +
             `}`;
    }

    prettyInstance(schema: TreeSchema, inst: Instance,
                   out: Array<string>)
    {
        assert(inst.iface$ === this);

        out.push(`${this.name.name} {`);

        let npushed: number = 0;
        
        // Retrieve each field.
        for (let field of this.fields) {
            const fty = field.ty;
            const fval = inst[field.name];
            const fvalStrs = new Array<string>();
            fty.prettyValue(schema, fval, fvalStrs);
            assert(fvalStrs.length > 0);
            if (fvalStrs.length == 1 &&
                fvalStrs[0].length < 30)
            {
                out.push(`  ${field.name}: ` +
                            fvalStrs[0]);
                npushed++;
            } else {
                const first = fvalStrs.shift();
                const tabbed = fvalStrs.map(s => {
                    return '  ' + s;
                });
                const tabbedFirst =
                    `  ${field.name}: ${first}`;
                out.push(tabbedFirst, ...tabbed);
                npushed += 1 + tabbed.length;
            }
        }

        let trailer: string = '';
        if (npushed > 10) {
            trailer = ` // ${this.name.name}`
        }
        out.push(`}${trailer}`);
    }

    resolveNames(
        schema: TreeSchema,
        newDecls: OrderedMap<TypeName, Declaration>)
      : Iface
    {
        const rfs = new Array<IfaceField>();
        for (let f of this.fields) {
            rfs.push(f.resolveNames(schema, newDecls));
        }
        return new Iface(this.name, rfs, this.isNode);
    }

    dumpTypescript(defns: Array<string>) {
        // On the interface, bind the typedef
        // name as a method yielding the Typedef
        // declaration.
        const nm = this.name.name;

        this.dumpTypescriptInterface(defns);
        defns.push('');
        this.dumpTypescriptInstance(defns);

    }

    dumpTypescriptInterface(defns: Array<string>) {
        const nm = this.name.name;

        defns.push(`export interface I_${nm} {`);
        for (let field of this.fields) {
            const fnm = field.name;
            const tstr = field.ty.typescriptString();
            defns.push(`    readonly ${fnm}: ${tstr};`);
        }
        defns.push(`} // I_${nm}`);
    }

    dumpTypescriptInstance(defns: Array<string>) {
        const nm = this.name.name;

        defns.push(`export class ${nm}`);
        if (this.isNode) {
            defns.push(`  extends BaseNode`);
        }
        defns.push(...[
            `  implements S.Instance`,
            `{`,
            `    readonly data$: Ro<I_${nm}>;`,
        ]);

        defns.push(...[
            ``,
            `    private constructor(data: Ro<I_${nm}>) {`,
        ]);
        // If extending Node, call super().
        if (this.isNode) {
            defns.push(`    super();`);
        }
        const ifaceEx = `ReflectedSchema.${nm}`;
        defns.push(...[
            `        this.data$ = Object.freeze(data);`,
            `        Object.freeze(this);`,
            `    }`,
            ``,
        ]);

        // Static constructor definition.
        defns.push(...[
            `    get iface$(): S.Iface {`,
            `        return ReflectedSchema.${nm};`,
            `    }`,
            `    static make(data: Ro<I_${nm}>) {`,
            `        return new ${nm}(data);`,
            `    }`,
            ``,
        ]);

        // Accessor method definition.
        for (let field of this.fields) {
            const fnm = field.name;
            const tstr = field.ty.typescriptString();
            defns.push(...[
                `    get ${fnm}(): ${tstr} {`,
                `       return this.data$.${fnm};`,
                `    }`,
            ]);
        }

        // End.
        defns.push(...[
            `}`,
        ]);
    }

    dumpReflection(builds: Array<string>) {
        const nm = this.name.name;
        const nmStr = JSON.stringify(nm);
        const cnmStr = JSON.stringify('c_' + nm);

        const typeNameEx = `S.TypeName.make(${nmStr})`;
        const isNodeEx = this.isNode ? `true` : `false`;

        builds.push(...[
        `get ${nm}(): S.Iface {`,
        `    if (!this[${cnmStr}]) {`,
        `        const typeName = ${typeNameEx};`,
        `        const fields: Array<S.IfaceField> = [`,
        ]);
        for (let f of this.fields) {
            const ftEx = f.ty.reflectedString();
            const fnStr = JSON.stringify(f.name);
            const isLazyEx = f.isLazy ? 'true' : 'false';
            builds.push(...[
            `        new S.IfaceField(`,
            `            /* name = */ ${fnStr},`,
            `            /* ty = */ ${ftEx},`,
            `            /* isLazy = */ ${isLazyEx}),`,
            ]);
        }
        builds.push(...[
        `        ];`,
        `        this[${cnmStr}] = new S.Iface(`
                      + `typeName, fields, ${isNodeEx});`,
        `    }`,
        `    assert(this[${cnmStr}] instanceof S.Iface);`,
        `    return this[${cnmStr}] as S.Iface;`,
        `},`,
        `get typeof_${nm}(): S.FieldType {`,
        `    const fieldName = this.${nm}.name;`,
        `    return S.FieldTypeNamed.make(fieldName);`,
        `}`,
        ]);
    }
}

export class IfaceField {
    readonly name: string;
    readonly ty: FieldType;
    readonly isLazy: boolean;

    constructor(name: string,
                ty: FieldType,
                isLazy?: boolean)
    {
        this.name = name;
        this.ty = ty;
        this.isLazy = !!isLazy;
        Object.freeze(this);
    }

    prettyString() {
        const attrPrefix = this.isLazy ? '[Lazy] ' : '';
        const name = this.name;
        const tyStr = this.ty.prettyString();
        return `  ${attrPrefix}${name}: ${tyStr};`;
    }

    resolveNames(schema: TreeSchema,
            newDecls: OrderedMap<TypeName, Declaration>)
      : IfaceField
    {
        const rty = this.ty.resolveNames(schema,
                                         newDecls);
        return new IfaceField(this.name, rty, this.isLazy);
    }
}

export type Value = null|boolean|number|string|Instance;
export interface Instance {
    iface$: Iface;
}

const TYPE_NAMES = new Map<string, TypeName>();
export class TypeName {
    readonly name: string;

    private constructor(name: string) {
        this.name = name;
        Object.freeze(this);
    }

    static make(name: string): TypeName {
        let ftname = TYPE_NAMES.get(name);
        if (!ftname) {
            ftname = new TypeName(name);
            TYPE_NAMES.set(name, ftname);
        }
        return ftname;
    }

    prettyString(): string {
        return this.name;
    }
}

const ENUM_VARIANT_NAMES =
    new Map<string, EnumVariantName>();

export class EnumVariantName {
    readonly enumName: TypeName;
    readonly name: string;

    private constructor(enumName: TypeName, name: string) {
        this.enumName = enumName;
        this.name = name;
        Object.freeze(this);
    }

    static make(enumName: TypeName, name: string)
      : EnumVariantName
    {
        const key = EnumVariantName.makeKey(enumName.name,
                                            name);
        let evname = ENUM_VARIANT_NAMES.get(key);
        if (!evname) {
            evname = new EnumVariantName(enumName, name);
            ENUM_VARIANT_NAMES.set(key, evname);
        }
        return evname;
    }

    get fullName(): string {
        return `${this.enumName.name}_${this.name}`;
    }

    prettyString(): string {
        return this.fullName;
    }

    static makeKey(enumName: string, name: string): string {
        return `${enumName}_${name}`;
    }
}

// A FieldType is one of:
//  1. A primitive type
//      bool, uint, int, f64, str, null
//  2. A reference to an enum or iface.
//  3. A union of 2+ distinct field types (T|U|V..)
//  4. An optional of a given type (?T)
//  5. An array of a given type. ([T])

export enum FieldTypeKind {
    Primitive, Named, Union, Opt, Array
};

let NEXT_TYPE_ID: number = 1;
const TYPE_CACHE: Map<string, FieldType> = new Map();

export abstract class FieldType {
    readonly typeId: number;

    abstract prettyString(): string;
    abstract kind(): FieldTypeKind;
    abstract resolveNames(schema: TreeSchema,
            newDecls: OrderedMap<TypeName, Declaration>)
      : FieldType;
    abstract typescriptString(): string;
    abstract reflectedString(): string;
    abstract matchesValue(schema: TreeSchema, value: any)
              : boolean;
    abstract prettyValue(schema: TreeSchema, value: any,
                         out: Array<string>);

    protected constructor(typeId: number) {
        this.typeId = typeId;
    }

    protected static nextId(): number {
        return NEXT_TYPE_ID++;
    }
    protected static lookup(key: string): FieldType|null {
        return TYPE_CACHE.get(key) || null;
    }
    protected static lookupOr<T extends FieldType>(
            key: string,
            f: (number) => T)
      : T
    {
        const existing = TYPE_CACHE.get(key);
        if (existing) {
            return existing as T;
        }
        const created = f(this.nextId());
        TYPE_CACHE.set(key, created);
        return created;
    }
    protected static register(key: string, ty: FieldType) {
        assert(!TYPE_CACHE.has(key));
        return TYPE_CACHE.set(key, ty);
    }

    isKind(k: FieldTypeKind): boolean {
        return this.kind() === k;
    }

    isPrimitive(): boolean {
        return this.isKind(FieldTypeKind.Primitive);
    }
    isUnion(): boolean {
        return this.isKind(FieldTypeKind.Union);
    }
    isOpt(): boolean {
        return this.isKind(FieldTypeKind.Opt);
    }
    isArray(): boolean {
        return this.isKind(FieldTypeKind.Array);
    }
}

export class FieldTypePrimitive extends FieldType {
    readonly name: string;

    private constructor(typeId: number, name: string) {
        super(typeId);
        this.name = name;
        Object.freeze(this);
    }

    static make(name: string): FieldTypePrimitive {
        const key = FieldTypePrimitive.typeKey(name);
        return FieldType.lookupOr(key, (id: number) => {
            return new FieldTypePrimitive(id, name);
        });
    }

    kind(): FieldTypeKind {
        return FieldTypeKind.Primitive;
    }
    prettyString(): string {
        return this.name;
    }
    resolveNames(schema: TreeSchema,
            newDecls: OrderedMap<TypeName, Declaration>)
      : FieldTypePrimitive
    {
        return this;
    }
    matchesValue(schema: TreeSchema, value: any): boolean {
        switch (this) {
          case TN_BOOL:
            return typeof(value) === 'boolean';
          case TN_UINT:
            return Number.isInteger(value) && (value >= 0);
          case TN_INT:
            return Number.isInteger(value);
          case TN_F64:
            return typeof(value) === 'number';
          case TN_STR:
            return typeof(value) === 'string';
        }
        throw new Error(`Unknown primitive ${this.name}`);
    }
    prettyValue(schema: TreeSchema, value: any,
                out: Array<string>)
    {
        switch (this) {
          case TN_BOOL: out.push(`Bool(${value})`); return;
          case TN_UINT: out.push(`Uint(${value})`); return;
          case TN_INT: out.push(`Int(${value})`); return;
          case TN_F64: out.push(`F64(${value})`); return;
          case TN_STR:
            out.push(`Str(${JSON.stringify(value)})`);
            return;
        }
        throw new Error(`Unknown primitive ${this.name}`);
    }

    typescriptString(): string {
        switch (this) {
          case TN_BOOL: return 'boolean';
          case TN_UINT: return 'UInt';
          case TN_INT: return 'Int';
          case TN_F64: return 'number';
          case TN_STR: return 'string';
        }
        throw new Error(`Unknown primitive ${this.name}`);
    }
    reflectedString(): string {
        switch (this) {
          case TN_BOOL: return 'TBool';
          case TN_UINT: return 'TUint';
          case TN_INT: return 'TInt';
          case TN_F64: return 'TF64';
          case TN_STR: return 'TStr';
        }
        throw new Error(`Unknown primitive ${this.name}`);
    }

    static typeKey(name: string): string {
        return `prim(${name})`;
    }

    static get Bool(): FieldTypePrimitive {
        return TN_BOOL;
    }
    static get Uint(): FieldTypePrimitive {
        return TN_UINT;
    }
    static get Int(): FieldTypePrimitive {
        return TN_INT;
    }
    static get F64(): FieldTypePrimitive {
        return TN_F64;
    }
    static get Str(): FieldTypePrimitive {
        return TN_STR;
    }
}

const TN_BOOL = FieldTypePrimitive.make('bool');
const TN_UINT = FieldTypePrimitive.make('uint');
const TN_INT = FieldTypePrimitive.make('int');
const TN_F64 = FieldTypePrimitive.make('f64');
const TN_STR = FieldTypePrimitive.make('str');

export class FieldTypeNamed extends FieldType {
    readonly name: TypeName;

    constructor(typeId: number, name: TypeName)
    {
        super(typeId);
        this.name = name;
        Object.freeze(this);
    }

    static make(name: TypeName): FieldTypeNamed
    {
        const key = FieldTypeNamed.typeKey(name);
        return FieldType.lookupOr(key, (id: number) => {
            return new FieldTypeNamed(id, name);
        });
    }
    resolveNames(schema: TreeSchema,
            newDecls: OrderedMap<TypeName, Declaration>)
      : FieldType
    {
        return schema.resolveType(this.name, newDecls);
    }
    typescriptString(): string {
        return this.name.name;
    }
    reflectedString(): string {
        const tstr = JSON.stringify(this.name.name);
        return `TNamed(${tstr})`;
    }
    matchesValue(schema: TreeSchema, value: any): boolean {
        const decl = schema.getDecl(this.name);
        if (decl instanceof Iface) {
            return (typeof(value) === 'object')
                 && (value !== null)
                 && (value['iface$'] === decl);
        } else if (decl instanceof Enum) {
            return typeof(value) == 'string' &&
                   decl.containsName(value as string);
        }
        throw new Error(`Unknown prim ${this.name.name}`);
    }
    prettyValue(schema: TreeSchema, value: any,
                out: Array<string>)
    {
        const decl = schema.getDecl(this.name);
        if (decl instanceof Iface) {
            assert(this.matchesValue(schema, value),
                   `Iface failed matchesValue: ` +
                        JSON.stringify(value));
            (value['iface$'] as Iface).prettyInstance(
                schema, value, out);
            out.push('');
            return;
        } else if (decl instanceof Enum) {
            assert(this.matchesValue(schema, value),
                   `Field ${decl.name.name} failed matchesValue: ` +
                        JSON.stringify(value));
            out.push(value);
            return;
        }
        throw new Error(
            `Unknown named ${this.name.name}: ` +
            JSON.stringify(value));
    }

    kind(): FieldTypeKind {
        return FieldTypeKind.Named;
    }
    prettyString(): string {
        return this.name.prettyString();
    }
    static typeKey(name: TypeName): string {
        return `named(${name.name})`;
    }
}

export class FieldTypeUnion extends FieldType {
    readonly variants: ReadonlyArray<FieldType>;

    constructor(typeId: number,
                variants: ReadonlyArray<FieldType>)
    {
        super(typeId);
        this.variants = variants;
        Object.freeze(this);
    }

    static make(variants: ReadonlyArray<FieldType>)
      : FieldTypeUnion
    {
        const key = FieldTypeUnion.typeKey(variants);
        return FieldType.lookupOr(key, (id: number) => {
            return new FieldTypeUnion(id, variants);
        });
    }

    kind(): FieldTypeKind {
        return FieldTypeKind.Union;
    }
    prettyString(): string {
        let mstr = this.variants.map(m => m.prettyString());
        return `Union<${mstr.join(' | ')}>`;
    }

    static typeKey(variants: ReadonlyArray<FieldType>)
      : string
    {
        let ids = variants.map(m => m.typeId);
        return `union(${ids.join(',')})`
    }

    matchesValue(schema: TreeSchema, value: any): boolean {
        return this.variants.some(v => {
            return v.matchesValue(schema, value);
        });
    }
    prettyValue(schema: TreeSchema, value: any,
                out: Array<string>)
    {
        // Check every constituent type.
        for (let v of this.variants) {
            if (v.matchesValue(schema, value)) {
                v.prettyValue(schema, value, out);
                return;
            }
        }
        throw new Error(`Union not matched: ${value}`);
    }

    resolveNames(schema: TreeSchema,
            newDecls: OrderedMap<TypeName, Declaration>)
      : FieldType
    {
        const newVariants = new Array<FieldType>();
        let wrapOpt: boolean = false;

        for (let variant of this.variants) {
            // resolve the variant first.
            let rv = variant.resolveNames(schema,
                                          newDecls);

            // While the inner type is an opt, set
            // wrapOpt = true and unwrap.
            while (rv instanceof FieldTypeOpt) {
                wrapOpt = true;
                rv = rv.inner;
            }

            // If the type is now a union, then
            // fold its contents into newVariants.
            if (rv instanceof FieldTypeUnion) {
                for (let terminalRv of rv.variants) {
                    newVariants.push(terminalRv);
                }
            } else {
                // Must either be an array, named,
                // or primitive.  Add it singularly.
                assert((rv instanceof FieldTypeArray) ||
                       (rv instanceof FieldTypeNamed) ||
                       (rv instanceof FieldTypePrimitive));
                newVariants.push(rv);
            }
        }

        let ft: FieldType = FieldTypeUnion.make(
                    Object.freeze(newVariants));
        if (wrapOpt) {
            ft = FieldTypeOpt.make(ft);
        }
        return ft;
    }
    typescriptString(): string {
        const varStrs = this.variants.map(v => {
            return v.typescriptString();
        });
        return `(${varStrs.join(' | ')})`;
    }
    reflectedString() {
        return `TUnion([` +
                this.variants.map(v => v.reflectedString())
                            .join(', ') + '])';
    }
}

export class FieldTypeOpt extends FieldType {
    readonly inner: FieldType;

    constructor(typeId: number, inner: FieldType) {
        super(typeId);
        this.inner = inner;
        Object.freeze(this);
    }

    static make(inner: FieldType): FieldTypeOpt {
        const key = FieldTypeOpt.typeKey(inner);
        return FieldType.lookupOr(key, (id: number) => {
            return new FieldTypeOpt(id, inner);
        });
    }

    kind(): FieldTypeKind {
        return FieldTypeKind.Opt;
    }
    prettyString(): string {
        return `Opt<${this.inner.prettyString()}>`;
    }
    static typeKey(inner: FieldType): string {
        return `opt(${inner.typeId})`;
    }

    matchesValue(schema: TreeSchema, value: any): boolean {
        return (value === null) ||
               this.inner.matchesValue(schema, value);
    }
    prettyValue(schema: TreeSchema, value: any,
                out: Array<string>)
    {
        assert(this.matchesValue(schema, value));
        if (value === null) {
            out.push('null');
        } else {
            this.inner.prettyValue(schema, value, out);
        }
    }

    resolveNames(schema: TreeSchema,
            newDecls: OrderedMap<TypeName, Declaration>)
      : FieldType
    {
        return FieldTypeOpt.make(
            this.inner.resolveNames(schema, newDecls));
    }
    typescriptString(): string {
        const innerStr = this.inner.typescriptString();
        return `Opt<${innerStr}>`;
    }
    reflectedString() {
        let innerStr = this.inner.reflectedString();
        return `TOpt(${innerStr})`;
    }
}

export class FieldTypeArray extends FieldType {
    readonly inner: FieldType;

    constructor(typeId: number, inner: FieldType) {
        super(typeId);
        this.inner = inner;
        Object.freeze(this);
    }

    static make(inner: FieldType): FieldTypeArray {
        const key = FieldTypeArray.typeKey(inner);
        return FieldType.lookupOr(key, (id: number) => {
            return new FieldTypeArray(id, inner);
        });
    }

    kind(): FieldTypeKind {
        return FieldTypeKind.Array;
    }
    prettyString(): string {
        return `Array<${this.inner.prettyString()}>`;
    }
    static typeKey(inner: FieldType): string {
        return `array(${inner.typeId})`;
    }

    matchesValue(schema: TreeSchema, value: any): boolean {
        return (value instanceof Array) &&
           (value.every(
                v => this.inner.matchesValue(schema, v)));
    }
    prettyValue(schema: TreeSchema, value: any,
                out: Array<string>)
    {
        assert(this.matchesValue(schema, value));
        const arrays = new Array<Array<string>>();
        for (let e of (value as Array<any>)) {
            const arr = new Array<string>();
            this.inner.prettyValue(schema, e, arr);
            arrays.push(arr.map(s => ('  ' + s)));
        }
        // Check for small definition.
        if (arrays.every(arr => (arr.length === 1))) {
            const j = arrays.map(arr => arr[0]).join(', ');
            if (j.length < 40) {
                out.push(`[${j}]`);
                return;
            }
        }

        out.push('[');
        for (let arr of arrays) {
            out.push(...arr);
        }
        out.push(']');
    }

    resolveNames(schema: TreeSchema,
            newDecls: OrderedMap<TypeName, Declaration>)
      : FieldType
    {
        return FieldTypeArray.make(
            this.inner.resolveNames(schema, newDecls));
    }

    typescriptString(): string {
        const innerStr = this.inner.typescriptString();
        return `RoArr<${innerStr}>`;
    }
    reflectedString() {
        let innerStr = this.inner.reflectedString();
        return `TArray(${innerStr})`;
    }
}
