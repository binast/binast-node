/*** TypeScript API ***/

/* Autogenerated in `tree_schema.ts.`
 * See `dumpTypescript` methods.
 */

import * as assert from 'assert';
import * as S from 'binast-schema';

export type UInt = number;
export type Int = number;
export type Opt<T> = (null | T);
export type Ro<T> = Readonly<T>;
export type Arr<T> = Array<T>;
export type RoArr<T> = ReadonlyArray<T>;


abstract class BaseNode {
}

/*** Reflected Schema Builder ***/


/* Helpers. */

function TArray(inner: S.FieldType): S.FieldTypeArray {
   return S.FieldTypeArray.make(inner);
}

function TUnion(inners: Array<S.FieldType>): S.FieldTypeUnion {
   return S.FieldTypeUnion.make(Object.freeze(inners));
}

function TNamed(name: string): S.FieldTypeNamed {
   return S.FieldTypeNamed.make(S.TypeName.make(name));
}

function TIface(name: string): S.FieldTypeIface {
   return S.FieldTypeIface.make(S.TypeName.make(name));
}

function TEnum(name: string): S.FieldTypeEnum {
   return S.FieldTypeEnum.make(S.TypeName.make(name));
}

function TIdent(name: string): S.FieldTypeIdent {
   return S.FieldTypeIdent.make(name);
}

const TNull = S.FieldTypePrimitive.Null;
const TBool = S.FieldTypePrimitive.Bool;
const TUint = S.FieldTypePrimitive.Uint;
const TInt = S.FieldTypePrimitive.Int;
const TF64 = S.FieldTypePrimitive.F64;
const TStr = S.FieldTypePrimitive.Str;

function mkEVN(enumName: string, name: string): S.EnumVariantName {
   const tn = S.TypeName.make(enumName);
   return S.EnumVariantName.make(tn, name);
}

export const ReflectedSchema = {
    get Arguments(): S.Typedef {
        if (!this["c_Arguments"]) {
            const typeName = S.TypeName.make("Arguments");
            const aliased = TArray(TUnion([TNamed("SpreadElement"), TNamed("Expression")]));
            this["c_Arguments"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Arguments"] instanceof S.Typedef);
        return this["c_Arguments"] as S.Typedef;
    },
    get typeof_Arguments(): S.FieldType {
        return this.Arguments.aliased;
    },


    get Identifier(): S.Typedef {
        if (!this["c_Identifier"]) {
            const typeName = S.TypeName.make("Identifier");
            const aliased = TIdent("ident");
            this["c_Identifier"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Identifier"] instanceof S.Typedef);
        return this["c_Identifier"] as S.Typedef;
    },
    get typeof_Identifier(): S.FieldType {
        return this.Identifier.aliased;
    },


    get IdentifierName(): S.Typedef {
        if (!this["c_IdentifierName"]) {
            const typeName = S.TypeName.make("IdentifierName");
            const aliased = TIdent("ident");
            this["c_IdentifierName"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_IdentifierName"] instanceof S.Typedef);
        return this["c_IdentifierName"] as S.Typedef;
    },
    get typeof_IdentifierName(): S.FieldType {
        return this.IdentifierName.aliased;
    },


    get PropertyString(): S.Typedef {
        if (!this["c_PropertyString"]) {
            const typeName = S.TypeName.make("PropertyString");
            const aliased = TIdent("ident");
            this["c_PropertyString"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_PropertyString"] instanceof S.Typedef);
        return this["c_PropertyString"] as S.Typedef;
    },
    get typeof_PropertyString(): S.FieldType {
        return this.PropertyString.aliased;
    },


    get Label(): S.Typedef {
        if (!this["c_Label"]) {
            const typeName = S.TypeName.make("Label");
            const aliased = TStr;
            this["c_Label"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Label"] instanceof S.Typedef);
        return this["c_Label"] as S.Typedef;
    },
    get typeof_Label(): S.FieldType {
        return this.Label.aliased;
    },


    get VariableDeclarationKind(): S.Enum {
        if (!this["c_VariableDeclarationKind"]) {
            const typeName = S.TypeName.make("VariableDeclarationKind");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("VariableDeclarationKind", "KwVar"))
            vvals.push("var");
    
            vnames.push(mkEVN("VariableDeclarationKind", "KwLet"))
            vvals.push("let");
    
            vnames.push(mkEVN("VariableDeclarationKind", "KwConst"))
            vvals.push("const");
    
            this["c_VariableDeclarationKind"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_VariableDeclarationKind"] instanceof S.Enum);
        return this["c_VariableDeclarationKind"] as S.Enum;
    },
    get typeof_VariableDeclarationKind(): S.FieldType {
        const fieldName = this.VariableDeclarationKind.name;
        return S.FieldTypeEnum.make(fieldName);
    },


    get CompoundAssignmentOperator(): S.Enum {
        if (!this["c_CompoundAssignmentOperator"]) {
            const typeName = S.TypeName.make("CompoundAssignmentOperator");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("CompoundAssignmentOperator", "PlusAssign"))
            vvals.push("+=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "MinusAssign"))
            vvals.push("-=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "MulAssign"))
            vvals.push("*=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "DivAssign"))
            vvals.push("/=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "ModAssign"))
            vvals.push("%=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "PowAssign"))
            vvals.push("**=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "LshAssign"))
            vvals.push("<<=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "RshAssign"))
            vvals.push(">>=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "ArshAssign"))
            vvals.push(">>>=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "BitorAssign"))
            vvals.push("|=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "BitxorAssign"))
            vvals.push("^=");
    
            vnames.push(mkEVN("CompoundAssignmentOperator", "BitandAssign"))
            vvals.push("&=");
    
            this["c_CompoundAssignmentOperator"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_CompoundAssignmentOperator"] instanceof S.Enum);
        return this["c_CompoundAssignmentOperator"] as S.Enum;
    },
    get typeof_CompoundAssignmentOperator(): S.FieldType {
        const fieldName = this.CompoundAssignmentOperator.name;
        return S.FieldTypeEnum.make(fieldName);
    },


    get BinaryOperator(): S.Enum {
        if (!this["c_BinaryOperator"]) {
            const typeName = S.TypeName.make("BinaryOperator");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("BinaryOperator", "Comma"))
            vvals.push(",");
    
            vnames.push(mkEVN("BinaryOperator", "LogicalOr"))
            vvals.push("||");
    
            vnames.push(mkEVN("BinaryOperator", "LogicalAnd"))
            vvals.push("&&");
    
            vnames.push(mkEVN("BinaryOperator", "Bitor"))
            vvals.push("|");
    
            vnames.push(mkEVN("BinaryOperator", "Bitxor"))
            vvals.push("^");
    
            vnames.push(mkEVN("BinaryOperator", "Bitand"))
            vvals.push("&");
    
            vnames.push(mkEVN("BinaryOperator", "Equal"))
            vvals.push("==");
    
            vnames.push(mkEVN("BinaryOperator", "NotEqual"))
            vvals.push("!=");
    
            vnames.push(mkEVN("BinaryOperator", "StrictEqual"))
            vvals.push("===");
    
            vnames.push(mkEVN("BinaryOperator", "NotStrictEqual"))
            vvals.push("!==");
    
            vnames.push(mkEVN("BinaryOperator", "LessThan"))
            vvals.push("<");
    
            vnames.push(mkEVN("BinaryOperator", "LessEqual"))
            vvals.push("<=");
    
            vnames.push(mkEVN("BinaryOperator", "GreaterThan"))
            vvals.push(">");
    
            vnames.push(mkEVN("BinaryOperator", "GreaterEqual"))
            vvals.push(">=");
    
            vnames.push(mkEVN("BinaryOperator", "KwIn"))
            vvals.push("in");
    
            vnames.push(mkEVN("BinaryOperator", "KwInstanceof"))
            vvals.push("instanceof");
    
            vnames.push(mkEVN("BinaryOperator", "Lsh"))
            vvals.push("<<");
    
            vnames.push(mkEVN("BinaryOperator", "Rsh"))
            vvals.push(">>");
    
            vnames.push(mkEVN("BinaryOperator", "Arsh"))
            vvals.push(">>>");
    
            vnames.push(mkEVN("BinaryOperator", "Plus"))
            vvals.push("+");
    
            vnames.push(mkEVN("BinaryOperator", "Minus"))
            vvals.push("-");
    
            vnames.push(mkEVN("BinaryOperator", "Mul"))
            vvals.push("*");
    
            vnames.push(mkEVN("BinaryOperator", "Div"))
            vvals.push("/");
    
            vnames.push(mkEVN("BinaryOperator", "Mod"))
            vvals.push("%");
    
            vnames.push(mkEVN("BinaryOperator", "Pow"))
            vvals.push("**");
    
            this["c_BinaryOperator"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_BinaryOperator"] instanceof S.Enum);
        return this["c_BinaryOperator"] as S.Enum;
    },
    get typeof_BinaryOperator(): S.FieldType {
        const fieldName = this.BinaryOperator.name;
        return S.FieldTypeEnum.make(fieldName);
    },


    get UnaryOperator(): S.Enum {
        if (!this["c_UnaryOperator"]) {
            const typeName = S.TypeName.make("UnaryOperator");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("UnaryOperator", "Plus"))
            vvals.push("+");
    
            vnames.push(mkEVN("UnaryOperator", "Minus"))
            vvals.push("-");
    
            vnames.push(mkEVN("UnaryOperator", "LogicalNot"))
            vvals.push("!");
    
            vnames.push(mkEVN("UnaryOperator", "Bitnot"))
            vvals.push("~");
    
            vnames.push(mkEVN("UnaryOperator", "KwTypeof"))
            vvals.push("typeof");
    
            vnames.push(mkEVN("UnaryOperator", "KwVoid"))
            vvals.push("void");
    
            vnames.push(mkEVN("UnaryOperator", "KwDelete"))
            vvals.push("delete");
    
            this["c_UnaryOperator"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_UnaryOperator"] instanceof S.Enum);
        return this["c_UnaryOperator"] as S.Enum;
    },
    get typeof_UnaryOperator(): S.FieldType {
        const fieldName = this.UnaryOperator.name;
        return S.FieldTypeEnum.make(fieldName);
    },


    get UpdateOperator(): S.Enum {
        if (!this["c_UpdateOperator"]) {
            const typeName = S.TypeName.make("UpdateOperator");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("UpdateOperator", "PlusPlus"))
            vvals.push("++");
    
            vnames.push(mkEVN("UpdateOperator", "MinusMinus"))
            vvals.push("--");
    
            this["c_UpdateOperator"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_UpdateOperator"] instanceof S.Enum);
        return this["c_UpdateOperator"] as S.Enum;
    },
    get typeof_UpdateOperator(): S.FieldType {
        const fieldName = this.UpdateOperator.name;
        return S.FieldTypeEnum.make(fieldName);
    },


    get AssertedDeclaredKind(): S.Enum {
        if (!this["c_AssertedDeclaredKind"]) {
            const typeName = S.TypeName.make("AssertedDeclaredKind");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("AssertedDeclaredKind", "KwVar"))
            vvals.push("var");
    
            vnames.push(mkEVN("AssertedDeclaredKind", "NonConstLexical"))
            vvals.push("non-const lexical");
    
            vnames.push(mkEVN("AssertedDeclaredKind", "ConstLexical"))
            vvals.push("const lexical");
    
            this["c_AssertedDeclaredKind"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_AssertedDeclaredKind"] instanceof S.Enum);
        return this["c_AssertedDeclaredKind"] as S.Enum;
    },
    get typeof_AssertedDeclaredKind(): S.FieldType {
        const fieldName = this.AssertedDeclaredKind.name;
        return S.FieldTypeEnum.make(fieldName);
    },


    get AssertedDeclaredName(): S.Iface {
        if (!this["c_AssertedDeclaredName"]) {
            const typeName = S.TypeName.make("AssertedDeclaredName");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("IdentifierName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "kind",
                /* ty = */ TNamed("AssertedDeclaredKind"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedDeclaredName"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedDeclaredName"] instanceof S.Iface);
        return this["c_AssertedDeclaredName"] as S.Iface;
    },
    get typeof_AssertedDeclaredName(): S.FieldType {
        const fieldName = this.AssertedDeclaredName.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssertedBoundName(): S.Iface {
        if (!this["c_AssertedBoundName"]) {
            const typeName = S.TypeName.make("AssertedBoundName");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("IdentifierName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedBoundName"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedBoundName"] instanceof S.Iface);
        return this["c_AssertedBoundName"] as S.Iface;
    },
    get typeof_AssertedBoundName(): S.FieldType {
        const fieldName = this.AssertedBoundName.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssertedBlockScope(): S.Iface {
        if (!this["c_AssertedBlockScope"]) {
            const typeName = S.TypeName.make("AssertedBlockScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "declaredNames",
                /* ty = */ TArray(TNamed("AssertedDeclaredName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedBlockScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedBlockScope"] instanceof S.Iface);
        return this["c_AssertedBlockScope"] as S.Iface;
    },
    get typeof_AssertedBlockScope(): S.FieldType {
        const fieldName = this.AssertedBlockScope.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssertedScriptGlobalScope(): S.Iface {
        if (!this["c_AssertedScriptGlobalScope"]) {
            const typeName = S.TypeName.make("AssertedScriptGlobalScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "declaredNames",
                /* ty = */ TArray(TNamed("AssertedDeclaredName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedScriptGlobalScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedScriptGlobalScope"] instanceof S.Iface);
        return this["c_AssertedScriptGlobalScope"] as S.Iface;
    },
    get typeof_AssertedScriptGlobalScope(): S.FieldType {
        const fieldName = this.AssertedScriptGlobalScope.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssertedVarScope(): S.Iface {
        if (!this["c_AssertedVarScope"]) {
            const typeName = S.TypeName.make("AssertedVarScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "declaredNames",
                /* ty = */ TArray(TNamed("AssertedDeclaredName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedVarScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedVarScope"] instanceof S.Iface);
        return this["c_AssertedVarScope"] as S.Iface;
    },
    get typeof_AssertedVarScope(): S.FieldType {
        const fieldName = this.AssertedVarScope.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssertedParameterScope(): S.Iface {
        if (!this["c_AssertedParameterScope"]) {
            const typeName = S.TypeName.make("AssertedParameterScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "boundNames",
                /* ty = */ TArray(TNamed("AssertedBoundName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isSimpleParameterList",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedParameterScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedParameterScope"] instanceof S.Iface);
        return this["c_AssertedParameterScope"] as S.Iface;
    },
    get typeof_AssertedParameterScope(): S.FieldType {
        const fieldName = this.AssertedParameterScope.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssertedBoundNamesScope(): S.Iface {
        if (!this["c_AssertedBoundNamesScope"]) {
            const typeName = S.TypeName.make("AssertedBoundNamesScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "boundNames",
                /* ty = */ TArray(TNamed("AssertedBoundName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedBoundNamesScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedBoundNamesScope"] instanceof S.Iface);
        return this["c_AssertedBoundNamesScope"] as S.Iface;
    },
    get typeof_AssertedBoundNamesScope(): S.FieldType {
        const fieldName = this.AssertedBoundNamesScope.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get Program(): S.Typedef {
        if (!this["c_Program"]) {
            const typeName = S.TypeName.make("Program");
            const aliased = TUnion([TNamed("Script"), TNamed("Module")]);
            this["c_Program"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Program"] instanceof S.Typedef);
        return this["c_Program"] as S.Typedef;
    },
    get typeof_Program(): S.FieldType {
        return this.Program.aliased;
    },


    get IterationStatement(): S.Typedef {
        if (!this["c_IterationStatement"]) {
            const typeName = S.TypeName.make("IterationStatement");
            const aliased = TUnion([TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement")]);
            this["c_IterationStatement"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_IterationStatement"] instanceof S.Typedef);
        return this["c_IterationStatement"] as S.Typedef;
    },
    get typeof_IterationStatement(): S.FieldType {
        return this.IterationStatement.aliased;
    },


    get Statement(): S.Typedef {
        if (!this["c_Statement"]) {
            const typeName = S.TypeName.make("Statement");
            const aliased = TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("FunctionDeclaration"), TNamed("IfStatement"), TNamed("IterationStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]);
            this["c_Statement"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Statement"] instanceof S.Typedef);
        return this["c_Statement"] as S.Typedef;
    },
    get typeof_Statement(): S.FieldType {
        return this.Statement.aliased;
    },


    get Literal(): S.Typedef {
        if (!this["c_Literal"]) {
            const typeName = S.TypeName.make("Literal");
            const aliased = TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression")]);
            this["c_Literal"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Literal"] instanceof S.Typedef);
        return this["c_Literal"] as S.Typedef;
    },
    get typeof_Literal(): S.FieldType {
        return this.Literal.aliased;
    },


    get Expression(): S.Typedef {
        if (!this["c_Expression"]) {
            const typeName = S.TypeName.make("Expression");
            const aliased = TUnion([TNamed("Literal"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("ArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("FunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]);
            this["c_Expression"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Expression"] instanceof S.Typedef);
        return this["c_Expression"] as S.Typedef;
    },
    get typeof_Expression(): S.FieldType {
        return this.Expression.aliased;
    },


    get PropertyName(): S.Typedef {
        if (!this["c_PropertyName"]) {
            const typeName = S.TypeName.make("PropertyName");
            const aliased = TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]);
            this["c_PropertyName"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_PropertyName"] instanceof S.Typedef);
        return this["c_PropertyName"] as S.Typedef;
    },
    get typeof_PropertyName(): S.FieldType {
        return this.PropertyName.aliased;
    },


    get MethodDefinition(): S.Typedef {
        if (!this["c_MethodDefinition"]) {
            const typeName = S.TypeName.make("MethodDefinition");
            const aliased = TUnion([TNamed("Method"), TNamed("Getter"), TNamed("Setter")]);
            this["c_MethodDefinition"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_MethodDefinition"] instanceof S.Typedef);
        return this["c_MethodDefinition"] as S.Typedef;
    },
    get typeof_MethodDefinition(): S.FieldType {
        return this.MethodDefinition.aliased;
    },


    get ObjectProperty(): S.Typedef {
        if (!this["c_ObjectProperty"]) {
            const typeName = S.TypeName.make("ObjectProperty");
            const aliased = TUnion([TNamed("MethodDefinition"), TNamed("DataProperty"), TNamed("ShorthandProperty")]);
            this["c_ObjectProperty"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_ObjectProperty"] instanceof S.Typedef);
        return this["c_ObjectProperty"] as S.Typedef;
    },
    get typeof_ObjectProperty(): S.FieldType {
        return this.ObjectProperty.aliased;
    },


    get ExportDeclaration(): S.Typedef {
        if (!this["c_ExportDeclaration"]) {
            const typeName = S.TypeName.make("ExportDeclaration");
            const aliased = TUnion([TNamed("ExportAllFrom"), TNamed("ExportFrom"), TNamed("ExportLocals"), TNamed("ExportDefault"), TNamed("Export")]);
            this["c_ExportDeclaration"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_ExportDeclaration"] instanceof S.Typedef);
        return this["c_ExportDeclaration"] as S.Typedef;
    },
    get typeof_ExportDeclaration(): S.FieldType {
        return this.ExportDeclaration.aliased;
    },


    get ImportDeclaration(): S.Typedef {
        if (!this["c_ImportDeclaration"]) {
            const typeName = S.TypeName.make("ImportDeclaration");
            const aliased = TUnion([TNamed("ImportNamespace"), TNamed("Import")]);
            this["c_ImportDeclaration"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_ImportDeclaration"] instanceof S.Typedef);
        return this["c_ImportDeclaration"] as S.Typedef;
    },
    get typeof_ImportDeclaration(): S.FieldType {
        return this.ImportDeclaration.aliased;
    },


    get FunctionDeclaration(): S.Typedef {
        if (!this["c_FunctionDeclaration"]) {
            const typeName = S.TypeName.make("FunctionDeclaration");
            const aliased = TUnion([TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration")]);
            this["c_FunctionDeclaration"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_FunctionDeclaration"] instanceof S.Typedef);
        return this["c_FunctionDeclaration"] as S.Typedef;
    },
    get typeof_FunctionDeclaration(): S.FieldType {
        return this.FunctionDeclaration.aliased;
    },


    get FunctionExpression(): S.Typedef {
        if (!this["c_FunctionExpression"]) {
            const typeName = S.TypeName.make("FunctionExpression");
            const aliased = TUnion([TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression")]);
            this["c_FunctionExpression"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_FunctionExpression"] instanceof S.Typedef);
        return this["c_FunctionExpression"] as S.Typedef;
    },
    get typeof_FunctionExpression(): S.FieldType {
        return this.FunctionExpression.aliased;
    },


    get Method(): S.Typedef {
        if (!this["c_Method"]) {
            const typeName = S.TypeName.make("Method");
            const aliased = TUnion([TNamed("EagerMethod"), TNamed("LazyMethod")]);
            this["c_Method"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Method"] instanceof S.Typedef);
        return this["c_Method"] as S.Typedef;
    },
    get typeof_Method(): S.FieldType {
        return this.Method.aliased;
    },


    get Getter(): S.Typedef {
        if (!this["c_Getter"]) {
            const typeName = S.TypeName.make("Getter");
            const aliased = TUnion([TNamed("EagerGetter"), TNamed("LazyGetter")]);
            this["c_Getter"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Getter"] instanceof S.Typedef);
        return this["c_Getter"] as S.Typedef;
    },
    get typeof_Getter(): S.FieldType {
        return this.Getter.aliased;
    },


    get Setter(): S.Typedef {
        if (!this["c_Setter"]) {
            const typeName = S.TypeName.make("Setter");
            const aliased = TUnion([TNamed("EagerSetter"), TNamed("LazySetter")]);
            this["c_Setter"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Setter"] instanceof S.Typedef);
        return this["c_Setter"] as S.Typedef;
    },
    get typeof_Setter(): S.FieldType {
        return this.Setter.aliased;
    },


    get ArrowExpression(): S.Typedef {
        if (!this["c_ArrowExpression"]) {
            const typeName = S.TypeName.make("ArrowExpression");
            const aliased = TUnion([TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression")]);
            this["c_ArrowExpression"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_ArrowExpression"] instanceof S.Typedef);
        return this["c_ArrowExpression"] as S.Typedef;
    },
    get typeof_ArrowExpression(): S.FieldType {
        return this.ArrowExpression.aliased;
    },


    get BindingIdentifier(): S.Iface {
        if (!this["c_BindingIdentifier"]) {
            const typeName = S.TypeName.make("BindingIdentifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("Identifier"),
                /* isLazy = */ false),
            ];
            this["c_BindingIdentifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BindingIdentifier"] instanceof S.Iface);
        return this["c_BindingIdentifier"] as S.Iface;
    },
    get typeof_BindingIdentifier(): S.FieldType {
        const fieldName = this.BindingIdentifier.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get BindingPattern(): S.Typedef {
        if (!this["c_BindingPattern"]) {
            const typeName = S.TypeName.make("BindingPattern");
            const aliased = TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding")]);
            this["c_BindingPattern"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_BindingPattern"] instanceof S.Typedef);
        return this["c_BindingPattern"] as S.Typedef;
    },
    get typeof_BindingPattern(): S.FieldType {
        return this.BindingPattern.aliased;
    },


    get Binding(): S.Typedef {
        if (!this["c_Binding"]) {
            const typeName = S.TypeName.make("Binding");
            const aliased = TUnion([TNamed("BindingPattern"), TNamed("BindingIdentifier")]);
            this["c_Binding"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Binding"] instanceof S.Typedef);
        return this["c_Binding"] as S.Typedef;
    },
    get typeof_Binding(): S.FieldType {
        return this.Binding.aliased;
    },


    get SimpleAssignmentTarget(): S.Typedef {
        if (!this["c_SimpleAssignmentTarget"]) {
            const typeName = S.TypeName.make("SimpleAssignmentTarget");
            const aliased = TUnion([TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")]);
            this["c_SimpleAssignmentTarget"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_SimpleAssignmentTarget"] instanceof S.Typedef);
        return this["c_SimpleAssignmentTarget"] as S.Typedef;
    },
    get typeof_SimpleAssignmentTarget(): S.FieldType {
        return this.SimpleAssignmentTarget.aliased;
    },


    get AssignmentTargetPattern(): S.Typedef {
        if (!this["c_AssignmentTargetPattern"]) {
            const typeName = S.TypeName.make("AssignmentTargetPattern");
            const aliased = TUnion([TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget")]);
            this["c_AssignmentTargetPattern"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_AssignmentTargetPattern"] instanceof S.Typedef);
        return this["c_AssignmentTargetPattern"] as S.Typedef;
    },
    get typeof_AssignmentTargetPattern(): S.FieldType {
        return this.AssignmentTargetPattern.aliased;
    },


    get AssignmentTarget(): S.Typedef {
        if (!this["c_AssignmentTarget"]) {
            const typeName = S.TypeName.make("AssignmentTarget");
            const aliased = TUnion([TNamed("AssignmentTargetPattern"), TNamed("SimpleAssignmentTarget")]);
            this["c_AssignmentTarget"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_AssignmentTarget"] instanceof S.Typedef);
        return this["c_AssignmentTarget"] as S.Typedef;
    },
    get typeof_AssignmentTarget(): S.FieldType {
        return this.AssignmentTarget.aliased;
    },


    get Parameter(): S.Typedef {
        if (!this["c_Parameter"]) {
            const typeName = S.TypeName.make("Parameter");
            const aliased = TUnion([TNamed("Binding"), TNamed("BindingWithInitializer")]);
            this["c_Parameter"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Parameter"] instanceof S.Typedef);
        return this["c_Parameter"] as S.Typedef;
    },
    get typeof_Parameter(): S.FieldType {
        return this.Parameter.aliased;
    },


    get BindingWithInitializer(): S.Iface {
        if (!this["c_BindingWithInitializer"]) {
            const typeName = S.TypeName.make("BindingWithInitializer");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("Binding"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_BindingWithInitializer"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BindingWithInitializer"] instanceof S.Iface);
        return this["c_BindingWithInitializer"] as S.Iface;
    },
    get typeof_BindingWithInitializer(): S.FieldType {
        const fieldName = this.BindingWithInitializer.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssignmentTargetIdentifier(): S.Iface {
        if (!this["c_AssignmentTargetIdentifier"]) {
            const typeName = S.TypeName.make("AssignmentTargetIdentifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("Identifier"),
                /* isLazy = */ false),
            ];
            this["c_AssignmentTargetIdentifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentTargetIdentifier"] instanceof S.Iface);
        return this["c_AssignmentTargetIdentifier"] as S.Iface;
    },
    get typeof_AssignmentTargetIdentifier(): S.FieldType {
        const fieldName = this.AssignmentTargetIdentifier.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ComputedMemberAssignmentTarget(): S.Iface {
        if (!this["c_ComputedMemberAssignmentTarget"]) {
            const typeName = S.TypeName.make("ComputedMemberAssignmentTarget");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TUnion([TNamed("Expression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_ComputedMemberAssignmentTarget"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ComputedMemberAssignmentTarget"] instanceof S.Iface);
        return this["c_ComputedMemberAssignmentTarget"] as S.Iface;
    },
    get typeof_ComputedMemberAssignmentTarget(): S.FieldType {
        const fieldName = this.ComputedMemberAssignmentTarget.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get StaticMemberAssignmentTarget(): S.Iface {
        if (!this["c_StaticMemberAssignmentTarget"]) {
            const typeName = S.TypeName.make("StaticMemberAssignmentTarget");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TUnion([TNamed("Expression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "property",
                /* ty = */ TNamed("IdentifierName"),
                /* isLazy = */ false),
            ];
            this["c_StaticMemberAssignmentTarget"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_StaticMemberAssignmentTarget"] instanceof S.Iface);
        return this["c_StaticMemberAssignmentTarget"] as S.Iface;
    },
    get typeof_StaticMemberAssignmentTarget(): S.FieldType {
        const fieldName = this.StaticMemberAssignmentTarget.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ArrayBinding(): S.Iface {
        if (!this["c_ArrayBinding"]) {
            const typeName = S.TypeName.make("ArrayBinding");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TUnion([TNull, TNamed("Binding"), TNamed("BindingWithInitializer")])),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "rest",
                /* ty = */ TUnion([TNull, TNamed("Binding")]),
                /* isLazy = */ false),
            ];
            this["c_ArrayBinding"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ArrayBinding"] instanceof S.Iface);
        return this["c_ArrayBinding"] as S.Iface;
    },
    get typeof_ArrayBinding(): S.FieldType {
        const fieldName = this.ArrayBinding.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get BindingPropertyIdentifier(): S.Iface {
        if (!this["c_BindingPropertyIdentifier"]) {
            const typeName = S.TypeName.make("BindingPropertyIdentifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            ];
            this["c_BindingPropertyIdentifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BindingPropertyIdentifier"] instanceof S.Iface);
        return this["c_BindingPropertyIdentifier"] as S.Iface;
    },
    get typeof_BindingPropertyIdentifier(): S.FieldType {
        const fieldName = this.BindingPropertyIdentifier.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get BindingPropertyProperty(): S.Iface {
        if (!this["c_BindingPropertyProperty"]) {
            const typeName = S.TypeName.make("BindingPropertyProperty");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("PropertyName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("Binding"), TNamed("BindingWithInitializer")]),
                /* isLazy = */ false),
            ];
            this["c_BindingPropertyProperty"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BindingPropertyProperty"] instanceof S.Iface);
        return this["c_BindingPropertyProperty"] as S.Iface;
    },
    get typeof_BindingPropertyProperty(): S.FieldType {
        const fieldName = this.BindingPropertyProperty.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get BindingProperty(): S.Typedef {
        if (!this["c_BindingProperty"]) {
            const typeName = S.TypeName.make("BindingProperty");
            const aliased = TUnion([TNamed("BindingPropertyIdentifier"), TNamed("BindingPropertyProperty")]);
            this["c_BindingProperty"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_BindingProperty"] instanceof S.Typedef);
        return this["c_BindingProperty"] as S.Typedef;
    },
    get typeof_BindingProperty(): S.FieldType {
        return this.BindingProperty.aliased;
    },


    get ObjectBinding(): S.Iface {
        if (!this["c_ObjectBinding"]) {
            const typeName = S.TypeName.make("ObjectBinding");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "properties",
                /* ty = */ TArray(TNamed("BindingProperty")),
                /* isLazy = */ false),
            ];
            this["c_ObjectBinding"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ObjectBinding"] instanceof S.Iface);
        return this["c_ObjectBinding"] as S.Iface;
    },
    get typeof_ObjectBinding(): S.FieldType {
        const fieldName = this.ObjectBinding.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssignmentTargetWithInitializer(): S.Iface {
        if (!this["c_AssignmentTargetWithInitializer"]) {
            const typeName = S.TypeName.make("AssignmentTargetWithInitializer");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("AssignmentTarget"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_AssignmentTargetWithInitializer"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentTargetWithInitializer"] instanceof S.Iface);
        return this["c_AssignmentTargetWithInitializer"] as S.Iface;
    },
    get typeof_AssignmentTargetWithInitializer(): S.FieldType {
        const fieldName = this.AssignmentTargetWithInitializer.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ArrayAssignmentTarget(): S.Iface {
        if (!this["c_ArrayAssignmentTarget"]) {
            const typeName = S.TypeName.make("ArrayAssignmentTarget");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TUnion([TNull, TNamed("AssignmentTarget"), TNamed("AssignmentTargetWithInitializer")])),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "rest",
                /* ty = */ TUnion([TNull, TNamed("AssignmentTarget")]),
                /* isLazy = */ false),
            ];
            this["c_ArrayAssignmentTarget"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ArrayAssignmentTarget"] instanceof S.Iface);
        return this["c_ArrayAssignmentTarget"] as S.Iface;
    },
    get typeof_ArrayAssignmentTarget(): S.FieldType {
        const fieldName = this.ArrayAssignmentTarget.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssignmentTargetPropertyIdentifier(): S.Iface {
        if (!this["c_AssignmentTargetPropertyIdentifier"]) {
            const typeName = S.TypeName.make("AssignmentTargetPropertyIdentifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("AssignmentTargetIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            ];
            this["c_AssignmentTargetPropertyIdentifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentTargetPropertyIdentifier"] instanceof S.Iface);
        return this["c_AssignmentTargetPropertyIdentifier"] as S.Iface;
    },
    get typeof_AssignmentTargetPropertyIdentifier(): S.FieldType {
        const fieldName = this.AssignmentTargetPropertyIdentifier.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssignmentTargetPropertyProperty(): S.Iface {
        if (!this["c_AssignmentTargetPropertyProperty"]) {
            const typeName = S.TypeName.make("AssignmentTargetPropertyProperty");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("PropertyName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("AssignmentTarget"), TNamed("AssignmentTargetWithInitializer")]),
                /* isLazy = */ false),
            ];
            this["c_AssignmentTargetPropertyProperty"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentTargetPropertyProperty"] instanceof S.Iface);
        return this["c_AssignmentTargetPropertyProperty"] as S.Iface;
    },
    get typeof_AssignmentTargetPropertyProperty(): S.FieldType {
        const fieldName = this.AssignmentTargetPropertyProperty.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssignmentTargetProperty(): S.Typedef {
        if (!this["c_AssignmentTargetProperty"]) {
            const typeName = S.TypeName.make("AssignmentTargetProperty");
            const aliased = TUnion([TNamed("AssignmentTargetPropertyIdentifier"), TNamed("AssignmentTargetPropertyProperty")]);
            this["c_AssignmentTargetProperty"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_AssignmentTargetProperty"] instanceof S.Typedef);
        return this["c_AssignmentTargetProperty"] as S.Typedef;
    },
    get typeof_AssignmentTargetProperty(): S.FieldType {
        return this.AssignmentTargetProperty.aliased;
    },


    get ObjectAssignmentTarget(): S.Iface {
        if (!this["c_ObjectAssignmentTarget"]) {
            const typeName = S.TypeName.make("ObjectAssignmentTarget");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "properties",
                /* ty = */ TArray(TNamed("AssignmentTargetProperty")),
                /* isLazy = */ false),
            ];
            this["c_ObjectAssignmentTarget"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ObjectAssignmentTarget"] instanceof S.Iface);
        return this["c_ObjectAssignmentTarget"] as S.Iface;
    },
    get typeof_ObjectAssignmentTarget(): S.FieldType {
        const fieldName = this.ObjectAssignmentTarget.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ClassExpression(): S.Iface {
        if (!this["c_ClassExpression"]) {
            const typeName = S.TypeName.make("ClassExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNull, TNamed("BindingIdentifier")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "super",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TNamed("ClassElement")),
                /* isLazy = */ false),
            ];
            this["c_ClassExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ClassExpression"] instanceof S.Iface);
        return this["c_ClassExpression"] as S.Iface;
    },
    get typeof_ClassExpression(): S.FieldType {
        const fieldName = this.ClassExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ClassDeclaration(): S.Iface {
        if (!this["c_ClassDeclaration"]) {
            const typeName = S.TypeName.make("ClassDeclaration");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "super",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TNamed("ClassElement")),
                /* isLazy = */ false),
            ];
            this["c_ClassDeclaration"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ClassDeclaration"] instanceof S.Iface);
        return this["c_ClassDeclaration"] as S.Iface;
    },
    get typeof_ClassDeclaration(): S.FieldType {
        const fieldName = this.ClassDeclaration.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ClassElement(): S.Iface {
        if (!this["c_ClassElement"]) {
            const typeName = S.TypeName.make("ClassElement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isStatic",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "method",
                /* ty = */ TNamed("MethodDefinition"),
                /* isLazy = */ false),
            ];
            this["c_ClassElement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ClassElement"] instanceof S.Iface);
        return this["c_ClassElement"] as S.Iface;
    },
    get typeof_ClassElement(): S.FieldType {
        const fieldName = this.ClassElement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get Module(): S.Iface {
        if (!this["c_Module"]) {
            const typeName = S.TypeName.make("Module");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "scope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "items",
                /* ty = */ TArray(TUnion([TNamed("ImportDeclaration"), TNamed("ExportDeclaration"), TNamed("Statement")])),
                /* isLazy = */ false),
            ];
            this["c_Module"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Module"] instanceof S.Iface);
        return this["c_Module"] as S.Iface;
    },
    get typeof_Module(): S.FieldType {
        const fieldName = this.Module.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get Import(): S.Iface {
        if (!this["c_Import"]) {
            const typeName = S.TypeName.make("Import");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "moduleSpecifier",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "defaultBinding",
                /* ty = */ TUnion([TNull, TNamed("BindingIdentifier")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "namedImports",
                /* ty = */ TArray(TNamed("ImportSpecifier")),
                /* isLazy = */ false),
            ];
            this["c_Import"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Import"] instanceof S.Iface);
        return this["c_Import"] as S.Iface;
    },
    get typeof_Import(): S.FieldType {
        const fieldName = this.Import.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ImportNamespace(): S.Iface {
        if (!this["c_ImportNamespace"]) {
            const typeName = S.TypeName.make("ImportNamespace");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "moduleSpecifier",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "defaultBinding",
                /* ty = */ TUnion([TNull, TNamed("BindingIdentifier")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "namespaceBinding",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            ];
            this["c_ImportNamespace"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ImportNamespace"] instanceof S.Iface);
        return this["c_ImportNamespace"] as S.Iface;
    },
    get typeof_ImportNamespace(): S.FieldType {
        const fieldName = this.ImportNamespace.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ImportSpecifier(): S.Iface {
        if (!this["c_ImportSpecifier"]) {
            const typeName = S.TypeName.make("ImportSpecifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNull, TNamed("IdentifierName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            ];
            this["c_ImportSpecifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ImportSpecifier"] instanceof S.Iface);
        return this["c_ImportSpecifier"] as S.Iface;
    },
    get typeof_ImportSpecifier(): S.FieldType {
        const fieldName = this.ImportSpecifier.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ExportAllFrom(): S.Iface {
        if (!this["c_ExportAllFrom"]) {
            const typeName = S.TypeName.make("ExportAllFrom");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "moduleSpecifier",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_ExportAllFrom"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportAllFrom"] instanceof S.Iface);
        return this["c_ExportAllFrom"] as S.Iface;
    },
    get typeof_ExportAllFrom(): S.FieldType {
        const fieldName = this.ExportAllFrom.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ExportFrom(): S.Iface {
        if (!this["c_ExportFrom"]) {
            const typeName = S.TypeName.make("ExportFrom");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "namedExports",
                /* ty = */ TArray(TNamed("ExportFromSpecifier")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "moduleSpecifier",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_ExportFrom"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportFrom"] instanceof S.Iface);
        return this["c_ExportFrom"] as S.Iface;
    },
    get typeof_ExportFrom(): S.FieldType {
        const fieldName = this.ExportFrom.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ExportLocals(): S.Iface {
        if (!this["c_ExportLocals"]) {
            const typeName = S.TypeName.make("ExportLocals");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "namedExports",
                /* ty = */ TArray(TNamed("ExportLocalSpecifier")),
                /* isLazy = */ false),
            ];
            this["c_ExportLocals"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportLocals"] instanceof S.Iface);
        return this["c_ExportLocals"] as S.Iface;
    },
    get typeof_ExportLocals(): S.FieldType {
        const fieldName = this.ExportLocals.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get Export(): S.Iface {
        if (!this["c_Export"]) {
            const typeName = S.TypeName.make("Export");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "declaration",
                /* ty = */ TUnion([TNamed("FunctionDeclaration"), TNamed("ClassDeclaration"), TNamed("VariableDeclaration")]),
                /* isLazy = */ false),
            ];
            this["c_Export"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Export"] instanceof S.Iface);
        return this["c_Export"] as S.Iface;
    },
    get typeof_Export(): S.FieldType {
        const fieldName = this.Export.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ExportDefault(): S.Iface {
        if (!this["c_ExportDefault"]) {
            const typeName = S.TypeName.make("ExportDefault");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("FunctionDeclaration"), TNamed("ClassDeclaration"), TNamed("Expression")]),
                /* isLazy = */ false),
            ];
            this["c_ExportDefault"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportDefault"] instanceof S.Iface);
        return this["c_ExportDefault"] as S.Iface;
    },
    get typeof_ExportDefault(): S.FieldType {
        const fieldName = this.ExportDefault.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ExportFromSpecifier(): S.Iface {
        if (!this["c_ExportFromSpecifier"]) {
            const typeName = S.TypeName.make("ExportFromSpecifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("IdentifierName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "exportedName",
                /* ty = */ TUnion([TNull, TNamed("IdentifierName")]),
                /* isLazy = */ false),
            ];
            this["c_ExportFromSpecifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportFromSpecifier"] instanceof S.Iface);
        return this["c_ExportFromSpecifier"] as S.Iface;
    },
    get typeof_ExportFromSpecifier(): S.FieldType {
        const fieldName = this.ExportFromSpecifier.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ExportLocalSpecifier(): S.Iface {
        if (!this["c_ExportLocalSpecifier"]) {
            const typeName = S.TypeName.make("ExportLocalSpecifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("IdentifierExpression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "exportedName",
                /* ty = */ TUnion([TNull, TNamed("IdentifierName")]),
                /* isLazy = */ false),
            ];
            this["c_ExportLocalSpecifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportLocalSpecifier"] instanceof S.Iface);
        return this["c_ExportLocalSpecifier"] as S.Iface;
    },
    get typeof_ExportLocalSpecifier(): S.FieldType {
        const fieldName = this.ExportLocalSpecifier.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get EagerMethod(): S.Iface {
        if (!this["c_EagerMethod"]) {
            const typeName = S.TypeName.make("EagerMethod");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("PropertyName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionOrMethodContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerMethod"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerMethod"] instanceof S.Iface);
        return this["c_EagerMethod"] as S.Iface;
    },
    get typeof_EagerMethod(): S.FieldType {
        const fieldName = this.EagerMethod.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LazyMethod(): S.Iface {
        if (!this["c_LazyMethod"]) {
            const typeName = S.TypeName.make("LazyMethod");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("PropertyName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionOrMethodContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyMethod"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyMethod"] instanceof S.Iface);
        return this["c_LazyMethod"] as S.Iface;
    },
    get typeof_LazyMethod(): S.FieldType {
        const fieldName = this.LazyMethod.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get EagerGetter(): S.Iface {
        if (!this["c_EagerGetter"]) {
            const typeName = S.TypeName.make("EagerGetter");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("PropertyName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("GetterContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerGetter"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerGetter"] instanceof S.Iface);
        return this["c_EagerGetter"] as S.Iface;
    },
    get typeof_EagerGetter(): S.FieldType {
        const fieldName = this.EagerGetter.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LazyGetter(): S.Iface {
        if (!this["c_LazyGetter"]) {
            const typeName = S.TypeName.make("LazyGetter");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("PropertyName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("GetterContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyGetter"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyGetter"] instanceof S.Iface);
        return this["c_LazyGetter"] as S.Iface;
    },
    get typeof_LazyGetter(): S.FieldType {
        const fieldName = this.LazyGetter.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get GetterContents(): S.Iface {
        if (!this["c_GetterContents"]) {
            const typeName = S.TypeName.make("GetterContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isThisCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("FunctionBody"),
                /* isLazy = */ false),
            ];
            this["c_GetterContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_GetterContents"] instanceof S.Iface);
        return this["c_GetterContents"] as S.Iface;
    },
    get typeof_GetterContents(): S.FieldType {
        const fieldName = this.GetterContents.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get EagerSetter(): S.Iface {
        if (!this["c_EagerSetter"]) {
            const typeName = S.TypeName.make("EagerSetter");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("PropertyName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("SetterContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerSetter"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerSetter"] instanceof S.Iface);
        return this["c_EagerSetter"] as S.Iface;
    },
    get typeof_EagerSetter(): S.FieldType {
        const fieldName = this.EagerSetter.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LazySetter(): S.Iface {
        if (!this["c_LazySetter"]) {
            const typeName = S.TypeName.make("LazySetter");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("PropertyName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("SetterContents"),
                /* isLazy = */ false),
            ];
            this["c_LazySetter"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazySetter"] instanceof S.Iface);
        return this["c_LazySetter"] as S.Iface;
    },
    get typeof_LazySetter(): S.FieldType {
        const fieldName = this.LazySetter.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get SetterContents(): S.Iface {
        if (!this["c_SetterContents"]) {
            const typeName = S.TypeName.make("SetterContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isThisCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "parameterScope",
                /* ty = */ TNamed("AssertedParameterScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "param",
                /* ty = */ TNamed("Parameter"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("FunctionBody"),
                /* isLazy = */ false),
            ];
            this["c_SetterContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SetterContents"] instanceof S.Iface);
        return this["c_SetterContents"] as S.Iface;
    },
    get typeof_SetterContents(): S.FieldType {
        const fieldName = this.SetterContents.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get DataProperty(): S.Iface {
        if (!this["c_DataProperty"]) {
            const typeName = S.TypeName.make("DataProperty");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("PropertyName"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_DataProperty"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_DataProperty"] instanceof S.Iface);
        return this["c_DataProperty"] as S.Iface;
    },
    get typeof_DataProperty(): S.FieldType {
        const fieldName = this.DataProperty.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ShorthandProperty(): S.Iface {
        if (!this["c_ShorthandProperty"]) {
            const typeName = S.TypeName.make("ShorthandProperty");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("IdentifierExpression"),
                /* isLazy = */ false),
            ];
            this["c_ShorthandProperty"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ShorthandProperty"] instanceof S.Iface);
        return this["c_ShorthandProperty"] as S.Iface;
    },
    get typeof_ShorthandProperty(): S.FieldType {
        const fieldName = this.ShorthandProperty.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ComputedPropertyName(): S.Iface {
        if (!this["c_ComputedPropertyName"]) {
            const typeName = S.TypeName.make("ComputedPropertyName");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_ComputedPropertyName"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ComputedPropertyName"] instanceof S.Iface);
        return this["c_ComputedPropertyName"] as S.Iface;
    },
    get typeof_ComputedPropertyName(): S.FieldType {
        const fieldName = this.ComputedPropertyName.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LiteralPropertyName(): S.Iface {
        if (!this["c_LiteralPropertyName"]) {
            const typeName = S.TypeName.make("LiteralPropertyName");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "value",
                /* ty = */ TNamed("PropertyString"),
                /* isLazy = */ false),
            ];
            this["c_LiteralPropertyName"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralPropertyName"] instanceof S.Iface);
        return this["c_LiteralPropertyName"] as S.Iface;
    },
    get typeof_LiteralPropertyName(): S.FieldType {
        const fieldName = this.LiteralPropertyName.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LiteralBooleanExpression(): S.Iface {
        if (!this["c_LiteralBooleanExpression"]) {
            const typeName = S.TypeName.make("LiteralBooleanExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "value",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_LiteralBooleanExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralBooleanExpression"] instanceof S.Iface);
        return this["c_LiteralBooleanExpression"] as S.Iface;
    },
    get typeof_LiteralBooleanExpression(): S.FieldType {
        const fieldName = this.LiteralBooleanExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LiteralInfinityExpression(): S.Iface {
        if (!this["c_LiteralInfinityExpression"]) {
            const typeName = S.TypeName.make("LiteralInfinityExpression");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_LiteralInfinityExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralInfinityExpression"] instanceof S.Iface);
        return this["c_LiteralInfinityExpression"] as S.Iface;
    },
    get typeof_LiteralInfinityExpression(): S.FieldType {
        const fieldName = this.LiteralInfinityExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LiteralNullExpression(): S.Iface {
        if (!this["c_LiteralNullExpression"]) {
            const typeName = S.TypeName.make("LiteralNullExpression");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_LiteralNullExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralNullExpression"] instanceof S.Iface);
        return this["c_LiteralNullExpression"] as S.Iface;
    },
    get typeof_LiteralNullExpression(): S.FieldType {
        const fieldName = this.LiteralNullExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LiteralNumericExpression(): S.Iface {
        if (!this["c_LiteralNumericExpression"]) {
            const typeName = S.TypeName.make("LiteralNumericExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "value",
                /* ty = */ TF64,
                /* isLazy = */ false),
            ];
            this["c_LiteralNumericExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralNumericExpression"] instanceof S.Iface);
        return this["c_LiteralNumericExpression"] as S.Iface;
    },
    get typeof_LiteralNumericExpression(): S.FieldType {
        const fieldName = this.LiteralNumericExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LiteralRegExpExpression(): S.Iface {
        if (!this["c_LiteralRegExpExpression"]) {
            const typeName = S.TypeName.make("LiteralRegExpExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "pattern",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "flags",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_LiteralRegExpExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralRegExpExpression"] instanceof S.Iface);
        return this["c_LiteralRegExpExpression"] as S.Iface;
    },
    get typeof_LiteralRegExpExpression(): S.FieldType {
        const fieldName = this.LiteralRegExpExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LiteralStringExpression(): S.Iface {
        if (!this["c_LiteralStringExpression"]) {
            const typeName = S.TypeName.make("LiteralStringExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "value",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_LiteralStringExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralStringExpression"] instanceof S.Iface);
        return this["c_LiteralStringExpression"] as S.Iface;
    },
    get typeof_LiteralStringExpression(): S.FieldType {
        const fieldName = this.LiteralStringExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ArrayExpression(): S.Iface {
        if (!this["c_ArrayExpression"]) {
            const typeName = S.TypeName.make("ArrayExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TUnion([TNull, TNamed("SpreadElement"), TNamed("Expression")])),
                /* isLazy = */ false),
            ];
            this["c_ArrayExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ArrayExpression"] instanceof S.Iface);
        return this["c_ArrayExpression"] as S.Iface;
    },
    get typeof_ArrayExpression(): S.FieldType {
        const fieldName = this.ArrayExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get EagerArrowExpression(): S.Iface {
        if (!this["c_EagerArrowExpression"]) {
            const typeName = S.TypeName.make("EagerArrowExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TUnion([TNull, TArray(TNamed("Directive"))]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("ArrowExpressionContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerArrowExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerArrowExpression"] instanceof S.Iface);
        return this["c_EagerArrowExpression"] as S.Iface;
    },
    get typeof_EagerArrowExpression(): S.FieldType {
        const fieldName = this.EagerArrowExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LazyArrowExpression(): S.Iface {
        if (!this["c_LazyArrowExpression"]) {
            const typeName = S.TypeName.make("LazyArrowExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TUnion([TNull, TArray(TNamed("Directive"))]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("ArrowExpressionContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyArrowExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyArrowExpression"] instanceof S.Iface);
        return this["c_LazyArrowExpression"] as S.Iface;
    },
    get typeof_LazyArrowExpression(): S.FieldType {
        const fieldName = this.LazyArrowExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ArrowExpressionContents(): S.Iface {
        if (!this["c_ArrowExpressionContents"]) {
            const typeName = S.TypeName.make("ArrowExpressionContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "parameterScope",
                /* ty = */ TNamed("AssertedParameterScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "params",
                /* ty = */ TNamed("FormalParameters"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("FunctionBody"), TNamed("Expression")]),
                /* isLazy = */ false),
            ];
            this["c_ArrowExpressionContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ArrowExpressionContents"] instanceof S.Iface);
        return this["c_ArrowExpressionContents"] as S.Iface;
    },
    get typeof_ArrowExpressionContents(): S.FieldType {
        const fieldName = this.ArrowExpressionContents.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AssignmentExpression(): S.Iface {
        if (!this["c_AssignmentExpression"]) {
            const typeName = S.TypeName.make("AssignmentExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("AssignmentTarget"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_AssignmentExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentExpression"] instanceof S.Iface);
        return this["c_AssignmentExpression"] as S.Iface;
    },
    get typeof_AssignmentExpression(): S.FieldType {
        const fieldName = this.AssignmentExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get BinaryExpression(): S.Iface {
        if (!this["c_BinaryExpression"]) {
            const typeName = S.TypeName.make("BinaryExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "operator",
                /* ty = */ TNamed("BinaryOperator"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "left",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "right",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_BinaryExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BinaryExpression"] instanceof S.Iface);
        return this["c_BinaryExpression"] as S.Iface;
    },
    get typeof_BinaryExpression(): S.FieldType {
        const fieldName = this.BinaryExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get CallExpression(): S.Iface {
        if (!this["c_CallExpression"]) {
            const typeName = S.TypeName.make("CallExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "callee",
                /* ty = */ TUnion([TNamed("Expression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "arguments",
                /* ty = */ TNamed("Arguments"),
                /* isLazy = */ false),
            ];
            this["c_CallExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_CallExpression"] instanceof S.Iface);
        return this["c_CallExpression"] as S.Iface;
    },
    get typeof_CallExpression(): S.FieldType {
        const fieldName = this.CallExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get CompoundAssignmentExpression(): S.Iface {
        if (!this["c_CompoundAssignmentExpression"]) {
            const typeName = S.TypeName.make("CompoundAssignmentExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "operator",
                /* ty = */ TNamed("CompoundAssignmentOperator"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("SimpleAssignmentTarget"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_CompoundAssignmentExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_CompoundAssignmentExpression"] instanceof S.Iface);
        return this["c_CompoundAssignmentExpression"] as S.Iface;
    },
    get typeof_CompoundAssignmentExpression(): S.FieldType {
        const fieldName = this.CompoundAssignmentExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ComputedMemberExpression(): S.Iface {
        if (!this["c_ComputedMemberExpression"]) {
            const typeName = S.TypeName.make("ComputedMemberExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TUnion([TNamed("Expression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_ComputedMemberExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ComputedMemberExpression"] instanceof S.Iface);
        return this["c_ComputedMemberExpression"] as S.Iface;
    },
    get typeof_ComputedMemberExpression(): S.FieldType {
        const fieldName = this.ComputedMemberExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ConditionalExpression(): S.Iface {
        if (!this["c_ConditionalExpression"]) {
            const typeName = S.TypeName.make("ConditionalExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "consequent",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "alternate",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_ConditionalExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ConditionalExpression"] instanceof S.Iface);
        return this["c_ConditionalExpression"] as S.Iface;
    },
    get typeof_ConditionalExpression(): S.FieldType {
        const fieldName = this.ConditionalExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get EagerFunctionExpression(): S.Iface {
        if (!this["c_EagerFunctionExpression"]) {
            const typeName = S.TypeName.make("EagerFunctionExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNull, TNamed("BindingIdentifier")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionExpressionContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerFunctionExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerFunctionExpression"] instanceof S.Iface);
        return this["c_EagerFunctionExpression"] as S.Iface;
    },
    get typeof_EagerFunctionExpression(): S.FieldType {
        const fieldName = this.EagerFunctionExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LazyFunctionExpression(): S.Iface {
        if (!this["c_LazyFunctionExpression"]) {
            const typeName = S.TypeName.make("LazyFunctionExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNull, TNamed("BindingIdentifier")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionExpressionContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyFunctionExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyFunctionExpression"] instanceof S.Iface);
        return this["c_LazyFunctionExpression"] as S.Iface;
    },
    get typeof_LazyFunctionExpression(): S.FieldType {
        const fieldName = this.LazyFunctionExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get FunctionExpressionContents(): S.Iface {
        if (!this["c_FunctionExpressionContents"]) {
            const typeName = S.TypeName.make("FunctionExpressionContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isFunctionNameCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isThisCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "parameterScope",
                /* ty = */ TNamed("AssertedParameterScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "params",
                /* ty = */ TNamed("FormalParameters"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("FunctionBody"),
                /* isLazy = */ false),
            ];
            this["c_FunctionExpressionContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_FunctionExpressionContents"] instanceof S.Iface);
        return this["c_FunctionExpressionContents"] as S.Iface;
    },
    get typeof_FunctionExpressionContents(): S.FieldType {
        const fieldName = this.FunctionExpressionContents.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get IdentifierExpression(): S.Iface {
        if (!this["c_IdentifierExpression"]) {
            const typeName = S.TypeName.make("IdentifierExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("Identifier"),
                /* isLazy = */ false),
            ];
            this["c_IdentifierExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_IdentifierExpression"] instanceof S.Iface);
        return this["c_IdentifierExpression"] as S.Iface;
    },
    get typeof_IdentifierExpression(): S.FieldType {
        const fieldName = this.IdentifierExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get NewExpression(): S.Iface {
        if (!this["c_NewExpression"]) {
            const typeName = S.TypeName.make("NewExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "callee",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "arguments",
                /* ty = */ TNamed("Arguments"),
                /* isLazy = */ false),
            ];
            this["c_NewExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_NewExpression"] instanceof S.Iface);
        return this["c_NewExpression"] as S.Iface;
    },
    get typeof_NewExpression(): S.FieldType {
        const fieldName = this.NewExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get NewTargetExpression(): S.Iface {
        if (!this["c_NewTargetExpression"]) {
            const typeName = S.TypeName.make("NewTargetExpression");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_NewTargetExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_NewTargetExpression"] instanceof S.Iface);
        return this["c_NewTargetExpression"] as S.Iface;
    },
    get typeof_NewTargetExpression(): S.FieldType {
        const fieldName = this.NewTargetExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ObjectExpression(): S.Iface {
        if (!this["c_ObjectExpression"]) {
            const typeName = S.TypeName.make("ObjectExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "properties",
                /* ty = */ TArray(TNamed("ObjectProperty")),
                /* isLazy = */ false),
            ];
            this["c_ObjectExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ObjectExpression"] instanceof S.Iface);
        return this["c_ObjectExpression"] as S.Iface;
    },
    get typeof_ObjectExpression(): S.FieldType {
        const fieldName = this.ObjectExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get UnaryExpression(): S.Iface {
        if (!this["c_UnaryExpression"]) {
            const typeName = S.TypeName.make("UnaryExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "operator",
                /* ty = */ TNamed("UnaryOperator"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "operand",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_UnaryExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_UnaryExpression"] instanceof S.Iface);
        return this["c_UnaryExpression"] as S.Iface;
    },
    get typeof_UnaryExpression(): S.FieldType {
        const fieldName = this.UnaryExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get StaticMemberExpression(): S.Iface {
        if (!this["c_StaticMemberExpression"]) {
            const typeName = S.TypeName.make("StaticMemberExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TUnion([TNamed("Expression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "property",
                /* ty = */ TNamed("IdentifierName"),
                /* isLazy = */ false),
            ];
            this["c_StaticMemberExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_StaticMemberExpression"] instanceof S.Iface);
        return this["c_StaticMemberExpression"] as S.Iface;
    },
    get typeof_StaticMemberExpression(): S.FieldType {
        const fieldName = this.StaticMemberExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get TemplateExpression(): S.Iface {
        if (!this["c_TemplateExpression"]) {
            const typeName = S.TypeName.make("TemplateExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "tag",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TUnion([TNamed("Expression"), TNamed("TemplateElement")])),
                /* isLazy = */ false),
            ];
            this["c_TemplateExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_TemplateExpression"] instanceof S.Iface);
        return this["c_TemplateExpression"] as S.Iface;
    },
    get typeof_TemplateExpression(): S.FieldType {
        const fieldName = this.TemplateExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ThisExpression(): S.Iface {
        if (!this["c_ThisExpression"]) {
            const typeName = S.TypeName.make("ThisExpression");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_ThisExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ThisExpression"] instanceof S.Iface);
        return this["c_ThisExpression"] as S.Iface;
    },
    get typeof_ThisExpression(): S.FieldType {
        const fieldName = this.ThisExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get UpdateExpression(): S.Iface {
        if (!this["c_UpdateExpression"]) {
            const typeName = S.TypeName.make("UpdateExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isPrefix",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "operator",
                /* ty = */ TNamed("UpdateOperator"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "operand",
                /* ty = */ TNamed("SimpleAssignmentTarget"),
                /* isLazy = */ false),
            ];
            this["c_UpdateExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_UpdateExpression"] instanceof S.Iface);
        return this["c_UpdateExpression"] as S.Iface;
    },
    get typeof_UpdateExpression(): S.FieldType {
        const fieldName = this.UpdateExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get YieldExpression(): S.Iface {
        if (!this["c_YieldExpression"]) {
            const typeName = S.TypeName.make("YieldExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            ];
            this["c_YieldExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_YieldExpression"] instanceof S.Iface);
        return this["c_YieldExpression"] as S.Iface;
    },
    get typeof_YieldExpression(): S.FieldType {
        const fieldName = this.YieldExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get YieldStarExpression(): S.Iface {
        if (!this["c_YieldStarExpression"]) {
            const typeName = S.TypeName.make("YieldStarExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_YieldStarExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_YieldStarExpression"] instanceof S.Iface);
        return this["c_YieldStarExpression"] as S.Iface;
    },
    get typeof_YieldStarExpression(): S.FieldType {
        const fieldName = this.YieldStarExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get AwaitExpression(): S.Iface {
        if (!this["c_AwaitExpression"]) {
            const typeName = S.TypeName.make("AwaitExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_AwaitExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AwaitExpression"] instanceof S.Iface);
        return this["c_AwaitExpression"] as S.Iface;
    },
    get typeof_AwaitExpression(): S.FieldType {
        const fieldName = this.AwaitExpression.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get BreakStatement(): S.Iface {
        if (!this["c_BreakStatement"]) {
            const typeName = S.TypeName.make("BreakStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "label",
                /* ty = */ TUnion([TNull, TNamed("Label")]),
                /* isLazy = */ false),
            ];
            this["c_BreakStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BreakStatement"] instanceof S.Iface);
        return this["c_BreakStatement"] as S.Iface;
    },
    get typeof_BreakStatement(): S.FieldType {
        const fieldName = this.BreakStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ContinueStatement(): S.Iface {
        if (!this["c_ContinueStatement"]) {
            const typeName = S.TypeName.make("ContinueStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "label",
                /* ty = */ TUnion([TNull, TNamed("Label")]),
                /* isLazy = */ false),
            ];
            this["c_ContinueStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ContinueStatement"] instanceof S.Iface);
        return this["c_ContinueStatement"] as S.Iface;
    },
    get typeof_ContinueStatement(): S.FieldType {
        const fieldName = this.ContinueStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get DebuggerStatement(): S.Iface {
        if (!this["c_DebuggerStatement"]) {
            const typeName = S.TypeName.make("DebuggerStatement");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_DebuggerStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_DebuggerStatement"] instanceof S.Iface);
        return this["c_DebuggerStatement"] as S.Iface;
    },
    get typeof_DebuggerStatement(): S.FieldType {
        const fieldName = this.DebuggerStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get DoWhileStatement(): S.Iface {
        if (!this["c_DoWhileStatement"]) {
            const typeName = S.TypeName.make("DoWhileStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Statement"),
                /* isLazy = */ false),
            ];
            this["c_DoWhileStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_DoWhileStatement"] instanceof S.Iface);
        return this["c_DoWhileStatement"] as S.Iface;
    },
    get typeof_DoWhileStatement(): S.FieldType {
        const fieldName = this.DoWhileStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get EmptyStatement(): S.Iface {
        if (!this["c_EmptyStatement"]) {
            const typeName = S.TypeName.make("EmptyStatement");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_EmptyStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EmptyStatement"] instanceof S.Iface);
        return this["c_EmptyStatement"] as S.Iface;
    },
    get typeof_EmptyStatement(): S.FieldType {
        const fieldName = this.EmptyStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ExpressionStatement(): S.Iface {
        if (!this["c_ExpressionStatement"]) {
            const typeName = S.TypeName.make("ExpressionStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_ExpressionStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExpressionStatement"] instanceof S.Iface);
        return this["c_ExpressionStatement"] as S.Iface;
    },
    get typeof_ExpressionStatement(): S.FieldType {
        const fieldName = this.ExpressionStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ForInOfBinding(): S.Iface {
        if (!this["c_ForInOfBinding"]) {
            const typeName = S.TypeName.make("ForInOfBinding");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "kind",
                /* ty = */ TNamed("VariableDeclarationKind"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("Binding"),
                /* isLazy = */ false),
            ];
            this["c_ForInOfBinding"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ForInOfBinding"] instanceof S.Iface);
        return this["c_ForInOfBinding"] as S.Iface;
    },
    get typeof_ForInOfBinding(): S.FieldType {
        const fieldName = this.ForInOfBinding.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ForInStatement(): S.Iface {
        if (!this["c_ForInStatement"]) {
            const typeName = S.TypeName.make("ForInStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "left",
                /* ty = */ TUnion([TNamed("ForInOfBinding"), TNamed("AssignmentTarget")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "right",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Statement"),
                /* isLazy = */ false),
            ];
            this["c_ForInStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ForInStatement"] instanceof S.Iface);
        return this["c_ForInStatement"] as S.Iface;
    },
    get typeof_ForInStatement(): S.FieldType {
        const fieldName = this.ForInStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ForOfStatement(): S.Iface {
        if (!this["c_ForOfStatement"]) {
            const typeName = S.TypeName.make("ForOfStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "left",
                /* ty = */ TUnion([TNamed("ForInOfBinding"), TNamed("AssignmentTarget")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "right",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Statement"),
                /* isLazy = */ false),
            ];
            this["c_ForOfStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ForOfStatement"] instanceof S.Iface);
        return this["c_ForOfStatement"] as S.Iface;
    },
    get typeof_ForOfStatement(): S.FieldType {
        const fieldName = this.ForOfStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ForStatement(): S.Iface {
        if (!this["c_ForStatement"]) {
            const typeName = S.TypeName.make("ForStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TUnion([TNull, TNamed("VariableDeclaration"), TNamed("Expression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "update",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Statement"),
                /* isLazy = */ false),
            ];
            this["c_ForStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ForStatement"] instanceof S.Iface);
        return this["c_ForStatement"] as S.Iface;
    },
    get typeof_ForStatement(): S.FieldType {
        const fieldName = this.ForStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get IfStatement(): S.Iface {
        if (!this["c_IfStatement"]) {
            const typeName = S.TypeName.make("IfStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "consequent",
                /* ty = */ TNamed("Statement"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "alternate",
                /* ty = */ TUnion([TNull, TNamed("Statement")]),
                /* isLazy = */ false),
            ];
            this["c_IfStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_IfStatement"] instanceof S.Iface);
        return this["c_IfStatement"] as S.Iface;
    },
    get typeof_IfStatement(): S.FieldType {
        const fieldName = this.IfStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LabelledStatement(): S.Iface {
        if (!this["c_LabelledStatement"]) {
            const typeName = S.TypeName.make("LabelledStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "label",
                /* ty = */ TNamed("Label"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Statement"),
                /* isLazy = */ false),
            ];
            this["c_LabelledStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LabelledStatement"] instanceof S.Iface);
        return this["c_LabelledStatement"] as S.Iface;
    },
    get typeof_LabelledStatement(): S.FieldType {
        const fieldName = this.LabelledStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ReturnStatement(): S.Iface {
        if (!this["c_ReturnStatement"]) {
            const typeName = S.TypeName.make("ReturnStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            ];
            this["c_ReturnStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ReturnStatement"] instanceof S.Iface);
        return this["c_ReturnStatement"] as S.Iface;
    },
    get typeof_ReturnStatement(): S.FieldType {
        const fieldName = this.ReturnStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get SwitchStatement(): S.Iface {
        if (!this["c_SwitchStatement"]) {
            const typeName = S.TypeName.make("SwitchStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "discriminant",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "cases",
                /* ty = */ TArray(TNamed("SwitchCase")),
                /* isLazy = */ false),
            ];
            this["c_SwitchStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SwitchStatement"] instanceof S.Iface);
        return this["c_SwitchStatement"] as S.Iface;
    },
    get typeof_SwitchStatement(): S.FieldType {
        const fieldName = this.SwitchStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get SwitchStatementWithDefault(): S.Iface {
        if (!this["c_SwitchStatementWithDefault"]) {
            const typeName = S.TypeName.make("SwitchStatementWithDefault");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "discriminant",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "preDefaultCases",
                /* ty = */ TArray(TNamed("SwitchCase")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "defaultCase",
                /* ty = */ TNamed("SwitchDefault"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "postDefaultCases",
                /* ty = */ TArray(TNamed("SwitchCase")),
                /* isLazy = */ false),
            ];
            this["c_SwitchStatementWithDefault"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SwitchStatementWithDefault"] instanceof S.Iface);
        return this["c_SwitchStatementWithDefault"] as S.Iface;
    },
    get typeof_SwitchStatementWithDefault(): S.FieldType {
        const fieldName = this.SwitchStatementWithDefault.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get ThrowStatement(): S.Iface {
        if (!this["c_ThrowStatement"]) {
            const typeName = S.TypeName.make("ThrowStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_ThrowStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ThrowStatement"] instanceof S.Iface);
        return this["c_ThrowStatement"] as S.Iface;
    },
    get typeof_ThrowStatement(): S.FieldType {
        const fieldName = this.ThrowStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get TryCatchStatement(): S.Iface {
        if (!this["c_TryCatchStatement"]) {
            const typeName = S.TypeName.make("TryCatchStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Block"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "catchClause",
                /* ty = */ TNamed("CatchClause"),
                /* isLazy = */ false),
            ];
            this["c_TryCatchStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_TryCatchStatement"] instanceof S.Iface);
        return this["c_TryCatchStatement"] as S.Iface;
    },
    get typeof_TryCatchStatement(): S.FieldType {
        const fieldName = this.TryCatchStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get TryFinallyStatement(): S.Iface {
        if (!this["c_TryFinallyStatement"]) {
            const typeName = S.TypeName.make("TryFinallyStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Block"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "catchClause",
                /* ty = */ TUnion([TNull, TNamed("CatchClause")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "finalizer",
                /* ty = */ TNamed("Block"),
                /* isLazy = */ false),
            ];
            this["c_TryFinallyStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_TryFinallyStatement"] instanceof S.Iface);
        return this["c_TryFinallyStatement"] as S.Iface;
    },
    get typeof_TryFinallyStatement(): S.FieldType {
        const fieldName = this.TryFinallyStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get WhileStatement(): S.Iface {
        if (!this["c_WhileStatement"]) {
            const typeName = S.TypeName.make("WhileStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Statement"),
                /* isLazy = */ false),
            ];
            this["c_WhileStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_WhileStatement"] instanceof S.Iface);
        return this["c_WhileStatement"] as S.Iface;
    },
    get typeof_WhileStatement(): S.FieldType {
        const fieldName = this.WhileStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get WithStatement(): S.Iface {
        if (!this["c_WithStatement"]) {
            const typeName = S.TypeName.make("WithStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Statement"),
                /* isLazy = */ false),
            ];
            this["c_WithStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_WithStatement"] instanceof S.Iface);
        return this["c_WithStatement"] as S.Iface;
    },
    get typeof_WithStatement(): S.FieldType {
        const fieldName = this.WithStatement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get Block(): S.Iface {
        if (!this["c_Block"]) {
            const typeName = S.TypeName.make("Block");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "scope",
                /* ty = */ TNamed("AssertedBlockScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "statements",
                /* ty = */ TArray(TNamed("Statement")),
                /* isLazy = */ false),
            ];
            this["c_Block"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Block"] instanceof S.Iface);
        return this["c_Block"] as S.Iface;
    },
    get typeof_Block(): S.FieldType {
        const fieldName = this.Block.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get CatchClause(): S.Iface {
        if (!this["c_CatchClause"]) {
            const typeName = S.TypeName.make("CatchClause");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "bindingScope",
                /* ty = */ TNamed("AssertedBoundNamesScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("Binding"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Block"),
                /* isLazy = */ false),
            ];
            this["c_CatchClause"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_CatchClause"] instanceof S.Iface);
        return this["c_CatchClause"] as S.Iface;
    },
    get typeof_CatchClause(): S.FieldType {
        const fieldName = this.CatchClause.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get Directive(): S.Iface {
        if (!this["c_Directive"]) {
            const typeName = S.TypeName.make("Directive");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "rawValue",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_Directive"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Directive"] instanceof S.Iface);
        return this["c_Directive"] as S.Iface;
    },
    get typeof_Directive(): S.FieldType {
        const fieldName = this.Directive.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get FormalParameters(): S.Iface {
        if (!this["c_FormalParameters"]) {
            const typeName = S.TypeName.make("FormalParameters");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "items",
                /* ty = */ TArray(TNamed("Parameter")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "rest",
                /* ty = */ TUnion([TNull, TNamed("Binding")]),
                /* isLazy = */ false),
            ];
            this["c_FormalParameters"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_FormalParameters"] instanceof S.Iface);
        return this["c_FormalParameters"] as S.Iface;
    },
    get typeof_FormalParameters(): S.FieldType {
        const fieldName = this.FormalParameters.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get FunctionBody(): S.Typedef {
        if (!this["c_FunctionBody"]) {
            const typeName = S.TypeName.make("FunctionBody");
            const aliased = TArray(TNamed("Statement"));
            this["c_FunctionBody"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_FunctionBody"] instanceof S.Typedef);
        return this["c_FunctionBody"] as S.Typedef;
    },
    get typeof_FunctionBody(): S.FieldType {
        return this.FunctionBody.aliased;
    },


    get EagerFunctionDeclaration(): S.Iface {
        if (!this["c_EagerFunctionDeclaration"]) {
            const typeName = S.TypeName.make("EagerFunctionDeclaration");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionOrMethodContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerFunctionDeclaration"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerFunctionDeclaration"] instanceof S.Iface);
        return this["c_EagerFunctionDeclaration"] as S.Iface;
    },
    get typeof_EagerFunctionDeclaration(): S.FieldType {
        const fieldName = this.EagerFunctionDeclaration.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get LazyFunctionDeclaration(): S.Iface {
        if (!this["c_LazyFunctionDeclaration"]) {
            const typeName = S.TypeName.make("LazyFunctionDeclaration");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "content",
                /* ty = */ TNamed("FunctionOrMethodContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyFunctionDeclaration"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyFunctionDeclaration"] instanceof S.Iface);
        return this["c_LazyFunctionDeclaration"] as S.Iface;
    },
    get typeof_LazyFunctionDeclaration(): S.FieldType {
        const fieldName = this.LazyFunctionDeclaration.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get FunctionOrMethodContents(): S.Iface {
        if (!this["c_FunctionOrMethodContents"]) {
            const typeName = S.TypeName.make("FunctionOrMethodContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isThisCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "parameterScope",
                /* ty = */ TNamed("AssertedParameterScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "params",
                /* ty = */ TNamed("FormalParameters"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("FunctionBody"),
                /* isLazy = */ false),
            ];
            this["c_FunctionOrMethodContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_FunctionOrMethodContents"] instanceof S.Iface);
        return this["c_FunctionOrMethodContents"] as S.Iface;
    },
    get typeof_FunctionOrMethodContents(): S.FieldType {
        const fieldName = this.FunctionOrMethodContents.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get Script(): S.Iface {
        if (!this["c_Script"]) {
            const typeName = S.TypeName.make("Script");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "scope",
                /* ty = */ TNamed("AssertedScriptGlobalScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "statements",
                /* ty = */ TArray(TNamed("Statement")),
                /* isLazy = */ false),
            ];
            this["c_Script"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Script"] instanceof S.Iface);
        return this["c_Script"] as S.Iface;
    },
    get typeof_Script(): S.FieldType {
        const fieldName = this.Script.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get SpreadElement(): S.Iface {
        if (!this["c_SpreadElement"]) {
            const typeName = S.TypeName.make("SpreadElement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            ];
            this["c_SpreadElement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SpreadElement"] instanceof S.Iface);
        return this["c_SpreadElement"] as S.Iface;
    },
    get typeof_SpreadElement(): S.FieldType {
        const fieldName = this.SpreadElement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get Super(): S.Iface {
        if (!this["c_Super"]) {
            const typeName = S.TypeName.make("Super");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_Super"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Super"] instanceof S.Iface);
        return this["c_Super"] as S.Iface;
    },
    get typeof_Super(): S.FieldType {
        const fieldName = this.Super.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get SwitchCase(): S.Iface {
        if (!this["c_SwitchCase"]) {
            const typeName = S.TypeName.make("SwitchCase");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TNamed("Expression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "consequent",
                /* ty = */ TArray(TNamed("Statement")),
                /* isLazy = */ false),
            ];
            this["c_SwitchCase"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SwitchCase"] instanceof S.Iface);
        return this["c_SwitchCase"] as S.Iface;
    },
    get typeof_SwitchCase(): S.FieldType {
        const fieldName = this.SwitchCase.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get SwitchDefault(): S.Iface {
        if (!this["c_SwitchDefault"]) {
            const typeName = S.TypeName.make("SwitchDefault");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "consequent",
                /* ty = */ TArray(TNamed("Statement")),
                /* isLazy = */ false),
            ];
            this["c_SwitchDefault"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SwitchDefault"] instanceof S.Iface);
        return this["c_SwitchDefault"] as S.Iface;
    },
    get typeof_SwitchDefault(): S.FieldType {
        const fieldName = this.SwitchDefault.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get TemplateElement(): S.Iface {
        if (!this["c_TemplateElement"]) {
            const typeName = S.TypeName.make("TemplateElement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "rawValue",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_TemplateElement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_TemplateElement"] instanceof S.Iface);
        return this["c_TemplateElement"] as S.Iface;
    },
    get typeof_TemplateElement(): S.FieldType {
        const fieldName = this.TemplateElement.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get VariableDeclaration(): S.Iface {
        if (!this["c_VariableDeclaration"]) {
            const typeName = S.TypeName.make("VariableDeclaration");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "kind",
                /* ty = */ TNamed("VariableDeclarationKind"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "declarators",
                /* ty = */ TArray(TNamed("VariableDeclarator")),
                /* isLazy = */ false),
            ];
            this["c_VariableDeclaration"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_VariableDeclaration"] instanceof S.Iface);
        return this["c_VariableDeclaration"] as S.Iface;
    },
    get typeof_VariableDeclaration(): S.FieldType {
        const fieldName = this.VariableDeclaration.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get VariableDeclarator(): S.Iface {
        if (!this["c_VariableDeclarator"]) {
            const typeName = S.TypeName.make("VariableDeclarator");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("Binding"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TUnion([TNull, TNamed("Expression")]),
                /* isLazy = */ false),
            ];
            this["c_VariableDeclarator"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_VariableDeclarator"] instanceof S.Iface);
        return this["c_VariableDeclarator"] as S.Iface;
    },
    get typeof_VariableDeclarator(): S.FieldType {
        const fieldName = this.VariableDeclarator.name;
        return S.FieldTypeIface.make(fieldName);
    },


    get schema(): S.TreeSchema {
        if (!this['_schema']) {
            const d = 
                new Array<S.Declaration>();
            d.push(ReflectedSchema.Arguments);
            d.push(ReflectedSchema.Identifier);
            d.push(ReflectedSchema.IdentifierName);
            d.push(ReflectedSchema.PropertyString);
            d.push(ReflectedSchema.Label);
            d.push(ReflectedSchema.VariableDeclarationKind);
            d.push(ReflectedSchema.CompoundAssignmentOperator);
            d.push(ReflectedSchema.BinaryOperator);
            d.push(ReflectedSchema.UnaryOperator);
            d.push(ReflectedSchema.UpdateOperator);
            d.push(ReflectedSchema.AssertedDeclaredKind);
            d.push(ReflectedSchema.AssertedDeclaredName);
            d.push(ReflectedSchema.AssertedBoundName);
            d.push(ReflectedSchema.AssertedBlockScope);
            d.push(ReflectedSchema.AssertedScriptGlobalScope);
            d.push(ReflectedSchema.AssertedVarScope);
            d.push(ReflectedSchema.AssertedParameterScope);
            d.push(ReflectedSchema.AssertedBoundNamesScope);
            d.push(ReflectedSchema.Program);
            d.push(ReflectedSchema.IterationStatement);
            d.push(ReflectedSchema.Statement);
            d.push(ReflectedSchema.Literal);
            d.push(ReflectedSchema.Expression);
            d.push(ReflectedSchema.PropertyName);
            d.push(ReflectedSchema.MethodDefinition);
            d.push(ReflectedSchema.ObjectProperty);
            d.push(ReflectedSchema.ExportDeclaration);
            d.push(ReflectedSchema.ImportDeclaration);
            d.push(ReflectedSchema.FunctionDeclaration);
            d.push(ReflectedSchema.FunctionExpression);
            d.push(ReflectedSchema.Method);
            d.push(ReflectedSchema.Getter);
            d.push(ReflectedSchema.Setter);
            d.push(ReflectedSchema.ArrowExpression);
            d.push(ReflectedSchema.BindingIdentifier);
            d.push(ReflectedSchema.BindingPattern);
            d.push(ReflectedSchema.Binding);
            d.push(ReflectedSchema.SimpleAssignmentTarget);
            d.push(ReflectedSchema.AssignmentTargetPattern);
            d.push(ReflectedSchema.AssignmentTarget);
            d.push(ReflectedSchema.Parameter);
            d.push(ReflectedSchema.BindingWithInitializer);
            d.push(ReflectedSchema.AssignmentTargetIdentifier);
            d.push(ReflectedSchema.ComputedMemberAssignmentTarget);
            d.push(ReflectedSchema.StaticMemberAssignmentTarget);
            d.push(ReflectedSchema.ArrayBinding);
            d.push(ReflectedSchema.BindingPropertyIdentifier);
            d.push(ReflectedSchema.BindingPropertyProperty);
            d.push(ReflectedSchema.BindingProperty);
            d.push(ReflectedSchema.ObjectBinding);
            d.push(ReflectedSchema.AssignmentTargetWithInitializer);
            d.push(ReflectedSchema.ArrayAssignmentTarget);
            d.push(ReflectedSchema.AssignmentTargetPropertyIdentifier);
            d.push(ReflectedSchema.AssignmentTargetPropertyProperty);
            d.push(ReflectedSchema.AssignmentTargetProperty);
            d.push(ReflectedSchema.ObjectAssignmentTarget);
            d.push(ReflectedSchema.ClassExpression);
            d.push(ReflectedSchema.ClassDeclaration);
            d.push(ReflectedSchema.ClassElement);
            d.push(ReflectedSchema.Module);
            d.push(ReflectedSchema.Import);
            d.push(ReflectedSchema.ImportNamespace);
            d.push(ReflectedSchema.ImportSpecifier);
            d.push(ReflectedSchema.ExportAllFrom);
            d.push(ReflectedSchema.ExportFrom);
            d.push(ReflectedSchema.ExportLocals);
            d.push(ReflectedSchema.Export);
            d.push(ReflectedSchema.ExportDefault);
            d.push(ReflectedSchema.ExportFromSpecifier);
            d.push(ReflectedSchema.ExportLocalSpecifier);
            d.push(ReflectedSchema.EagerMethod);
            d.push(ReflectedSchema.LazyMethod);
            d.push(ReflectedSchema.EagerGetter);
            d.push(ReflectedSchema.LazyGetter);
            d.push(ReflectedSchema.GetterContents);
            d.push(ReflectedSchema.EagerSetter);
            d.push(ReflectedSchema.LazySetter);
            d.push(ReflectedSchema.SetterContents);
            d.push(ReflectedSchema.DataProperty);
            d.push(ReflectedSchema.ShorthandProperty);
            d.push(ReflectedSchema.ComputedPropertyName);
            d.push(ReflectedSchema.LiteralPropertyName);
            d.push(ReflectedSchema.LiteralBooleanExpression);
            d.push(ReflectedSchema.LiteralInfinityExpression);
            d.push(ReflectedSchema.LiteralNullExpression);
            d.push(ReflectedSchema.LiteralNumericExpression);
            d.push(ReflectedSchema.LiteralRegExpExpression);
            d.push(ReflectedSchema.LiteralStringExpression);
            d.push(ReflectedSchema.ArrayExpression);
            d.push(ReflectedSchema.EagerArrowExpression);
            d.push(ReflectedSchema.LazyArrowExpression);
            d.push(ReflectedSchema.ArrowExpressionContents);
            d.push(ReflectedSchema.AssignmentExpression);
            d.push(ReflectedSchema.BinaryExpression);
            d.push(ReflectedSchema.CallExpression);
            d.push(ReflectedSchema.CompoundAssignmentExpression);
            d.push(ReflectedSchema.ComputedMemberExpression);
            d.push(ReflectedSchema.ConditionalExpression);
            d.push(ReflectedSchema.EagerFunctionExpression);
            d.push(ReflectedSchema.LazyFunctionExpression);
            d.push(ReflectedSchema.FunctionExpressionContents);
            d.push(ReflectedSchema.IdentifierExpression);
            d.push(ReflectedSchema.NewExpression);
            d.push(ReflectedSchema.NewTargetExpression);
            d.push(ReflectedSchema.ObjectExpression);
            d.push(ReflectedSchema.UnaryExpression);
            d.push(ReflectedSchema.StaticMemberExpression);
            d.push(ReflectedSchema.TemplateExpression);
            d.push(ReflectedSchema.ThisExpression);
            d.push(ReflectedSchema.UpdateExpression);
            d.push(ReflectedSchema.YieldExpression);
            d.push(ReflectedSchema.YieldStarExpression);
            d.push(ReflectedSchema.AwaitExpression);
            d.push(ReflectedSchema.BreakStatement);
            d.push(ReflectedSchema.ContinueStatement);
            d.push(ReflectedSchema.DebuggerStatement);
            d.push(ReflectedSchema.DoWhileStatement);
            d.push(ReflectedSchema.EmptyStatement);
            d.push(ReflectedSchema.ExpressionStatement);
            d.push(ReflectedSchema.ForInOfBinding);
            d.push(ReflectedSchema.ForInStatement);
            d.push(ReflectedSchema.ForOfStatement);
            d.push(ReflectedSchema.ForStatement);
            d.push(ReflectedSchema.IfStatement);
            d.push(ReflectedSchema.LabelledStatement);
            d.push(ReflectedSchema.ReturnStatement);
            d.push(ReflectedSchema.SwitchStatement);
            d.push(ReflectedSchema.SwitchStatementWithDefault);
            d.push(ReflectedSchema.ThrowStatement);
            d.push(ReflectedSchema.TryCatchStatement);
            d.push(ReflectedSchema.TryFinallyStatement);
            d.push(ReflectedSchema.WhileStatement);
            d.push(ReflectedSchema.WithStatement);
            d.push(ReflectedSchema.Block);
            d.push(ReflectedSchema.CatchClause);
            d.push(ReflectedSchema.Directive);
            d.push(ReflectedSchema.FormalParameters);
            d.push(ReflectedSchema.FunctionBody);
            d.push(ReflectedSchema.EagerFunctionDeclaration);
            d.push(ReflectedSchema.LazyFunctionDeclaration);
            d.push(ReflectedSchema.FunctionOrMethodContents);
            d.push(ReflectedSchema.Script);
            d.push(ReflectedSchema.SpreadElement);
            d.push(ReflectedSchema.Super);
            d.push(ReflectedSchema.SwitchCase);
            d.push(ReflectedSchema.SwitchDefault);
            d.push(ReflectedSchema.TemplateElement);
            d.push(ReflectedSchema.VariableDeclaration);
            d.push(ReflectedSchema.VariableDeclarator);
            this['_schema'] = new S.TreeSchema(d);
        }
        assert(this['_schema'] instanceof S.TreeSchema);
        return this['_schema'] as S.TreeSchema;
    },
} // ReflectedSchema;


/*** Typed Interfaces ***/

export type Arguments = RoArr<(SpreadElement | Expression)>;


export type Identifier = S.Identifier;


export type IdentifierName = S.Identifier;


export type PropertyString = S.Identifier;


export type Label = string;


export enum VariableDeclarationKind {
   KwVar = "VariableDeclarationKind_KwVar",
   KwLet = "VariableDeclarationKind_KwLet",
   KwConst = "VariableDeclarationKind_KwConst",
} // enum VariableDeclarationKind

export function liftVariableDeclarationKind(s: string): VariableDeclarationKind {
    switch (s) {
      case "var": return VariableDeclarationKind.KwVar;
      case "let": return VariableDeclarationKind.KwLet;
      case "const": return VariableDeclarationKind.KwConst;
    }
    throw new Error("NOT ENUM!: " + s);
}



export enum CompoundAssignmentOperator {
   PlusAssign = "CompoundAssignmentOperator_PlusAssign",
   MinusAssign = "CompoundAssignmentOperator_MinusAssign",
   MulAssign = "CompoundAssignmentOperator_MulAssign",
   DivAssign = "CompoundAssignmentOperator_DivAssign",
   ModAssign = "CompoundAssignmentOperator_ModAssign",
   PowAssign = "CompoundAssignmentOperator_PowAssign",
   LshAssign = "CompoundAssignmentOperator_LshAssign",
   RshAssign = "CompoundAssignmentOperator_RshAssign",
   ArshAssign = "CompoundAssignmentOperator_ArshAssign",
   BitorAssign = "CompoundAssignmentOperator_BitorAssign",
   BitxorAssign = "CompoundAssignmentOperator_BitxorAssign",
   BitandAssign = "CompoundAssignmentOperator_BitandAssign",
} // enum CompoundAssignmentOperator

export function liftCompoundAssignmentOperator(s: string): CompoundAssignmentOperator {
    switch (s) {
      case "+=": return CompoundAssignmentOperator.PlusAssign;
      case "-=": return CompoundAssignmentOperator.MinusAssign;
      case "*=": return CompoundAssignmentOperator.MulAssign;
      case "/=": return CompoundAssignmentOperator.DivAssign;
      case "%=": return CompoundAssignmentOperator.ModAssign;
      case "**=": return CompoundAssignmentOperator.PowAssign;
      case "<<=": return CompoundAssignmentOperator.LshAssign;
      case ">>=": return CompoundAssignmentOperator.RshAssign;
      case ">>>=": return CompoundAssignmentOperator.ArshAssign;
      case "|=": return CompoundAssignmentOperator.BitorAssign;
      case "^=": return CompoundAssignmentOperator.BitxorAssign;
      case "&=": return CompoundAssignmentOperator.BitandAssign;
    }
    throw new Error("NOT ENUM!: " + s);
}



export enum BinaryOperator {
   Comma = "BinaryOperator_Comma",
   LogicalOr = "BinaryOperator_LogicalOr",
   LogicalAnd = "BinaryOperator_LogicalAnd",
   Bitor = "BinaryOperator_Bitor",
   Bitxor = "BinaryOperator_Bitxor",
   Bitand = "BinaryOperator_Bitand",
   Equal = "BinaryOperator_Equal",
   NotEqual = "BinaryOperator_NotEqual",
   StrictEqual = "BinaryOperator_StrictEqual",
   NotStrictEqual = "BinaryOperator_NotStrictEqual",
   LessThan = "BinaryOperator_LessThan",
   LessEqual = "BinaryOperator_LessEqual",
   GreaterThan = "BinaryOperator_GreaterThan",
   GreaterEqual = "BinaryOperator_GreaterEqual",
   KwIn = "BinaryOperator_KwIn",
   KwInstanceof = "BinaryOperator_KwInstanceof",
   Lsh = "BinaryOperator_Lsh",
   Rsh = "BinaryOperator_Rsh",
   Arsh = "BinaryOperator_Arsh",
   Plus = "BinaryOperator_Plus",
   Minus = "BinaryOperator_Minus",
   Mul = "BinaryOperator_Mul",
   Div = "BinaryOperator_Div",
   Mod = "BinaryOperator_Mod",
   Pow = "BinaryOperator_Pow",
} // enum BinaryOperator

export function liftBinaryOperator(s: string): BinaryOperator {
    switch (s) {
      case ",": return BinaryOperator.Comma;
      case "||": return BinaryOperator.LogicalOr;
      case "&&": return BinaryOperator.LogicalAnd;
      case "|": return BinaryOperator.Bitor;
      case "^": return BinaryOperator.Bitxor;
      case "&": return BinaryOperator.Bitand;
      case "==": return BinaryOperator.Equal;
      case "!=": return BinaryOperator.NotEqual;
      case "===": return BinaryOperator.StrictEqual;
      case "!==": return BinaryOperator.NotStrictEqual;
      case "<": return BinaryOperator.LessThan;
      case "<=": return BinaryOperator.LessEqual;
      case ">": return BinaryOperator.GreaterThan;
      case ">=": return BinaryOperator.GreaterEqual;
      case "in": return BinaryOperator.KwIn;
      case "instanceof": return BinaryOperator.KwInstanceof;
      case "<<": return BinaryOperator.Lsh;
      case ">>": return BinaryOperator.Rsh;
      case ">>>": return BinaryOperator.Arsh;
      case "+": return BinaryOperator.Plus;
      case "-": return BinaryOperator.Minus;
      case "*": return BinaryOperator.Mul;
      case "/": return BinaryOperator.Div;
      case "%": return BinaryOperator.Mod;
      case "**": return BinaryOperator.Pow;
    }
    throw new Error("NOT ENUM!: " + s);
}



export enum UnaryOperator {
   Plus = "UnaryOperator_Plus",
   Minus = "UnaryOperator_Minus",
   LogicalNot = "UnaryOperator_LogicalNot",
   Bitnot = "UnaryOperator_Bitnot",
   KwTypeof = "UnaryOperator_KwTypeof",
   KwVoid = "UnaryOperator_KwVoid",
   KwDelete = "UnaryOperator_KwDelete",
} // enum UnaryOperator

export function liftUnaryOperator(s: string): UnaryOperator {
    switch (s) {
      case "+": return UnaryOperator.Plus;
      case "-": return UnaryOperator.Minus;
      case "!": return UnaryOperator.LogicalNot;
      case "~": return UnaryOperator.Bitnot;
      case "typeof": return UnaryOperator.KwTypeof;
      case "void": return UnaryOperator.KwVoid;
      case "delete": return UnaryOperator.KwDelete;
    }
    throw new Error("NOT ENUM!: " + s);
}



export enum UpdateOperator {
   PlusPlus = "UpdateOperator_PlusPlus",
   MinusMinus = "UpdateOperator_MinusMinus",
} // enum UpdateOperator

export function liftUpdateOperator(s: string): UpdateOperator {
    switch (s) {
      case "++": return UpdateOperator.PlusPlus;
      case "--": return UpdateOperator.MinusMinus;
    }
    throw new Error("NOT ENUM!: " + s);
}



export enum AssertedDeclaredKind {
   KwVar = "AssertedDeclaredKind_KwVar",
   NonConstLexical = "AssertedDeclaredKind_NonConstLexical",
   ConstLexical = "AssertedDeclaredKind_ConstLexical",
} // enum AssertedDeclaredKind

export function liftAssertedDeclaredKind(s: string): AssertedDeclaredKind {
    switch (s) {
      case "var": return AssertedDeclaredKind.KwVar;
      case "non-const lexical": return AssertedDeclaredKind.NonConstLexical;
      case "const lexical": return AssertedDeclaredKind.ConstLexical;
    }
    throw new Error("NOT ENUM!: " + s);
}



export interface I_AssertedDeclaredName {
    readonly name: IdentifierName;
    readonly kind: AssertedDeclaredKind;
    readonly isCaptured: boolean;
} // I_AssertedDeclaredName

export class AssertedDeclaredName
  implements S.Instance
{
    readonly data$: Ro<I_AssertedDeclaredName>;

    private constructor(data: Ro<I_AssertedDeclaredName>) {
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssertedDeclaredName;
    }
    static make(data: Ro<I_AssertedDeclaredName>) {
        return new AssertedDeclaredName(data);
    }

    get name(): IdentifierName {
       return this.data$.name;
    }
    get kind(): AssertedDeclaredKind {
       return this.data$.kind;
    }
    get isCaptured(): boolean {
       return this.data$.isCaptured;
    }
}


export interface I_AssertedBoundName {
    readonly name: IdentifierName;
    readonly isCaptured: boolean;
} // I_AssertedBoundName

export class AssertedBoundName
  implements S.Instance
{
    readonly data$: Ro<I_AssertedBoundName>;

    private constructor(data: Ro<I_AssertedBoundName>) {
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssertedBoundName;
    }
    static make(data: Ro<I_AssertedBoundName>) {
        return new AssertedBoundName(data);
    }

    get name(): IdentifierName {
       return this.data$.name;
    }
    get isCaptured(): boolean {
       return this.data$.isCaptured;
    }
}


export interface I_AssertedBlockScope {
    readonly declaredNames: RoArr<AssertedDeclaredName>;
    readonly hasDirectEval: boolean;
} // I_AssertedBlockScope

export class AssertedBlockScope
  implements S.Instance
{
    readonly data$: Ro<I_AssertedBlockScope>;

    private constructor(data: Ro<I_AssertedBlockScope>) {
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssertedBlockScope;
    }
    static make(data: Ro<I_AssertedBlockScope>) {
        return new AssertedBlockScope(data);
    }

    get declaredNames(): RoArr<AssertedDeclaredName> {
       return this.data$.declaredNames;
    }
    get hasDirectEval(): boolean {
       return this.data$.hasDirectEval;
    }
}


export interface I_AssertedScriptGlobalScope {
    readonly declaredNames: RoArr<AssertedDeclaredName>;
    readonly hasDirectEval: boolean;
} // I_AssertedScriptGlobalScope

export class AssertedScriptGlobalScope
  implements S.Instance
{
    readonly data$: Ro<I_AssertedScriptGlobalScope>;

    private constructor(data: Ro<I_AssertedScriptGlobalScope>) {
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssertedScriptGlobalScope;
    }
    static make(data: Ro<I_AssertedScriptGlobalScope>) {
        return new AssertedScriptGlobalScope(data);
    }

    get declaredNames(): RoArr<AssertedDeclaredName> {
       return this.data$.declaredNames;
    }
    get hasDirectEval(): boolean {
       return this.data$.hasDirectEval;
    }
}


export interface I_AssertedVarScope {
    readonly declaredNames: RoArr<AssertedDeclaredName>;
    readonly hasDirectEval: boolean;
} // I_AssertedVarScope

export class AssertedVarScope
  implements S.Instance
{
    readonly data$: Ro<I_AssertedVarScope>;

    private constructor(data: Ro<I_AssertedVarScope>) {
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssertedVarScope;
    }
    static make(data: Ro<I_AssertedVarScope>) {
        return new AssertedVarScope(data);
    }

    get declaredNames(): RoArr<AssertedDeclaredName> {
       return this.data$.declaredNames;
    }
    get hasDirectEval(): boolean {
       return this.data$.hasDirectEval;
    }
}


export interface I_AssertedParameterScope {
    readonly boundNames: RoArr<AssertedBoundName>;
    readonly hasDirectEval: boolean;
    readonly isSimpleParameterList: boolean;
} // I_AssertedParameterScope

export class AssertedParameterScope
  implements S.Instance
{
    readonly data$: Ro<I_AssertedParameterScope>;

    private constructor(data: Ro<I_AssertedParameterScope>) {
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssertedParameterScope;
    }
    static make(data: Ro<I_AssertedParameterScope>) {
        return new AssertedParameterScope(data);
    }

    get boundNames(): RoArr<AssertedBoundName> {
       return this.data$.boundNames;
    }
    get hasDirectEval(): boolean {
       return this.data$.hasDirectEval;
    }
    get isSimpleParameterList(): boolean {
       return this.data$.isSimpleParameterList;
    }
}


export interface I_AssertedBoundNamesScope {
    readonly boundNames: RoArr<AssertedBoundName>;
    readonly hasDirectEval: boolean;
} // I_AssertedBoundNamesScope

export class AssertedBoundNamesScope
  implements S.Instance
{
    readonly data$: Ro<I_AssertedBoundNamesScope>;

    private constructor(data: Ro<I_AssertedBoundNamesScope>) {
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssertedBoundNamesScope;
    }
    static make(data: Ro<I_AssertedBoundNamesScope>) {
        return new AssertedBoundNamesScope(data);
    }

    get boundNames(): RoArr<AssertedBoundName> {
       return this.data$.boundNames;
    }
    get hasDirectEval(): boolean {
       return this.data$.hasDirectEval;
    }
}


export type Program = (Script | Module);


export type IterationStatement = (DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | WhileStatement);


export type Statement = (Block | BreakStatement | ContinueStatement | ClassDeclaration | DebuggerStatement | EmptyStatement | ExpressionStatement | FunctionDeclaration | IfStatement | IterationStatement | LabelledStatement | ReturnStatement | SwitchStatement | SwitchStatementWithDefault | ThrowStatement | TryCatchStatement | TryFinallyStatement | VariableDeclaration | WithStatement);


export type Literal = (LiteralBooleanExpression | LiteralInfinityExpression | LiteralNullExpression | LiteralNumericExpression | LiteralStringExpression);


export type Expression = (Literal | LiteralRegExpExpression | ArrayExpression | ArrowExpression | AssignmentExpression | BinaryExpression | CallExpression | CompoundAssignmentExpression | ComputedMemberExpression | ConditionalExpression | ClassExpression | FunctionExpression | IdentifierExpression | NewExpression | NewTargetExpression | ObjectExpression | UnaryExpression | StaticMemberExpression | TemplateExpression | ThisExpression | UpdateExpression | YieldExpression | YieldStarExpression | AwaitExpression);


export type PropertyName = (ComputedPropertyName | LiteralPropertyName);


export type MethodDefinition = (Method | Getter | Setter);


export type ObjectProperty = (MethodDefinition | DataProperty | ShorthandProperty);


export type ExportDeclaration = (ExportAllFrom | ExportFrom | ExportLocals | ExportDefault | Export);


export type ImportDeclaration = (ImportNamespace | Import);


export type FunctionDeclaration = (EagerFunctionDeclaration | LazyFunctionDeclaration);


export type FunctionExpression = (EagerFunctionExpression | LazyFunctionExpression);


export type Method = (EagerMethod | LazyMethod);


export type Getter = (EagerGetter | LazyGetter);


export type Setter = (EagerSetter | LazySetter);


export type ArrowExpression = (EagerArrowExpression | LazyArrowExpression);


export interface I_BindingIdentifier {
    readonly name: Identifier;
} // I_BindingIdentifier

export class BindingIdentifier
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_BindingIdentifier>;

    private constructor(data: Ro<I_BindingIdentifier>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.BindingIdentifier;
    }
    static make(data: Ro<I_BindingIdentifier>) {
        return new BindingIdentifier(data);
    }

    get name(): Identifier {
       return this.data$.name;
    }
}


export type BindingPattern = (ObjectBinding | ArrayBinding);


export type Binding = (BindingPattern | BindingIdentifier);


export type SimpleAssignmentTarget = (AssignmentTargetIdentifier | ComputedMemberAssignmentTarget | StaticMemberAssignmentTarget);


export type AssignmentTargetPattern = (ObjectAssignmentTarget | ArrayAssignmentTarget);


export type AssignmentTarget = (AssignmentTargetPattern | SimpleAssignmentTarget);


export type Parameter = (Binding | BindingWithInitializer);


export interface I_BindingWithInitializer {
    readonly binding: Binding;
    readonly init: Expression;
} // I_BindingWithInitializer

export class BindingWithInitializer
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_BindingWithInitializer>;

    private constructor(data: Ro<I_BindingWithInitializer>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.BindingWithInitializer;
    }
    static make(data: Ro<I_BindingWithInitializer>) {
        return new BindingWithInitializer(data);
    }

    get binding(): Binding {
       return this.data$.binding;
    }
    get init(): Expression {
       return this.data$.init;
    }
}


export interface I_AssignmentTargetIdentifier {
    readonly name: Identifier;
} // I_AssignmentTargetIdentifier

export class AssignmentTargetIdentifier
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_AssignmentTargetIdentifier>;

    private constructor(data: Ro<I_AssignmentTargetIdentifier>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssignmentTargetIdentifier;
    }
    static make(data: Ro<I_AssignmentTargetIdentifier>) {
        return new AssignmentTargetIdentifier(data);
    }

    get name(): Identifier {
       return this.data$.name;
    }
}


export interface I_ComputedMemberAssignmentTarget {
    readonly object: (Expression | Super);
    readonly expression: Expression;
} // I_ComputedMemberAssignmentTarget

export class ComputedMemberAssignmentTarget
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ComputedMemberAssignmentTarget>;

    private constructor(data: Ro<I_ComputedMemberAssignmentTarget>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ComputedMemberAssignmentTarget;
    }
    static make(data: Ro<I_ComputedMemberAssignmentTarget>) {
        return new ComputedMemberAssignmentTarget(data);
    }

    get object(): (Expression | Super) {
       return this.data$.object;
    }
    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_StaticMemberAssignmentTarget {
    readonly object: (Expression | Super);
    readonly property: IdentifierName;
} // I_StaticMemberAssignmentTarget

export class StaticMemberAssignmentTarget
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_StaticMemberAssignmentTarget>;

    private constructor(data: Ro<I_StaticMemberAssignmentTarget>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.StaticMemberAssignmentTarget;
    }
    static make(data: Ro<I_StaticMemberAssignmentTarget>) {
        return new StaticMemberAssignmentTarget(data);
    }

    get object(): (Expression | Super) {
       return this.data$.object;
    }
    get property(): IdentifierName {
       return this.data$.property;
    }
}


export interface I_ArrayBinding {
    readonly elements: RoArr<(null | Binding | BindingWithInitializer)>;
    readonly rest: (null | Binding);
} // I_ArrayBinding

export class ArrayBinding
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ArrayBinding>;

    private constructor(data: Ro<I_ArrayBinding>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ArrayBinding;
    }
    static make(data: Ro<I_ArrayBinding>) {
        return new ArrayBinding(data);
    }

    get elements(): RoArr<(null | Binding | BindingWithInitializer)> {
       return this.data$.elements;
    }
    get rest(): (null | Binding) {
       return this.data$.rest;
    }
}


export interface I_BindingPropertyIdentifier {
    readonly binding: BindingIdentifier;
    readonly init: (null | Expression);
} // I_BindingPropertyIdentifier

export class BindingPropertyIdentifier
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_BindingPropertyIdentifier>;

    private constructor(data: Ro<I_BindingPropertyIdentifier>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.BindingPropertyIdentifier;
    }
    static make(data: Ro<I_BindingPropertyIdentifier>) {
        return new BindingPropertyIdentifier(data);
    }

    get binding(): BindingIdentifier {
       return this.data$.binding;
    }
    get init(): (null | Expression) {
       return this.data$.init;
    }
}


export interface I_BindingPropertyProperty {
    readonly name: PropertyName;
    readonly binding: (Binding | BindingWithInitializer);
} // I_BindingPropertyProperty

export class BindingPropertyProperty
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_BindingPropertyProperty>;

    private constructor(data: Ro<I_BindingPropertyProperty>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.BindingPropertyProperty;
    }
    static make(data: Ro<I_BindingPropertyProperty>) {
        return new BindingPropertyProperty(data);
    }

    get name(): PropertyName {
       return this.data$.name;
    }
    get binding(): (Binding | BindingWithInitializer) {
       return this.data$.binding;
    }
}


export type BindingProperty = (BindingPropertyIdentifier | BindingPropertyProperty);


export interface I_ObjectBinding {
    readonly properties: RoArr<BindingProperty>;
} // I_ObjectBinding

export class ObjectBinding
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ObjectBinding>;

    private constructor(data: Ro<I_ObjectBinding>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ObjectBinding;
    }
    static make(data: Ro<I_ObjectBinding>) {
        return new ObjectBinding(data);
    }

    get properties(): RoArr<BindingProperty> {
       return this.data$.properties;
    }
}


export interface I_AssignmentTargetWithInitializer {
    readonly binding: AssignmentTarget;
    readonly init: Expression;
} // I_AssignmentTargetWithInitializer

export class AssignmentTargetWithInitializer
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_AssignmentTargetWithInitializer>;

    private constructor(data: Ro<I_AssignmentTargetWithInitializer>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssignmentTargetWithInitializer;
    }
    static make(data: Ro<I_AssignmentTargetWithInitializer>) {
        return new AssignmentTargetWithInitializer(data);
    }

    get binding(): AssignmentTarget {
       return this.data$.binding;
    }
    get init(): Expression {
       return this.data$.init;
    }
}


export interface I_ArrayAssignmentTarget {
    readonly elements: RoArr<(null | AssignmentTarget | AssignmentTargetWithInitializer)>;
    readonly rest: (null | AssignmentTarget);
} // I_ArrayAssignmentTarget

export class ArrayAssignmentTarget
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ArrayAssignmentTarget>;

    private constructor(data: Ro<I_ArrayAssignmentTarget>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ArrayAssignmentTarget;
    }
    static make(data: Ro<I_ArrayAssignmentTarget>) {
        return new ArrayAssignmentTarget(data);
    }

    get elements(): RoArr<(null | AssignmentTarget | AssignmentTargetWithInitializer)> {
       return this.data$.elements;
    }
    get rest(): (null | AssignmentTarget) {
       return this.data$.rest;
    }
}


export interface I_AssignmentTargetPropertyIdentifier {
    readonly binding: AssignmentTargetIdentifier;
    readonly init: (null | Expression);
} // I_AssignmentTargetPropertyIdentifier

export class AssignmentTargetPropertyIdentifier
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_AssignmentTargetPropertyIdentifier>;

    private constructor(data: Ro<I_AssignmentTargetPropertyIdentifier>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssignmentTargetPropertyIdentifier;
    }
    static make(data: Ro<I_AssignmentTargetPropertyIdentifier>) {
        return new AssignmentTargetPropertyIdentifier(data);
    }

    get binding(): AssignmentTargetIdentifier {
       return this.data$.binding;
    }
    get init(): (null | Expression) {
       return this.data$.init;
    }
}


export interface I_AssignmentTargetPropertyProperty {
    readonly name: PropertyName;
    readonly binding: (AssignmentTarget | AssignmentTargetWithInitializer);
} // I_AssignmentTargetPropertyProperty

export class AssignmentTargetPropertyProperty
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_AssignmentTargetPropertyProperty>;

    private constructor(data: Ro<I_AssignmentTargetPropertyProperty>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssignmentTargetPropertyProperty;
    }
    static make(data: Ro<I_AssignmentTargetPropertyProperty>) {
        return new AssignmentTargetPropertyProperty(data);
    }

    get name(): PropertyName {
       return this.data$.name;
    }
    get binding(): (AssignmentTarget | AssignmentTargetWithInitializer) {
       return this.data$.binding;
    }
}


export type AssignmentTargetProperty = (AssignmentTargetPropertyIdentifier | AssignmentTargetPropertyProperty);


export interface I_ObjectAssignmentTarget {
    readonly properties: RoArr<AssignmentTargetProperty>;
} // I_ObjectAssignmentTarget

export class ObjectAssignmentTarget
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ObjectAssignmentTarget>;

    private constructor(data: Ro<I_ObjectAssignmentTarget>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ObjectAssignmentTarget;
    }
    static make(data: Ro<I_ObjectAssignmentTarget>) {
        return new ObjectAssignmentTarget(data);
    }

    get properties(): RoArr<AssignmentTargetProperty> {
       return this.data$.properties;
    }
}


export interface I_ClassExpression {
    readonly name: (null | BindingIdentifier);
    readonly super: (null | Expression);
    readonly elements: RoArr<ClassElement>;
} // I_ClassExpression

export class ClassExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ClassExpression>;

    private constructor(data: Ro<I_ClassExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ClassExpression;
    }
    static make(data: Ro<I_ClassExpression>) {
        return new ClassExpression(data);
    }

    get name(): (null | BindingIdentifier) {
       return this.data$.name;
    }
    get super(): (null | Expression) {
       return this.data$.super;
    }
    get elements(): RoArr<ClassElement> {
       return this.data$.elements;
    }
}


export interface I_ClassDeclaration {
    readonly name: BindingIdentifier;
    readonly super: (null | Expression);
    readonly elements: RoArr<ClassElement>;
} // I_ClassDeclaration

export class ClassDeclaration
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ClassDeclaration>;

    private constructor(data: Ro<I_ClassDeclaration>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ClassDeclaration;
    }
    static make(data: Ro<I_ClassDeclaration>) {
        return new ClassDeclaration(data);
    }

    get name(): BindingIdentifier {
       return this.data$.name;
    }
    get super(): (null | Expression) {
       return this.data$.super;
    }
    get elements(): RoArr<ClassElement> {
       return this.data$.elements;
    }
}


export interface I_ClassElement {
    readonly isStatic: boolean;
    readonly method: MethodDefinition;
} // I_ClassElement

export class ClassElement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ClassElement>;

    private constructor(data: Ro<I_ClassElement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ClassElement;
    }
    static make(data: Ro<I_ClassElement>) {
        return new ClassElement(data);
    }

    get isStatic(): boolean {
       return this.data$.isStatic;
    }
    get method(): MethodDefinition {
       return this.data$.method;
    }
}


export interface I_Module {
    readonly scope: AssertedVarScope;
    readonly directives: RoArr<Directive>;
    readonly items: RoArr<(ImportDeclaration | ExportDeclaration | Statement)>;
} // I_Module

export class Module
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_Module>;

    private constructor(data: Ro<I_Module>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.Module;
    }
    static make(data: Ro<I_Module>) {
        return new Module(data);
    }

    get scope(): AssertedVarScope {
       return this.data$.scope;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get items(): RoArr<(ImportDeclaration | ExportDeclaration | Statement)> {
       return this.data$.items;
    }
}


export interface I_Import {
    readonly moduleSpecifier: string;
    readonly defaultBinding: (null | BindingIdentifier);
    readonly namedImports: RoArr<ImportSpecifier>;
} // I_Import

export class Import
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_Import>;

    private constructor(data: Ro<I_Import>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.Import;
    }
    static make(data: Ro<I_Import>) {
        return new Import(data);
    }

    get moduleSpecifier(): string {
       return this.data$.moduleSpecifier;
    }
    get defaultBinding(): (null | BindingIdentifier) {
       return this.data$.defaultBinding;
    }
    get namedImports(): RoArr<ImportSpecifier> {
       return this.data$.namedImports;
    }
}


export interface I_ImportNamespace {
    readonly moduleSpecifier: string;
    readonly defaultBinding: (null | BindingIdentifier);
    readonly namespaceBinding: BindingIdentifier;
} // I_ImportNamespace

export class ImportNamespace
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ImportNamespace>;

    private constructor(data: Ro<I_ImportNamespace>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ImportNamespace;
    }
    static make(data: Ro<I_ImportNamespace>) {
        return new ImportNamespace(data);
    }

    get moduleSpecifier(): string {
       return this.data$.moduleSpecifier;
    }
    get defaultBinding(): (null | BindingIdentifier) {
       return this.data$.defaultBinding;
    }
    get namespaceBinding(): BindingIdentifier {
       return this.data$.namespaceBinding;
    }
}


export interface I_ImportSpecifier {
    readonly name: (null | IdentifierName);
    readonly binding: BindingIdentifier;
} // I_ImportSpecifier

export class ImportSpecifier
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ImportSpecifier>;

    private constructor(data: Ro<I_ImportSpecifier>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ImportSpecifier;
    }
    static make(data: Ro<I_ImportSpecifier>) {
        return new ImportSpecifier(data);
    }

    get name(): (null | IdentifierName) {
       return this.data$.name;
    }
    get binding(): BindingIdentifier {
       return this.data$.binding;
    }
}


export interface I_ExportAllFrom {
    readonly moduleSpecifier: string;
} // I_ExportAllFrom

export class ExportAllFrom
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ExportAllFrom>;

    private constructor(data: Ro<I_ExportAllFrom>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ExportAllFrom;
    }
    static make(data: Ro<I_ExportAllFrom>) {
        return new ExportAllFrom(data);
    }

    get moduleSpecifier(): string {
       return this.data$.moduleSpecifier;
    }
}


export interface I_ExportFrom {
    readonly namedExports: RoArr<ExportFromSpecifier>;
    readonly moduleSpecifier: string;
} // I_ExportFrom

export class ExportFrom
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ExportFrom>;

    private constructor(data: Ro<I_ExportFrom>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ExportFrom;
    }
    static make(data: Ro<I_ExportFrom>) {
        return new ExportFrom(data);
    }

    get namedExports(): RoArr<ExportFromSpecifier> {
       return this.data$.namedExports;
    }
    get moduleSpecifier(): string {
       return this.data$.moduleSpecifier;
    }
}


export interface I_ExportLocals {
    readonly namedExports: RoArr<ExportLocalSpecifier>;
} // I_ExportLocals

export class ExportLocals
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ExportLocals>;

    private constructor(data: Ro<I_ExportLocals>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ExportLocals;
    }
    static make(data: Ro<I_ExportLocals>) {
        return new ExportLocals(data);
    }

    get namedExports(): RoArr<ExportLocalSpecifier> {
       return this.data$.namedExports;
    }
}


export interface I_Export {
    readonly declaration: (FunctionDeclaration | ClassDeclaration | VariableDeclaration);
} // I_Export

export class Export
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_Export>;

    private constructor(data: Ro<I_Export>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.Export;
    }
    static make(data: Ro<I_Export>) {
        return new Export(data);
    }

    get declaration(): (FunctionDeclaration | ClassDeclaration | VariableDeclaration) {
       return this.data$.declaration;
    }
}


export interface I_ExportDefault {
    readonly body: (FunctionDeclaration | ClassDeclaration | Expression);
} // I_ExportDefault

export class ExportDefault
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ExportDefault>;

    private constructor(data: Ro<I_ExportDefault>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ExportDefault;
    }
    static make(data: Ro<I_ExportDefault>) {
        return new ExportDefault(data);
    }

    get body(): (FunctionDeclaration | ClassDeclaration | Expression) {
       return this.data$.body;
    }
}


export interface I_ExportFromSpecifier {
    readonly name: IdentifierName;
    readonly exportedName: (null | IdentifierName);
} // I_ExportFromSpecifier

export class ExportFromSpecifier
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ExportFromSpecifier>;

    private constructor(data: Ro<I_ExportFromSpecifier>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ExportFromSpecifier;
    }
    static make(data: Ro<I_ExportFromSpecifier>) {
        return new ExportFromSpecifier(data);
    }

    get name(): IdentifierName {
       return this.data$.name;
    }
    get exportedName(): (null | IdentifierName) {
       return this.data$.exportedName;
    }
}


export interface I_ExportLocalSpecifier {
    readonly name: IdentifierExpression;
    readonly exportedName: (null | IdentifierName);
} // I_ExportLocalSpecifier

export class ExportLocalSpecifier
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ExportLocalSpecifier>;

    private constructor(data: Ro<I_ExportLocalSpecifier>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ExportLocalSpecifier;
    }
    static make(data: Ro<I_ExportLocalSpecifier>) {
        return new ExportLocalSpecifier(data);
    }

    get name(): IdentifierExpression {
       return this.data$.name;
    }
    get exportedName(): (null | IdentifierName) {
       return this.data$.exportedName;
    }
}


export interface I_EagerMethod {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionOrMethodContents;
} // I_EagerMethod

export class EagerMethod
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_EagerMethod>;

    private constructor(data: Ro<I_EagerMethod>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.EagerMethod;
    }
    static make(data: Ro<I_EagerMethod>) {
        return new EagerMethod(data);
    }

    get isAsync(): boolean {
       return this.data$.isAsync;
    }
    get isGenerator(): boolean {
       return this.data$.isGenerator;
    }
    get name(): PropertyName {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get contents(): FunctionOrMethodContents {
       return this.data$.contents;
    }
}


export interface I_LazyMethod {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionOrMethodContents;
} // I_LazyMethod

export class LazyMethod
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LazyMethod>;

    private constructor(data: Ro<I_LazyMethod>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LazyMethod;
    }
    static make(data: Ro<I_LazyMethod>) {
        return new LazyMethod(data);
    }

    get isAsync(): boolean {
       return this.data$.isAsync;
    }
    get isGenerator(): boolean {
       return this.data$.isGenerator;
    }
    get name(): PropertyName {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get contents(): FunctionOrMethodContents {
       return this.data$.contents;
    }
}


export interface I_EagerGetter {
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: GetterContents;
} // I_EagerGetter

export class EagerGetter
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_EagerGetter>;

    private constructor(data: Ro<I_EagerGetter>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.EagerGetter;
    }
    static make(data: Ro<I_EagerGetter>) {
        return new EagerGetter(data);
    }

    get name(): PropertyName {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get contents(): GetterContents {
       return this.data$.contents;
    }
}


export interface I_LazyGetter {
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: GetterContents;
} // I_LazyGetter

export class LazyGetter
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LazyGetter>;

    private constructor(data: Ro<I_LazyGetter>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LazyGetter;
    }
    static make(data: Ro<I_LazyGetter>) {
        return new LazyGetter(data);
    }

    get name(): PropertyName {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get contents(): GetterContents {
       return this.data$.contents;
    }
}


export interface I_GetterContents {
    readonly isThisCaptured: boolean;
    readonly bodyScope: AssertedVarScope;
    readonly body: FunctionBody;
} // I_GetterContents

export class GetterContents
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_GetterContents>;

    private constructor(data: Ro<I_GetterContents>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.GetterContents;
    }
    static make(data: Ro<I_GetterContents>) {
        return new GetterContents(data);
    }

    get isThisCaptured(): boolean {
       return this.data$.isThisCaptured;
    }
    get bodyScope(): AssertedVarScope {
       return this.data$.bodyScope;
    }
    get body(): FunctionBody {
       return this.data$.body;
    }
}


export interface I_EagerSetter {
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: SetterContents;
} // I_EagerSetter

export class EagerSetter
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_EagerSetter>;

    private constructor(data: Ro<I_EagerSetter>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.EagerSetter;
    }
    static make(data: Ro<I_EagerSetter>) {
        return new EagerSetter(data);
    }

    get name(): PropertyName {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get contents(): SetterContents {
       return this.data$.contents;
    }
}


export interface I_LazySetter {
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: SetterContents;
} // I_LazySetter

export class LazySetter
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LazySetter>;

    private constructor(data: Ro<I_LazySetter>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LazySetter;
    }
    static make(data: Ro<I_LazySetter>) {
        return new LazySetter(data);
    }

    get name(): PropertyName {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get contents(): SetterContents {
       return this.data$.contents;
    }
}


export interface I_SetterContents {
    readonly isThisCaptured: boolean;
    readonly parameterScope: AssertedParameterScope;
    readonly param: Parameter;
    readonly bodyScope: AssertedVarScope;
    readonly body: FunctionBody;
} // I_SetterContents

export class SetterContents
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_SetterContents>;

    private constructor(data: Ro<I_SetterContents>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.SetterContents;
    }
    static make(data: Ro<I_SetterContents>) {
        return new SetterContents(data);
    }

    get isThisCaptured(): boolean {
       return this.data$.isThisCaptured;
    }
    get parameterScope(): AssertedParameterScope {
       return this.data$.parameterScope;
    }
    get param(): Parameter {
       return this.data$.param;
    }
    get bodyScope(): AssertedVarScope {
       return this.data$.bodyScope;
    }
    get body(): FunctionBody {
       return this.data$.body;
    }
}


export interface I_DataProperty {
    readonly name: PropertyName;
    readonly expression: Expression;
} // I_DataProperty

export class DataProperty
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_DataProperty>;

    private constructor(data: Ro<I_DataProperty>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.DataProperty;
    }
    static make(data: Ro<I_DataProperty>) {
        return new DataProperty(data);
    }

    get name(): PropertyName {
       return this.data$.name;
    }
    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_ShorthandProperty {
    readonly name: IdentifierExpression;
} // I_ShorthandProperty

export class ShorthandProperty
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ShorthandProperty>;

    private constructor(data: Ro<I_ShorthandProperty>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ShorthandProperty;
    }
    static make(data: Ro<I_ShorthandProperty>) {
        return new ShorthandProperty(data);
    }

    get name(): IdentifierExpression {
       return this.data$.name;
    }
}


export interface I_ComputedPropertyName {
    readonly expression: Expression;
} // I_ComputedPropertyName

export class ComputedPropertyName
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ComputedPropertyName>;

    private constructor(data: Ro<I_ComputedPropertyName>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ComputedPropertyName;
    }
    static make(data: Ro<I_ComputedPropertyName>) {
        return new ComputedPropertyName(data);
    }

    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_LiteralPropertyName {
    readonly value: PropertyString;
} // I_LiteralPropertyName

export class LiteralPropertyName
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LiteralPropertyName>;

    private constructor(data: Ro<I_LiteralPropertyName>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LiteralPropertyName;
    }
    static make(data: Ro<I_LiteralPropertyName>) {
        return new LiteralPropertyName(data);
    }

    get value(): PropertyString {
       return this.data$.value;
    }
}


export interface I_LiteralBooleanExpression {
    readonly value: boolean;
} // I_LiteralBooleanExpression

export class LiteralBooleanExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LiteralBooleanExpression>;

    private constructor(data: Ro<I_LiteralBooleanExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LiteralBooleanExpression;
    }
    static make(data: Ro<I_LiteralBooleanExpression>) {
        return new LiteralBooleanExpression(data);
    }

    get value(): boolean {
       return this.data$.value;
    }
}


export interface I_LiteralInfinityExpression {
} // I_LiteralInfinityExpression

export class LiteralInfinityExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LiteralInfinityExpression>;

    private constructor(data: Ro<I_LiteralInfinityExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LiteralInfinityExpression;
    }
    static make(data: Ro<I_LiteralInfinityExpression>) {
        return new LiteralInfinityExpression(data);
    }

}


export interface I_LiteralNullExpression {
} // I_LiteralNullExpression

export class LiteralNullExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LiteralNullExpression>;

    private constructor(data: Ro<I_LiteralNullExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LiteralNullExpression;
    }
    static make(data: Ro<I_LiteralNullExpression>) {
        return new LiteralNullExpression(data);
    }

}


export interface I_LiteralNumericExpression {
    readonly value: number;
} // I_LiteralNumericExpression

export class LiteralNumericExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LiteralNumericExpression>;

    private constructor(data: Ro<I_LiteralNumericExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LiteralNumericExpression;
    }
    static make(data: Ro<I_LiteralNumericExpression>) {
        return new LiteralNumericExpression(data);
    }

    get value(): number {
       return this.data$.value;
    }
}


export interface I_LiteralRegExpExpression {
    readonly pattern: string;
    readonly flags: string;
} // I_LiteralRegExpExpression

export class LiteralRegExpExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LiteralRegExpExpression>;

    private constructor(data: Ro<I_LiteralRegExpExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LiteralRegExpExpression;
    }
    static make(data: Ro<I_LiteralRegExpExpression>) {
        return new LiteralRegExpExpression(data);
    }

    get pattern(): string {
       return this.data$.pattern;
    }
    get flags(): string {
       return this.data$.flags;
    }
}


export interface I_LiteralStringExpression {
    readonly value: string;
} // I_LiteralStringExpression

export class LiteralStringExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LiteralStringExpression>;

    private constructor(data: Ro<I_LiteralStringExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LiteralStringExpression;
    }
    static make(data: Ro<I_LiteralStringExpression>) {
        return new LiteralStringExpression(data);
    }

    get value(): string {
       return this.data$.value;
    }
}


export interface I_ArrayExpression {
    readonly elements: RoArr<(null | SpreadElement | Expression)>;
} // I_ArrayExpression

export class ArrayExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ArrayExpression>;

    private constructor(data: Ro<I_ArrayExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ArrayExpression;
    }
    static make(data: Ro<I_ArrayExpression>) {
        return new ArrayExpression(data);
    }

    get elements(): RoArr<(null | SpreadElement | Expression)> {
       return this.data$.elements;
    }
}


export interface I_EagerArrowExpression {
    readonly isAsync: boolean;
    readonly directives: (null | RoArr<Directive>);
    readonly contents: ArrowExpressionContents;
} // I_EagerArrowExpression

export class EagerArrowExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_EagerArrowExpression>;

    private constructor(data: Ro<I_EagerArrowExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.EagerArrowExpression;
    }
    static make(data: Ro<I_EagerArrowExpression>) {
        return new EagerArrowExpression(data);
    }

    get isAsync(): boolean {
       return this.data$.isAsync;
    }
    get directives(): (null | RoArr<Directive>) {
       return this.data$.directives;
    }
    get contents(): ArrowExpressionContents {
       return this.data$.contents;
    }
}


export interface I_LazyArrowExpression {
    readonly isAsync: boolean;
    readonly directives: (null | RoArr<Directive>);
    readonly contents: ArrowExpressionContents;
} // I_LazyArrowExpression

export class LazyArrowExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LazyArrowExpression>;

    private constructor(data: Ro<I_LazyArrowExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LazyArrowExpression;
    }
    static make(data: Ro<I_LazyArrowExpression>) {
        return new LazyArrowExpression(data);
    }

    get isAsync(): boolean {
       return this.data$.isAsync;
    }
    get directives(): (null | RoArr<Directive>) {
       return this.data$.directives;
    }
    get contents(): ArrowExpressionContents {
       return this.data$.contents;
    }
}


export interface I_ArrowExpressionContents {
    readonly parameterScope: AssertedParameterScope;
    readonly params: FormalParameters;
    readonly bodyScope: AssertedVarScope;
    readonly body: (FunctionBody | Expression);
} // I_ArrowExpressionContents

export class ArrowExpressionContents
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ArrowExpressionContents>;

    private constructor(data: Ro<I_ArrowExpressionContents>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ArrowExpressionContents;
    }
    static make(data: Ro<I_ArrowExpressionContents>) {
        return new ArrowExpressionContents(data);
    }

    get parameterScope(): AssertedParameterScope {
       return this.data$.parameterScope;
    }
    get params(): FormalParameters {
       return this.data$.params;
    }
    get bodyScope(): AssertedVarScope {
       return this.data$.bodyScope;
    }
    get body(): (FunctionBody | Expression) {
       return this.data$.body;
    }
}


export interface I_AssignmentExpression {
    readonly binding: AssignmentTarget;
    readonly expression: Expression;
} // I_AssignmentExpression

export class AssignmentExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_AssignmentExpression>;

    private constructor(data: Ro<I_AssignmentExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AssignmentExpression;
    }
    static make(data: Ro<I_AssignmentExpression>) {
        return new AssignmentExpression(data);
    }

    get binding(): AssignmentTarget {
       return this.data$.binding;
    }
    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_BinaryExpression {
    readonly operator: BinaryOperator;
    readonly left: Expression;
    readonly right: Expression;
} // I_BinaryExpression

export class BinaryExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_BinaryExpression>;

    private constructor(data: Ro<I_BinaryExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.BinaryExpression;
    }
    static make(data: Ro<I_BinaryExpression>) {
        return new BinaryExpression(data);
    }

    get operator(): BinaryOperator {
       return this.data$.operator;
    }
    get left(): Expression {
       return this.data$.left;
    }
    get right(): Expression {
       return this.data$.right;
    }
}


export interface I_CallExpression {
    readonly callee: (Expression | Super);
    readonly arguments: Arguments;
} // I_CallExpression

export class CallExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_CallExpression>;

    private constructor(data: Ro<I_CallExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.CallExpression;
    }
    static make(data: Ro<I_CallExpression>) {
        return new CallExpression(data);
    }

    get callee(): (Expression | Super) {
       return this.data$.callee;
    }
    get arguments(): Arguments {
       return this.data$.arguments;
    }
}


export interface I_CompoundAssignmentExpression {
    readonly operator: CompoundAssignmentOperator;
    readonly binding: SimpleAssignmentTarget;
    readonly expression: Expression;
} // I_CompoundAssignmentExpression

export class CompoundAssignmentExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_CompoundAssignmentExpression>;

    private constructor(data: Ro<I_CompoundAssignmentExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.CompoundAssignmentExpression;
    }
    static make(data: Ro<I_CompoundAssignmentExpression>) {
        return new CompoundAssignmentExpression(data);
    }

    get operator(): CompoundAssignmentOperator {
       return this.data$.operator;
    }
    get binding(): SimpleAssignmentTarget {
       return this.data$.binding;
    }
    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_ComputedMemberExpression {
    readonly object: (Expression | Super);
    readonly expression: Expression;
} // I_ComputedMemberExpression

export class ComputedMemberExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ComputedMemberExpression>;

    private constructor(data: Ro<I_ComputedMemberExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ComputedMemberExpression;
    }
    static make(data: Ro<I_ComputedMemberExpression>) {
        return new ComputedMemberExpression(data);
    }

    get object(): (Expression | Super) {
       return this.data$.object;
    }
    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_ConditionalExpression {
    readonly test: Expression;
    readonly consequent: Expression;
    readonly alternate: Expression;
} // I_ConditionalExpression

export class ConditionalExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ConditionalExpression>;

    private constructor(data: Ro<I_ConditionalExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ConditionalExpression;
    }
    static make(data: Ro<I_ConditionalExpression>) {
        return new ConditionalExpression(data);
    }

    get test(): Expression {
       return this.data$.test;
    }
    get consequent(): Expression {
       return this.data$.consequent;
    }
    get alternate(): Expression {
       return this.data$.alternate;
    }
}


export interface I_EagerFunctionExpression {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: (null | BindingIdentifier);
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionExpressionContents;
} // I_EagerFunctionExpression

export class EagerFunctionExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_EagerFunctionExpression>;

    private constructor(data: Ro<I_EagerFunctionExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.EagerFunctionExpression;
    }
    static make(data: Ro<I_EagerFunctionExpression>) {
        return new EagerFunctionExpression(data);
    }

    get isAsync(): boolean {
       return this.data$.isAsync;
    }
    get isGenerator(): boolean {
       return this.data$.isGenerator;
    }
    get name(): (null | BindingIdentifier) {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get contents(): FunctionExpressionContents {
       return this.data$.contents;
    }
}


export interface I_LazyFunctionExpression {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: (null | BindingIdentifier);
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionExpressionContents;
} // I_LazyFunctionExpression

export class LazyFunctionExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LazyFunctionExpression>;

    private constructor(data: Ro<I_LazyFunctionExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LazyFunctionExpression;
    }
    static make(data: Ro<I_LazyFunctionExpression>) {
        return new LazyFunctionExpression(data);
    }

    get isAsync(): boolean {
       return this.data$.isAsync;
    }
    get isGenerator(): boolean {
       return this.data$.isGenerator;
    }
    get name(): (null | BindingIdentifier) {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get contents(): FunctionExpressionContents {
       return this.data$.contents;
    }
}


export interface I_FunctionExpressionContents {
    readonly isFunctionNameCaptured: boolean;
    readonly isThisCaptured: boolean;
    readonly parameterScope: AssertedParameterScope;
    readonly params: FormalParameters;
    readonly bodyScope: AssertedVarScope;
    readonly body: FunctionBody;
} // I_FunctionExpressionContents

export class FunctionExpressionContents
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_FunctionExpressionContents>;

    private constructor(data: Ro<I_FunctionExpressionContents>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.FunctionExpressionContents;
    }
    static make(data: Ro<I_FunctionExpressionContents>) {
        return new FunctionExpressionContents(data);
    }

    get isFunctionNameCaptured(): boolean {
       return this.data$.isFunctionNameCaptured;
    }
    get isThisCaptured(): boolean {
       return this.data$.isThisCaptured;
    }
    get parameterScope(): AssertedParameterScope {
       return this.data$.parameterScope;
    }
    get params(): FormalParameters {
       return this.data$.params;
    }
    get bodyScope(): AssertedVarScope {
       return this.data$.bodyScope;
    }
    get body(): FunctionBody {
       return this.data$.body;
    }
}


export interface I_IdentifierExpression {
    readonly name: Identifier;
} // I_IdentifierExpression

export class IdentifierExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_IdentifierExpression>;

    private constructor(data: Ro<I_IdentifierExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.IdentifierExpression;
    }
    static make(data: Ro<I_IdentifierExpression>) {
        return new IdentifierExpression(data);
    }

    get name(): Identifier {
       return this.data$.name;
    }
}


export interface I_NewExpression {
    readonly callee: Expression;
    readonly arguments: Arguments;
} // I_NewExpression

export class NewExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_NewExpression>;

    private constructor(data: Ro<I_NewExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.NewExpression;
    }
    static make(data: Ro<I_NewExpression>) {
        return new NewExpression(data);
    }

    get callee(): Expression {
       return this.data$.callee;
    }
    get arguments(): Arguments {
       return this.data$.arguments;
    }
}


export interface I_NewTargetExpression {
} // I_NewTargetExpression

export class NewTargetExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_NewTargetExpression>;

    private constructor(data: Ro<I_NewTargetExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.NewTargetExpression;
    }
    static make(data: Ro<I_NewTargetExpression>) {
        return new NewTargetExpression(data);
    }

}


export interface I_ObjectExpression {
    readonly properties: RoArr<ObjectProperty>;
} // I_ObjectExpression

export class ObjectExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ObjectExpression>;

    private constructor(data: Ro<I_ObjectExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ObjectExpression;
    }
    static make(data: Ro<I_ObjectExpression>) {
        return new ObjectExpression(data);
    }

    get properties(): RoArr<ObjectProperty> {
       return this.data$.properties;
    }
}


export interface I_UnaryExpression {
    readonly operator: UnaryOperator;
    readonly operand: Expression;
} // I_UnaryExpression

export class UnaryExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_UnaryExpression>;

    private constructor(data: Ro<I_UnaryExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.UnaryExpression;
    }
    static make(data: Ro<I_UnaryExpression>) {
        return new UnaryExpression(data);
    }

    get operator(): UnaryOperator {
       return this.data$.operator;
    }
    get operand(): Expression {
       return this.data$.operand;
    }
}


export interface I_StaticMemberExpression {
    readonly object: (Expression | Super);
    readonly property: IdentifierName;
} // I_StaticMemberExpression

export class StaticMemberExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_StaticMemberExpression>;

    private constructor(data: Ro<I_StaticMemberExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.StaticMemberExpression;
    }
    static make(data: Ro<I_StaticMemberExpression>) {
        return new StaticMemberExpression(data);
    }

    get object(): (Expression | Super) {
       return this.data$.object;
    }
    get property(): IdentifierName {
       return this.data$.property;
    }
}


export interface I_TemplateExpression {
    readonly tag: (null | Expression);
    readonly elements: RoArr<(Expression | TemplateElement)>;
} // I_TemplateExpression

export class TemplateExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_TemplateExpression>;

    private constructor(data: Ro<I_TemplateExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.TemplateExpression;
    }
    static make(data: Ro<I_TemplateExpression>) {
        return new TemplateExpression(data);
    }

    get tag(): (null | Expression) {
       return this.data$.tag;
    }
    get elements(): RoArr<(Expression | TemplateElement)> {
       return this.data$.elements;
    }
}


export interface I_ThisExpression {
} // I_ThisExpression

export class ThisExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ThisExpression>;

    private constructor(data: Ro<I_ThisExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ThisExpression;
    }
    static make(data: Ro<I_ThisExpression>) {
        return new ThisExpression(data);
    }

}


export interface I_UpdateExpression {
    readonly isPrefix: boolean;
    readonly operator: UpdateOperator;
    readonly operand: SimpleAssignmentTarget;
} // I_UpdateExpression

export class UpdateExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_UpdateExpression>;

    private constructor(data: Ro<I_UpdateExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.UpdateExpression;
    }
    static make(data: Ro<I_UpdateExpression>) {
        return new UpdateExpression(data);
    }

    get isPrefix(): boolean {
       return this.data$.isPrefix;
    }
    get operator(): UpdateOperator {
       return this.data$.operator;
    }
    get operand(): SimpleAssignmentTarget {
       return this.data$.operand;
    }
}


export interface I_YieldExpression {
    readonly expression: (null | Expression);
} // I_YieldExpression

export class YieldExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_YieldExpression>;

    private constructor(data: Ro<I_YieldExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.YieldExpression;
    }
    static make(data: Ro<I_YieldExpression>) {
        return new YieldExpression(data);
    }

    get expression(): (null | Expression) {
       return this.data$.expression;
    }
}


export interface I_YieldStarExpression {
    readonly expression: Expression;
} // I_YieldStarExpression

export class YieldStarExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_YieldStarExpression>;

    private constructor(data: Ro<I_YieldStarExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.YieldStarExpression;
    }
    static make(data: Ro<I_YieldStarExpression>) {
        return new YieldStarExpression(data);
    }

    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_AwaitExpression {
    readonly expression: Expression;
} // I_AwaitExpression

export class AwaitExpression
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_AwaitExpression>;

    private constructor(data: Ro<I_AwaitExpression>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.AwaitExpression;
    }
    static make(data: Ro<I_AwaitExpression>) {
        return new AwaitExpression(data);
    }

    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_BreakStatement {
    readonly label: (null | Label);
} // I_BreakStatement

export class BreakStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_BreakStatement>;

    private constructor(data: Ro<I_BreakStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.BreakStatement;
    }
    static make(data: Ro<I_BreakStatement>) {
        return new BreakStatement(data);
    }

    get label(): (null | Label) {
       return this.data$.label;
    }
}


export interface I_ContinueStatement {
    readonly label: (null | Label);
} // I_ContinueStatement

export class ContinueStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ContinueStatement>;

    private constructor(data: Ro<I_ContinueStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ContinueStatement;
    }
    static make(data: Ro<I_ContinueStatement>) {
        return new ContinueStatement(data);
    }

    get label(): (null | Label) {
       return this.data$.label;
    }
}


export interface I_DebuggerStatement {
} // I_DebuggerStatement

export class DebuggerStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_DebuggerStatement>;

    private constructor(data: Ro<I_DebuggerStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.DebuggerStatement;
    }
    static make(data: Ro<I_DebuggerStatement>) {
        return new DebuggerStatement(data);
    }

}


export interface I_DoWhileStatement {
    readonly test: Expression;
    readonly body: Statement;
} // I_DoWhileStatement

export class DoWhileStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_DoWhileStatement>;

    private constructor(data: Ro<I_DoWhileStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.DoWhileStatement;
    }
    static make(data: Ro<I_DoWhileStatement>) {
        return new DoWhileStatement(data);
    }

    get test(): Expression {
       return this.data$.test;
    }
    get body(): Statement {
       return this.data$.body;
    }
}


export interface I_EmptyStatement {
} // I_EmptyStatement

export class EmptyStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_EmptyStatement>;

    private constructor(data: Ro<I_EmptyStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.EmptyStatement;
    }
    static make(data: Ro<I_EmptyStatement>) {
        return new EmptyStatement(data);
    }

}


export interface I_ExpressionStatement {
    readonly expression: Expression;
} // I_ExpressionStatement

export class ExpressionStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ExpressionStatement>;

    private constructor(data: Ro<I_ExpressionStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ExpressionStatement;
    }
    static make(data: Ro<I_ExpressionStatement>) {
        return new ExpressionStatement(data);
    }

    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_ForInOfBinding {
    readonly kind: VariableDeclarationKind;
    readonly binding: Binding;
} // I_ForInOfBinding

export class ForInOfBinding
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ForInOfBinding>;

    private constructor(data: Ro<I_ForInOfBinding>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ForInOfBinding;
    }
    static make(data: Ro<I_ForInOfBinding>) {
        return new ForInOfBinding(data);
    }

    get kind(): VariableDeclarationKind {
       return this.data$.kind;
    }
    get binding(): Binding {
       return this.data$.binding;
    }
}


export interface I_ForInStatement {
    readonly left: (ForInOfBinding | AssignmentTarget);
    readonly right: Expression;
    readonly body: Statement;
} // I_ForInStatement

export class ForInStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ForInStatement>;

    private constructor(data: Ro<I_ForInStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ForInStatement;
    }
    static make(data: Ro<I_ForInStatement>) {
        return new ForInStatement(data);
    }

    get left(): (ForInOfBinding | AssignmentTarget) {
       return this.data$.left;
    }
    get right(): Expression {
       return this.data$.right;
    }
    get body(): Statement {
       return this.data$.body;
    }
}


export interface I_ForOfStatement {
    readonly left: (ForInOfBinding | AssignmentTarget);
    readonly right: Expression;
    readonly body: Statement;
} // I_ForOfStatement

export class ForOfStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ForOfStatement>;

    private constructor(data: Ro<I_ForOfStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ForOfStatement;
    }
    static make(data: Ro<I_ForOfStatement>) {
        return new ForOfStatement(data);
    }

    get left(): (ForInOfBinding | AssignmentTarget) {
       return this.data$.left;
    }
    get right(): Expression {
       return this.data$.right;
    }
    get body(): Statement {
       return this.data$.body;
    }
}


export interface I_ForStatement {
    readonly init: (null | VariableDeclaration | Expression);
    readonly test: (null | Expression);
    readonly update: (null | Expression);
    readonly body: Statement;
} // I_ForStatement

export class ForStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ForStatement>;

    private constructor(data: Ro<I_ForStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ForStatement;
    }
    static make(data: Ro<I_ForStatement>) {
        return new ForStatement(data);
    }

    get init(): (null | VariableDeclaration | Expression) {
       return this.data$.init;
    }
    get test(): (null | Expression) {
       return this.data$.test;
    }
    get update(): (null | Expression) {
       return this.data$.update;
    }
    get body(): Statement {
       return this.data$.body;
    }
}


export interface I_IfStatement {
    readonly test: Expression;
    readonly consequent: Statement;
    readonly alternate: (null | Statement);
} // I_IfStatement

export class IfStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_IfStatement>;

    private constructor(data: Ro<I_IfStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.IfStatement;
    }
    static make(data: Ro<I_IfStatement>) {
        return new IfStatement(data);
    }

    get test(): Expression {
       return this.data$.test;
    }
    get consequent(): Statement {
       return this.data$.consequent;
    }
    get alternate(): (null | Statement) {
       return this.data$.alternate;
    }
}


export interface I_LabelledStatement {
    readonly label: Label;
    readonly body: Statement;
} // I_LabelledStatement

export class LabelledStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LabelledStatement>;

    private constructor(data: Ro<I_LabelledStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LabelledStatement;
    }
    static make(data: Ro<I_LabelledStatement>) {
        return new LabelledStatement(data);
    }

    get label(): Label {
       return this.data$.label;
    }
    get body(): Statement {
       return this.data$.body;
    }
}


export interface I_ReturnStatement {
    readonly expression: (null | Expression);
} // I_ReturnStatement

export class ReturnStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ReturnStatement>;

    private constructor(data: Ro<I_ReturnStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ReturnStatement;
    }
    static make(data: Ro<I_ReturnStatement>) {
        return new ReturnStatement(data);
    }

    get expression(): (null | Expression) {
       return this.data$.expression;
    }
}


export interface I_SwitchStatement {
    readonly discriminant: Expression;
    readonly cases: RoArr<SwitchCase>;
} // I_SwitchStatement

export class SwitchStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_SwitchStatement>;

    private constructor(data: Ro<I_SwitchStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.SwitchStatement;
    }
    static make(data: Ro<I_SwitchStatement>) {
        return new SwitchStatement(data);
    }

    get discriminant(): Expression {
       return this.data$.discriminant;
    }
    get cases(): RoArr<SwitchCase> {
       return this.data$.cases;
    }
}


export interface I_SwitchStatementWithDefault {
    readonly discriminant: Expression;
    readonly preDefaultCases: RoArr<SwitchCase>;
    readonly defaultCase: SwitchDefault;
    readonly postDefaultCases: RoArr<SwitchCase>;
} // I_SwitchStatementWithDefault

export class SwitchStatementWithDefault
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_SwitchStatementWithDefault>;

    private constructor(data: Ro<I_SwitchStatementWithDefault>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.SwitchStatementWithDefault;
    }
    static make(data: Ro<I_SwitchStatementWithDefault>) {
        return new SwitchStatementWithDefault(data);
    }

    get discriminant(): Expression {
       return this.data$.discriminant;
    }
    get preDefaultCases(): RoArr<SwitchCase> {
       return this.data$.preDefaultCases;
    }
    get defaultCase(): SwitchDefault {
       return this.data$.defaultCase;
    }
    get postDefaultCases(): RoArr<SwitchCase> {
       return this.data$.postDefaultCases;
    }
}


export interface I_ThrowStatement {
    readonly expression: Expression;
} // I_ThrowStatement

export class ThrowStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_ThrowStatement>;

    private constructor(data: Ro<I_ThrowStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.ThrowStatement;
    }
    static make(data: Ro<I_ThrowStatement>) {
        return new ThrowStatement(data);
    }

    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_TryCatchStatement {
    readonly body: Block;
    readonly catchClause: CatchClause;
} // I_TryCatchStatement

export class TryCatchStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_TryCatchStatement>;

    private constructor(data: Ro<I_TryCatchStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.TryCatchStatement;
    }
    static make(data: Ro<I_TryCatchStatement>) {
        return new TryCatchStatement(data);
    }

    get body(): Block {
       return this.data$.body;
    }
    get catchClause(): CatchClause {
       return this.data$.catchClause;
    }
}


export interface I_TryFinallyStatement {
    readonly body: Block;
    readonly catchClause: (null | CatchClause);
    readonly finalizer: Block;
} // I_TryFinallyStatement

export class TryFinallyStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_TryFinallyStatement>;

    private constructor(data: Ro<I_TryFinallyStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.TryFinallyStatement;
    }
    static make(data: Ro<I_TryFinallyStatement>) {
        return new TryFinallyStatement(data);
    }

    get body(): Block {
       return this.data$.body;
    }
    get catchClause(): (null | CatchClause) {
       return this.data$.catchClause;
    }
    get finalizer(): Block {
       return this.data$.finalizer;
    }
}


export interface I_WhileStatement {
    readonly test: Expression;
    readonly body: Statement;
} // I_WhileStatement

export class WhileStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_WhileStatement>;

    private constructor(data: Ro<I_WhileStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.WhileStatement;
    }
    static make(data: Ro<I_WhileStatement>) {
        return new WhileStatement(data);
    }

    get test(): Expression {
       return this.data$.test;
    }
    get body(): Statement {
       return this.data$.body;
    }
}


export interface I_WithStatement {
    readonly object: Expression;
    readonly body: Statement;
} // I_WithStatement

export class WithStatement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_WithStatement>;

    private constructor(data: Ro<I_WithStatement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.WithStatement;
    }
    static make(data: Ro<I_WithStatement>) {
        return new WithStatement(data);
    }

    get object(): Expression {
       return this.data$.object;
    }
    get body(): Statement {
       return this.data$.body;
    }
}


export interface I_Block {
    readonly scope: AssertedBlockScope;
    readonly statements: RoArr<Statement>;
} // I_Block

export class Block
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_Block>;

    private constructor(data: Ro<I_Block>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.Block;
    }
    static make(data: Ro<I_Block>) {
        return new Block(data);
    }

    get scope(): AssertedBlockScope {
       return this.data$.scope;
    }
    get statements(): RoArr<Statement> {
       return this.data$.statements;
    }
}


export interface I_CatchClause {
    readonly bindingScope: AssertedBoundNamesScope;
    readonly binding: Binding;
    readonly body: Block;
} // I_CatchClause

export class CatchClause
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_CatchClause>;

    private constructor(data: Ro<I_CatchClause>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.CatchClause;
    }
    static make(data: Ro<I_CatchClause>) {
        return new CatchClause(data);
    }

    get bindingScope(): AssertedBoundNamesScope {
       return this.data$.bindingScope;
    }
    get binding(): Binding {
       return this.data$.binding;
    }
    get body(): Block {
       return this.data$.body;
    }
}


export interface I_Directive {
    readonly rawValue: string;
} // I_Directive

export class Directive
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_Directive>;

    private constructor(data: Ro<I_Directive>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.Directive;
    }
    static make(data: Ro<I_Directive>) {
        return new Directive(data);
    }

    get rawValue(): string {
       return this.data$.rawValue;
    }
}


export interface I_FormalParameters {
    readonly items: RoArr<Parameter>;
    readonly rest: (null | Binding);
} // I_FormalParameters

export class FormalParameters
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_FormalParameters>;

    private constructor(data: Ro<I_FormalParameters>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.FormalParameters;
    }
    static make(data: Ro<I_FormalParameters>) {
        return new FormalParameters(data);
    }

    get items(): RoArr<Parameter> {
       return this.data$.items;
    }
    get rest(): (null | Binding) {
       return this.data$.rest;
    }
}


export type FunctionBody = RoArr<Statement>;


export interface I_EagerFunctionDeclaration {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: BindingIdentifier;
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionOrMethodContents;
} // I_EagerFunctionDeclaration

export class EagerFunctionDeclaration
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_EagerFunctionDeclaration>;

    private constructor(data: Ro<I_EagerFunctionDeclaration>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.EagerFunctionDeclaration;
    }
    static make(data: Ro<I_EagerFunctionDeclaration>) {
        return new EagerFunctionDeclaration(data);
    }

    get isAsync(): boolean {
       return this.data$.isAsync;
    }
    get isGenerator(): boolean {
       return this.data$.isGenerator;
    }
    get name(): BindingIdentifier {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get contents(): FunctionOrMethodContents {
       return this.data$.contents;
    }
}


export interface I_LazyFunctionDeclaration {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: BindingIdentifier;
    readonly directives: RoArr<Directive>;
    readonly content: FunctionOrMethodContents;
} // I_LazyFunctionDeclaration

export class LazyFunctionDeclaration
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_LazyFunctionDeclaration>;

    private constructor(data: Ro<I_LazyFunctionDeclaration>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.LazyFunctionDeclaration;
    }
    static make(data: Ro<I_LazyFunctionDeclaration>) {
        return new LazyFunctionDeclaration(data);
    }

    get isAsync(): boolean {
       return this.data$.isAsync;
    }
    get isGenerator(): boolean {
       return this.data$.isGenerator;
    }
    get name(): BindingIdentifier {
       return this.data$.name;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get content(): FunctionOrMethodContents {
       return this.data$.content;
    }
}


export interface I_FunctionOrMethodContents {
    readonly isThisCaptured: boolean;
    readonly parameterScope: AssertedParameterScope;
    readonly params: FormalParameters;
    readonly bodyScope: AssertedVarScope;
    readonly body: FunctionBody;
} // I_FunctionOrMethodContents

export class FunctionOrMethodContents
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_FunctionOrMethodContents>;

    private constructor(data: Ro<I_FunctionOrMethodContents>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.FunctionOrMethodContents;
    }
    static make(data: Ro<I_FunctionOrMethodContents>) {
        return new FunctionOrMethodContents(data);
    }

    get isThisCaptured(): boolean {
       return this.data$.isThisCaptured;
    }
    get parameterScope(): AssertedParameterScope {
       return this.data$.parameterScope;
    }
    get params(): FormalParameters {
       return this.data$.params;
    }
    get bodyScope(): AssertedVarScope {
       return this.data$.bodyScope;
    }
    get body(): FunctionBody {
       return this.data$.body;
    }
}


export interface I_Script {
    readonly scope: AssertedScriptGlobalScope;
    readonly directives: RoArr<Directive>;
    readonly statements: RoArr<Statement>;
} // I_Script

export class Script
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_Script>;

    private constructor(data: Ro<I_Script>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.Script;
    }
    static make(data: Ro<I_Script>) {
        return new Script(data);
    }

    get scope(): AssertedScriptGlobalScope {
       return this.data$.scope;
    }
    get directives(): RoArr<Directive> {
       return this.data$.directives;
    }
    get statements(): RoArr<Statement> {
       return this.data$.statements;
    }
}


export interface I_SpreadElement {
    readonly expression: Expression;
} // I_SpreadElement

export class SpreadElement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_SpreadElement>;

    private constructor(data: Ro<I_SpreadElement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.SpreadElement;
    }
    static make(data: Ro<I_SpreadElement>) {
        return new SpreadElement(data);
    }

    get expression(): Expression {
       return this.data$.expression;
    }
}


export interface I_Super {
} // I_Super

export class Super
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_Super>;

    private constructor(data: Ro<I_Super>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.Super;
    }
    static make(data: Ro<I_Super>) {
        return new Super(data);
    }

}


export interface I_SwitchCase {
    readonly test: Expression;
    readonly consequent: RoArr<Statement>;
} // I_SwitchCase

export class SwitchCase
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_SwitchCase>;

    private constructor(data: Ro<I_SwitchCase>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.SwitchCase;
    }
    static make(data: Ro<I_SwitchCase>) {
        return new SwitchCase(data);
    }

    get test(): Expression {
       return this.data$.test;
    }
    get consequent(): RoArr<Statement> {
       return this.data$.consequent;
    }
}


export interface I_SwitchDefault {
    readonly consequent: RoArr<Statement>;
} // I_SwitchDefault

export class SwitchDefault
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_SwitchDefault>;

    private constructor(data: Ro<I_SwitchDefault>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.SwitchDefault;
    }
    static make(data: Ro<I_SwitchDefault>) {
        return new SwitchDefault(data);
    }

    get consequent(): RoArr<Statement> {
       return this.data$.consequent;
    }
}


export interface I_TemplateElement {
    readonly rawValue: string;
} // I_TemplateElement

export class TemplateElement
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_TemplateElement>;

    private constructor(data: Ro<I_TemplateElement>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.TemplateElement;
    }
    static make(data: Ro<I_TemplateElement>) {
        return new TemplateElement(data);
    }

    get rawValue(): string {
       return this.data$.rawValue;
    }
}


export interface I_VariableDeclaration {
    readonly kind: VariableDeclarationKind;
    readonly declarators: RoArr<VariableDeclarator>;
} // I_VariableDeclaration

export class VariableDeclaration
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_VariableDeclaration>;

    private constructor(data: Ro<I_VariableDeclaration>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.VariableDeclaration;
    }
    static make(data: Ro<I_VariableDeclaration>) {
        return new VariableDeclaration(data);
    }

    get kind(): VariableDeclarationKind {
       return this.data$.kind;
    }
    get declarators(): RoArr<VariableDeclarator> {
       return this.data$.declarators;
    }
}


export interface I_VariableDeclarator {
    readonly binding: Binding;
    readonly init: (null | Expression);
} // I_VariableDeclarator

export class VariableDeclarator
  extends BaseNode
  implements S.Instance
{
    readonly data$: Ro<I_VariableDeclarator>;

    private constructor(data: Ro<I_VariableDeclarator>) {
    super();
        this.data$ = Object.freeze(data);
        Object.freeze(this);
    }

    get iface$(): S.Iface {
        return ReflectedSchema.VariableDeclarator;
    }
    static make(data: Ro<I_VariableDeclarator>) {
        return new VariableDeclarator(data);
    }

    get binding(): Binding {
       return this.data$.binding;
    }
    get init(): (null | Expression) {
       return this.data$.init;
    }
}


