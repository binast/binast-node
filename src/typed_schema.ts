/*** TypeScript API ***/

/* Autogenerated in `tree_schema.ts.`
 * See `dumpTypescript` methods.
 */

import * as assert from 'assert';
import * as S from 'binast-schema';

export type UInt = number;
export type Int = number;
export type Opt<T> = (null | T);
export type Ro<T> = Readonly<T>;
export type Arr<T> = Array<T>;
export type RoArr<T> = ReadonlyArray<T>;


abstract class BaseNode {
}

/*** Reflected Schema Builder ***/


/* Helpers. */
function TOpt(inner: S.FieldType): S.FieldTypeOpt {
   return S.FieldTypeOpt.make(inner);
}

function TArray(inner: S.FieldType): S.FieldTypeArray {
   return S.FieldTypeArray.make(inner);
}

function TUnion(inners: Array<S.FieldType>): S.FieldTypeUnion {
   return S.FieldTypeUnion.make(Object.freeze(inners));
}

function TNamed(name: string): S.FieldTypeNamed {
   return S.FieldTypeNamed.make(S.TypeName.make(name));
}

const TBool = S.PrimitiveType.Bool;
const TUint = S.PrimitiveType.Uint;
const TInt = S.PrimitiveType.Int;
const TF64 = S.PrimitiveType.F64;
const TStr = S.PrimitiveType.Str;

function mkEVN(name: string): S.EnumVariantName {
   return S.EnumVariantName.make(name);
}

const ReflectedSchema = {
    get Arguments(): S.Typedef {
        if (!this["c_Arguments"]) {
            const typeName = S.TypeName.make("Arguments");
            const aliased = TArray(TUnion([TNamed("SpreadElement"), TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]));
            this["c_Arguments"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Arguments"] instanceof S.Typedef);
        return this["c_Arguments"] as S.Typedef;
    },
    get typeof_Arguments(): S.FieldType {
        return this.Arguments.aliased;
    },


    get Identifier(): S.Typedef {
        if (!this["c_Identifier"]) {
            const typeName = S.TypeName.make("Identifier");
            const aliased = TStr;
            this["c_Identifier"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Identifier"] instanceof S.Typedef);
        return this["c_Identifier"] as S.Typedef;
    },
    get typeof_Identifier(): S.FieldType {
        return this.Identifier.aliased;
    },


    get IdentifierName(): S.Typedef {
        if (!this["c_IdentifierName"]) {
            const typeName = S.TypeName.make("IdentifierName");
            const aliased = TStr;
            this["c_IdentifierName"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_IdentifierName"] instanceof S.Typedef);
        return this["c_IdentifierName"] as S.Typedef;
    },
    get typeof_IdentifierName(): S.FieldType {
        return this.IdentifierName.aliased;
    },


    get Label(): S.Typedef {
        if (!this["c_Label"]) {
            const typeName = S.TypeName.make("Label");
            const aliased = TStr;
            this["c_Label"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Label"] instanceof S.Typedef);
        return this["c_Label"] as S.Typedef;
    },
    get typeof_Label(): S.FieldType {
        return this.Label.aliased;
    },


    get VariableDeclarationKind(): S.Enum {
        if (!this["c_VariableDeclarationKind"]) {
            const typeName = S.TypeName.make("VariableDeclarationKind");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("KwVar"))
            vvals.push("var");
    
            vnames.push(mkEVN("KwLet"))
            vvals.push("let");
    
            vnames.push(mkEVN("KwConst"))
            vvals.push("const");
    
            this["c_VariableDeclarationKind"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_VariableDeclarationKind"] instanceof S.Enum);
        return this["c_VariableDeclarationKind"] as S.Enum;
    },
    get typeof_VariableDeclarationKind(): S.FieldType {
        const fieldName = this.VariableDeclarationKind.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get CompoundAssignmentOperator(): S.Enum {
        if (!this["c_CompoundAssignmentOperator"]) {
            const typeName = S.TypeName.make("CompoundAssignmentOperator");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("PlusAssign"))
            vvals.push("+=");
    
            vnames.push(mkEVN("MinusAssign"))
            vvals.push("-=");
    
            vnames.push(mkEVN("MulAssign"))
            vvals.push("*=");
    
            vnames.push(mkEVN("DivAssign"))
            vvals.push("/=");
    
            vnames.push(mkEVN("ModAssign"))
            vvals.push("%=");
    
            vnames.push(mkEVN("PowAssign"))
            vvals.push("**=");
    
            vnames.push(mkEVN("LshAssign"))
            vvals.push("<<=");
    
            vnames.push(mkEVN("RshAssign"))
            vvals.push(">>=");
    
            vnames.push(mkEVN("ArshAssign"))
            vvals.push(">>>=");
    
            vnames.push(mkEVN("BitorAssign"))
            vvals.push("|=");
    
            vnames.push(mkEVN("BitxorAssign"))
            vvals.push("^=");
    
            vnames.push(mkEVN("BitandAssign"))
            vvals.push("&=");
    
            this["c_CompoundAssignmentOperator"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_CompoundAssignmentOperator"] instanceof S.Enum);
        return this["c_CompoundAssignmentOperator"] as S.Enum;
    },
    get typeof_CompoundAssignmentOperator(): S.FieldType {
        const fieldName = this.CompoundAssignmentOperator.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get BinaryOperator(): S.Enum {
        if (!this["c_BinaryOperator"]) {
            const typeName = S.TypeName.make("BinaryOperator");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("Comma"))
            vvals.push(",");
    
            vnames.push(mkEVN("LogicalOr"))
            vvals.push("||");
    
            vnames.push(mkEVN("LogicalAnd"))
            vvals.push("&&");
    
            vnames.push(mkEVN("Bitor"))
            vvals.push("|");
    
            vnames.push(mkEVN("Bitxor"))
            vvals.push("^");
    
            vnames.push(mkEVN("Bitand"))
            vvals.push("&");
    
            vnames.push(mkEVN("Equal"))
            vvals.push("==");
    
            vnames.push(mkEVN("NotEqual"))
            vvals.push("!=");
    
            vnames.push(mkEVN("StrictEqual"))
            vvals.push("===");
    
            vnames.push(mkEVN("NotStrictEqual"))
            vvals.push("!==");
    
            vnames.push(mkEVN("LessThan"))
            vvals.push("<");
    
            vnames.push(mkEVN("LessEqual"))
            vvals.push("<=");
    
            vnames.push(mkEVN("GreaterThan"))
            vvals.push(">");
    
            vnames.push(mkEVN("GreaterEqual"))
            vvals.push(">=");
    
            vnames.push(mkEVN("KwIn"))
            vvals.push("in");
    
            vnames.push(mkEVN("KwInstanceof"))
            vvals.push("instanceof");
    
            vnames.push(mkEVN("Lsh"))
            vvals.push("<<");
    
            vnames.push(mkEVN("Rsh"))
            vvals.push(">>");
    
            vnames.push(mkEVN("Arsh"))
            vvals.push(">>>");
    
            vnames.push(mkEVN("Plus"))
            vvals.push("+");
    
            vnames.push(mkEVN("Minus"))
            vvals.push("-");
    
            vnames.push(mkEVN("Mul"))
            vvals.push("*");
    
            vnames.push(mkEVN("Div"))
            vvals.push("/");
    
            vnames.push(mkEVN("Mod"))
            vvals.push("%");
    
            vnames.push(mkEVN("Pow"))
            vvals.push("**");
    
            this["c_BinaryOperator"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_BinaryOperator"] instanceof S.Enum);
        return this["c_BinaryOperator"] as S.Enum;
    },
    get typeof_BinaryOperator(): S.FieldType {
        const fieldName = this.BinaryOperator.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get UnaryOperator(): S.Enum {
        if (!this["c_UnaryOperator"]) {
            const typeName = S.TypeName.make("UnaryOperator");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("Plus"))
            vvals.push("+");
    
            vnames.push(mkEVN("Minus"))
            vvals.push("-");
    
            vnames.push(mkEVN("LogicalNot"))
            vvals.push("!");
    
            vnames.push(mkEVN("Bitnot"))
            vvals.push("~");
    
            vnames.push(mkEVN("KwTypeof"))
            vvals.push("typeof");
    
            vnames.push(mkEVN("KwVoid"))
            vvals.push("void");
    
            vnames.push(mkEVN("KwDelete"))
            vvals.push("delete");
    
            this["c_UnaryOperator"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_UnaryOperator"] instanceof S.Enum);
        return this["c_UnaryOperator"] as S.Enum;
    },
    get typeof_UnaryOperator(): S.FieldType {
        const fieldName = this.UnaryOperator.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get UpdateOperator(): S.Enum {
        if (!this["c_UpdateOperator"]) {
            const typeName = S.TypeName.make("UpdateOperator");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("PlusPlus"))
            vvals.push("++");
    
            vnames.push(mkEVN("MinusMinus"))
            vvals.push("--");
    
            this["c_UpdateOperator"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_UpdateOperator"] instanceof S.Enum);
        return this["c_UpdateOperator"] as S.Enum;
    },
    get typeof_UpdateOperator(): S.FieldType {
        const fieldName = this.UpdateOperator.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssertedDeclaredKind(): S.Enum {
        if (!this["c_AssertedDeclaredKind"]) {
            const typeName = S.TypeName.make("AssertedDeclaredKind");
            const vnames: Array<S.EnumVariantName> = [];
            const vvals: Array<string> = [];
            vnames.push(mkEVN("KwVar"))
            vvals.push("var");
    
            vnames.push(mkEVN("NonConstLexical"))
            vvals.push("non-const lexical");
    
            vnames.push(mkEVN("ConstLexical"))
            vvals.push("const lexical");
    
            this["c_AssertedDeclaredKind"] = new S.Enum(typeName, vnames, vvals);
        }
        assert(this["c_AssertedDeclaredKind"] instanceof S.Enum);
        return this["c_AssertedDeclaredKind"] as S.Enum;
    },
    get typeof_AssertedDeclaredKind(): S.FieldType {
        const fieldName = this.AssertedDeclaredKind.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssertedDeclaredName(): S.Iface {
        if (!this["c_AssertedDeclaredName"]) {
            const typeName = S.TypeName.make("AssertedDeclaredName");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "kind",
                /* ty = */ TNamed("AssertedDeclaredKind"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedDeclaredName"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedDeclaredName"] instanceof S.Iface);
        return this["c_AssertedDeclaredName"] as S.Iface;
    },
    get typeof_AssertedDeclaredName(): S.FieldType {
        const fieldName = this.AssertedDeclaredName.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssertedBoundName(): S.Iface {
        if (!this["c_AssertedBoundName"]) {
            const typeName = S.TypeName.make("AssertedBoundName");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedBoundName"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedBoundName"] instanceof S.Iface);
        return this["c_AssertedBoundName"] as S.Iface;
    },
    get typeof_AssertedBoundName(): S.FieldType {
        const fieldName = this.AssertedBoundName.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssertedBlockScope(): S.Iface {
        if (!this["c_AssertedBlockScope"]) {
            const typeName = S.TypeName.make("AssertedBlockScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "declaredNames",
                /* ty = */ TArray(TNamed("AssertedDeclaredName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedBlockScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedBlockScope"] instanceof S.Iface);
        return this["c_AssertedBlockScope"] as S.Iface;
    },
    get typeof_AssertedBlockScope(): S.FieldType {
        const fieldName = this.AssertedBlockScope.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssertedScriptGlobalScope(): S.Iface {
        if (!this["c_AssertedScriptGlobalScope"]) {
            const typeName = S.TypeName.make("AssertedScriptGlobalScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "declaredNames",
                /* ty = */ TArray(TNamed("AssertedDeclaredName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedScriptGlobalScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedScriptGlobalScope"] instanceof S.Iface);
        return this["c_AssertedScriptGlobalScope"] as S.Iface;
    },
    get typeof_AssertedScriptGlobalScope(): S.FieldType {
        const fieldName = this.AssertedScriptGlobalScope.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssertedVarScope(): S.Iface {
        if (!this["c_AssertedVarScope"]) {
            const typeName = S.TypeName.make("AssertedVarScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "declaredNames",
                /* ty = */ TArray(TNamed("AssertedDeclaredName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedVarScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedVarScope"] instanceof S.Iface);
        return this["c_AssertedVarScope"] as S.Iface;
    },
    get typeof_AssertedVarScope(): S.FieldType {
        const fieldName = this.AssertedVarScope.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssertedParameterScope(): S.Iface {
        if (!this["c_AssertedParameterScope"]) {
            const typeName = S.TypeName.make("AssertedParameterScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "boundNames",
                /* ty = */ TArray(TNamed("AssertedBoundName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isSimpleParameterList",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedParameterScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedParameterScope"] instanceof S.Iface);
        return this["c_AssertedParameterScope"] as S.Iface;
    },
    get typeof_AssertedParameterScope(): S.FieldType {
        const fieldName = this.AssertedParameterScope.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssertedBoundNamesScope(): S.Iface {
        if (!this["c_AssertedBoundNamesScope"]) {
            const typeName = S.TypeName.make("AssertedBoundNamesScope");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "boundNames",
                /* ty = */ TArray(TNamed("AssertedBoundName")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "hasDirectEval",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_AssertedBoundNamesScope"] = new S.Iface(typeName, fields, false);
        }
        assert(this["c_AssertedBoundNamesScope"] instanceof S.Iface);
        return this["c_AssertedBoundNamesScope"] as S.Iface;
    },
    get typeof_AssertedBoundNamesScope(): S.FieldType {
        const fieldName = this.AssertedBoundNamesScope.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get Program(): S.Typedef {
        if (!this["c_Program"]) {
            const typeName = S.TypeName.make("Program");
            const aliased = TUnion([TNamed("Script"), TNamed("Module")]);
            this["c_Program"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Program"] instanceof S.Typedef);
        return this["c_Program"] as S.Typedef;
    },
    get typeof_Program(): S.FieldType {
        return this.Program.aliased;
    },


    get IterationStatement(): S.Typedef {
        if (!this["c_IterationStatement"]) {
            const typeName = S.TypeName.make("IterationStatement");
            const aliased = TUnion([TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement")]);
            this["c_IterationStatement"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_IterationStatement"] instanceof S.Typedef);
        return this["c_IterationStatement"] as S.Typedef;
    },
    get typeof_IterationStatement(): S.FieldType {
        return this.IterationStatement.aliased;
    },


    get Statement(): S.Typedef {
        if (!this["c_Statement"]) {
            const typeName = S.TypeName.make("Statement");
            const aliased = TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]);
            this["c_Statement"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Statement"] instanceof S.Typedef);
        return this["c_Statement"] as S.Typedef;
    },
    get typeof_Statement(): S.FieldType {
        return this.Statement.aliased;
    },


    get Literal(): S.Typedef {
        if (!this["c_Literal"]) {
            const typeName = S.TypeName.make("Literal");
            const aliased = TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression")]);
            this["c_Literal"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Literal"] instanceof S.Typedef);
        return this["c_Literal"] as S.Typedef;
    },
    get typeof_Literal(): S.FieldType {
        return this.Literal.aliased;
    },


    get Expression(): S.Typedef {
        if (!this["c_Expression"]) {
            const typeName = S.TypeName.make("Expression");
            const aliased = TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]);
            this["c_Expression"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Expression"] instanceof S.Typedef);
        return this["c_Expression"] as S.Typedef;
    },
    get typeof_Expression(): S.FieldType {
        return this.Expression.aliased;
    },


    get PropertyName(): S.Typedef {
        if (!this["c_PropertyName"]) {
            const typeName = S.TypeName.make("PropertyName");
            const aliased = TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]);
            this["c_PropertyName"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_PropertyName"] instanceof S.Typedef);
        return this["c_PropertyName"] as S.Typedef;
    },
    get typeof_PropertyName(): S.FieldType {
        return this.PropertyName.aliased;
    },


    get MethodDefinition(): S.Typedef {
        if (!this["c_MethodDefinition"]) {
            const typeName = S.TypeName.make("MethodDefinition");
            const aliased = TUnion([TNamed("EagerMethod"), TNamed("LazyMethod"), TNamed("EagerGetter"), TNamed("LazyGetter"), TNamed("EagerSetter"), TNamed("LazySetter")]);
            this["c_MethodDefinition"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_MethodDefinition"] instanceof S.Typedef);
        return this["c_MethodDefinition"] as S.Typedef;
    },
    get typeof_MethodDefinition(): S.FieldType {
        return this.MethodDefinition.aliased;
    },


    get ObjectProperty(): S.Typedef {
        if (!this["c_ObjectProperty"]) {
            const typeName = S.TypeName.make("ObjectProperty");
            const aliased = TUnion([TNamed("EagerMethod"), TNamed("LazyMethod"), TNamed("EagerGetter"), TNamed("LazyGetter"), TNamed("EagerSetter"), TNamed("LazySetter"), TNamed("DataProperty"), TNamed("ShorthandProperty")]);
            this["c_ObjectProperty"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_ObjectProperty"] instanceof S.Typedef);
        return this["c_ObjectProperty"] as S.Typedef;
    },
    get typeof_ObjectProperty(): S.FieldType {
        return this.ObjectProperty.aliased;
    },


    get ExportDeclaration(): S.Typedef {
        if (!this["c_ExportDeclaration"]) {
            const typeName = S.TypeName.make("ExportDeclaration");
            const aliased = TUnion([TNamed("ExportAllFrom"), TNamed("ExportFrom"), TNamed("ExportLocals"), TNamed("ExportDefault"), TNamed("Export")]);
            this["c_ExportDeclaration"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_ExportDeclaration"] instanceof S.Typedef);
        return this["c_ExportDeclaration"] as S.Typedef;
    },
    get typeof_ExportDeclaration(): S.FieldType {
        return this.ExportDeclaration.aliased;
    },


    get ImportDeclaration(): S.Typedef {
        if (!this["c_ImportDeclaration"]) {
            const typeName = S.TypeName.make("ImportDeclaration");
            const aliased = TUnion([TNamed("ImportNamespace"), TNamed("Import")]);
            this["c_ImportDeclaration"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_ImportDeclaration"] instanceof S.Typedef);
        return this["c_ImportDeclaration"] as S.Typedef;
    },
    get typeof_ImportDeclaration(): S.FieldType {
        return this.ImportDeclaration.aliased;
    },


    get FunctionDeclaration(): S.Typedef {
        if (!this["c_FunctionDeclaration"]) {
            const typeName = S.TypeName.make("FunctionDeclaration");
            const aliased = TUnion([TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration")]);
            this["c_FunctionDeclaration"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_FunctionDeclaration"] instanceof S.Typedef);
        return this["c_FunctionDeclaration"] as S.Typedef;
    },
    get typeof_FunctionDeclaration(): S.FieldType {
        return this.FunctionDeclaration.aliased;
    },


    get FunctionExpression(): S.Typedef {
        if (!this["c_FunctionExpression"]) {
            const typeName = S.TypeName.make("FunctionExpression");
            const aliased = TUnion([TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression")]);
            this["c_FunctionExpression"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_FunctionExpression"] instanceof S.Typedef);
        return this["c_FunctionExpression"] as S.Typedef;
    },
    get typeof_FunctionExpression(): S.FieldType {
        return this.FunctionExpression.aliased;
    },


    get Method(): S.Typedef {
        if (!this["c_Method"]) {
            const typeName = S.TypeName.make("Method");
            const aliased = TUnion([TNamed("EagerMethod"), TNamed("LazyMethod")]);
            this["c_Method"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Method"] instanceof S.Typedef);
        return this["c_Method"] as S.Typedef;
    },
    get typeof_Method(): S.FieldType {
        return this.Method.aliased;
    },


    get Getter(): S.Typedef {
        if (!this["c_Getter"]) {
            const typeName = S.TypeName.make("Getter");
            const aliased = TUnion([TNamed("EagerGetter"), TNamed("LazyGetter")]);
            this["c_Getter"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Getter"] instanceof S.Typedef);
        return this["c_Getter"] as S.Typedef;
    },
    get typeof_Getter(): S.FieldType {
        return this.Getter.aliased;
    },


    get Setter(): S.Typedef {
        if (!this["c_Setter"]) {
            const typeName = S.TypeName.make("Setter");
            const aliased = TUnion([TNamed("EagerSetter"), TNamed("LazySetter")]);
            this["c_Setter"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Setter"] instanceof S.Typedef);
        return this["c_Setter"] as S.Typedef;
    },
    get typeof_Setter(): S.FieldType {
        return this.Setter.aliased;
    },


    get ArrowExpression(): S.Typedef {
        if (!this["c_ArrowExpression"]) {
            const typeName = S.TypeName.make("ArrowExpression");
            const aliased = TUnion([TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression")]);
            this["c_ArrowExpression"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_ArrowExpression"] instanceof S.Typedef);
        return this["c_ArrowExpression"] as S.Typedef;
    },
    get typeof_ArrowExpression(): S.FieldType {
        return this.ArrowExpression.aliased;
    },


    get BindingIdentifier(): S.Iface {
        if (!this["c_BindingIdentifier"]) {
            const typeName = S.TypeName.make("BindingIdentifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_BindingIdentifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BindingIdentifier"] instanceof S.Iface);
        return this["c_BindingIdentifier"] as S.Iface;
    },
    get typeof_BindingIdentifier(): S.FieldType {
        const fieldName = this.BindingIdentifier.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get BindingPattern(): S.Typedef {
        if (!this["c_BindingPattern"]) {
            const typeName = S.TypeName.make("BindingPattern");
            const aliased = TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding")]);
            this["c_BindingPattern"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_BindingPattern"] instanceof S.Typedef);
        return this["c_BindingPattern"] as S.Typedef;
    },
    get typeof_BindingPattern(): S.FieldType {
        return this.BindingPattern.aliased;
    },


    get Binding(): S.Typedef {
        if (!this["c_Binding"]) {
            const typeName = S.TypeName.make("Binding");
            const aliased = TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier")]);
            this["c_Binding"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Binding"] instanceof S.Typedef);
        return this["c_Binding"] as S.Typedef;
    },
    get typeof_Binding(): S.FieldType {
        return this.Binding.aliased;
    },


    get SimpleAssignmentTarget(): S.Typedef {
        if (!this["c_SimpleAssignmentTarget"]) {
            const typeName = S.TypeName.make("SimpleAssignmentTarget");
            const aliased = TUnion([TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")]);
            this["c_SimpleAssignmentTarget"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_SimpleAssignmentTarget"] instanceof S.Typedef);
        return this["c_SimpleAssignmentTarget"] as S.Typedef;
    },
    get typeof_SimpleAssignmentTarget(): S.FieldType {
        return this.SimpleAssignmentTarget.aliased;
    },


    get AssignmentTargetPattern(): S.Typedef {
        if (!this["c_AssignmentTargetPattern"]) {
            const typeName = S.TypeName.make("AssignmentTargetPattern");
            const aliased = TUnion([TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget")]);
            this["c_AssignmentTargetPattern"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_AssignmentTargetPattern"] instanceof S.Typedef);
        return this["c_AssignmentTargetPattern"] as S.Typedef;
    },
    get typeof_AssignmentTargetPattern(): S.FieldType {
        return this.AssignmentTargetPattern.aliased;
    },


    get AssignmentTarget(): S.Typedef {
        if (!this["c_AssignmentTarget"]) {
            const typeName = S.TypeName.make("AssignmentTarget");
            const aliased = TUnion([TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget"), TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")]);
            this["c_AssignmentTarget"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_AssignmentTarget"] instanceof S.Typedef);
        return this["c_AssignmentTarget"] as S.Typedef;
    },
    get typeof_AssignmentTarget(): S.FieldType {
        return this.AssignmentTarget.aliased;
    },


    get Parameter(): S.Typedef {
        if (!this["c_Parameter"]) {
            const typeName = S.TypeName.make("Parameter");
            const aliased = TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier"), TNamed("BindingWithInitializer")]);
            this["c_Parameter"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_Parameter"] instanceof S.Typedef);
        return this["c_Parameter"] as S.Typedef;
    },
    get typeof_Parameter(): S.FieldType {
        return this.Parameter.aliased;
    },


    get BindingWithInitializer(): S.Iface {
        if (!this["c_BindingWithInitializer"]) {
            const typeName = S.TypeName.make("BindingWithInitializer");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_BindingWithInitializer"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BindingWithInitializer"] instanceof S.Iface);
        return this["c_BindingWithInitializer"] as S.Iface;
    },
    get typeof_BindingWithInitializer(): S.FieldType {
        const fieldName = this.BindingWithInitializer.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssignmentTargetIdentifier(): S.Iface {
        if (!this["c_AssignmentTargetIdentifier"]) {
            const typeName = S.TypeName.make("AssignmentTargetIdentifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_AssignmentTargetIdentifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentTargetIdentifier"] instanceof S.Iface);
        return this["c_AssignmentTargetIdentifier"] as S.Iface;
    },
    get typeof_AssignmentTargetIdentifier(): S.FieldType {
        const fieldName = this.AssignmentTargetIdentifier.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ComputedMemberAssignmentTarget(): S.Iface {
        if (!this["c_ComputedMemberAssignmentTarget"]) {
            const typeName = S.TypeName.make("ComputedMemberAssignmentTarget");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_ComputedMemberAssignmentTarget"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ComputedMemberAssignmentTarget"] instanceof S.Iface);
        return this["c_ComputedMemberAssignmentTarget"] as S.Iface;
    },
    get typeof_ComputedMemberAssignmentTarget(): S.FieldType {
        const fieldName = this.ComputedMemberAssignmentTarget.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get StaticMemberAssignmentTarget(): S.Iface {
        if (!this["c_StaticMemberAssignmentTarget"]) {
            const typeName = S.TypeName.make("StaticMemberAssignmentTarget");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "property",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_StaticMemberAssignmentTarget"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_StaticMemberAssignmentTarget"] instanceof S.Iface);
        return this["c_StaticMemberAssignmentTarget"] as S.Iface;
    },
    get typeof_StaticMemberAssignmentTarget(): S.FieldType {
        const fieldName = this.StaticMemberAssignmentTarget.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ArrayBinding(): S.Iface {
        if (!this["c_ArrayBinding"]) {
            const typeName = S.TypeName.make("ArrayBinding");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TOpt(TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier"), TNamed("BindingWithInitializer")]))),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "rest",
                /* ty = */ TOpt(TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier")])),
                /* isLazy = */ false),
            ];
            this["c_ArrayBinding"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ArrayBinding"] instanceof S.Iface);
        return this["c_ArrayBinding"] as S.Iface;
    },
    get typeof_ArrayBinding(): S.FieldType {
        const fieldName = this.ArrayBinding.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get BindingPropertyIdentifier(): S.Iface {
        if (!this["c_BindingPropertyIdentifier"]) {
            const typeName = S.TypeName.make("BindingPropertyIdentifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            ];
            this["c_BindingPropertyIdentifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BindingPropertyIdentifier"] instanceof S.Iface);
        return this["c_BindingPropertyIdentifier"] as S.Iface;
    },
    get typeof_BindingPropertyIdentifier(): S.FieldType {
        const fieldName = this.BindingPropertyIdentifier.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get BindingPropertyProperty(): S.Iface {
        if (!this["c_BindingPropertyProperty"]) {
            const typeName = S.TypeName.make("BindingPropertyProperty");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier"), TNamed("BindingWithInitializer")]),
                /* isLazy = */ false),
            ];
            this["c_BindingPropertyProperty"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BindingPropertyProperty"] instanceof S.Iface);
        return this["c_BindingPropertyProperty"] as S.Iface;
    },
    get typeof_BindingPropertyProperty(): S.FieldType {
        const fieldName = this.BindingPropertyProperty.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get BindingProperty(): S.Typedef {
        if (!this["c_BindingProperty"]) {
            const typeName = S.TypeName.make("BindingProperty");
            const aliased = TUnion([TNamed("BindingPropertyIdentifier"), TNamed("BindingPropertyProperty")]);
            this["c_BindingProperty"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_BindingProperty"] instanceof S.Typedef);
        return this["c_BindingProperty"] as S.Typedef;
    },
    get typeof_BindingProperty(): S.FieldType {
        return this.BindingProperty.aliased;
    },


    get ObjectBinding(): S.Iface {
        if (!this["c_ObjectBinding"]) {
            const typeName = S.TypeName.make("ObjectBinding");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "properties",
                /* ty = */ TArray(TUnion([TNamed("BindingPropertyIdentifier"), TNamed("BindingPropertyProperty")])),
                /* isLazy = */ false),
            ];
            this["c_ObjectBinding"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ObjectBinding"] instanceof S.Iface);
        return this["c_ObjectBinding"] as S.Iface;
    },
    get typeof_ObjectBinding(): S.FieldType {
        const fieldName = this.ObjectBinding.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssignmentTargetWithInitializer(): S.Iface {
        if (!this["c_AssignmentTargetWithInitializer"]) {
            const typeName = S.TypeName.make("AssignmentTargetWithInitializer");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget"), TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_AssignmentTargetWithInitializer"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentTargetWithInitializer"] instanceof S.Iface);
        return this["c_AssignmentTargetWithInitializer"] as S.Iface;
    },
    get typeof_AssignmentTargetWithInitializer(): S.FieldType {
        const fieldName = this.AssignmentTargetWithInitializer.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ArrayAssignmentTarget(): S.Iface {
        if (!this["c_ArrayAssignmentTarget"]) {
            const typeName = S.TypeName.make("ArrayAssignmentTarget");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TOpt(TUnion([TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget"), TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget"), TNamed("AssignmentTargetWithInitializer")]))),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "rest",
                /* ty = */ TOpt(TUnion([TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget"), TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")])),
                /* isLazy = */ false),
            ];
            this["c_ArrayAssignmentTarget"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ArrayAssignmentTarget"] instanceof S.Iface);
        return this["c_ArrayAssignmentTarget"] as S.Iface;
    },
    get typeof_ArrayAssignmentTarget(): S.FieldType {
        const fieldName = this.ArrayAssignmentTarget.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssignmentTargetPropertyIdentifier(): S.Iface {
        if (!this["c_AssignmentTargetPropertyIdentifier"]) {
            const typeName = S.TypeName.make("AssignmentTargetPropertyIdentifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("AssignmentTargetIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            ];
            this["c_AssignmentTargetPropertyIdentifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentTargetPropertyIdentifier"] instanceof S.Iface);
        return this["c_AssignmentTargetPropertyIdentifier"] as S.Iface;
    },
    get typeof_AssignmentTargetPropertyIdentifier(): S.FieldType {
        const fieldName = this.AssignmentTargetPropertyIdentifier.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssignmentTargetPropertyProperty(): S.Iface {
        if (!this["c_AssignmentTargetPropertyProperty"]) {
            const typeName = S.TypeName.make("AssignmentTargetPropertyProperty");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget"), TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget"), TNamed("AssignmentTargetWithInitializer")]),
                /* isLazy = */ false),
            ];
            this["c_AssignmentTargetPropertyProperty"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentTargetPropertyProperty"] instanceof S.Iface);
        return this["c_AssignmentTargetPropertyProperty"] as S.Iface;
    },
    get typeof_AssignmentTargetPropertyProperty(): S.FieldType {
        const fieldName = this.AssignmentTargetPropertyProperty.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssignmentTargetProperty(): S.Typedef {
        if (!this["c_AssignmentTargetProperty"]) {
            const typeName = S.TypeName.make("AssignmentTargetProperty");
            const aliased = TUnion([TNamed("AssignmentTargetPropertyIdentifier"), TNamed("AssignmentTargetPropertyProperty")]);
            this["c_AssignmentTargetProperty"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_AssignmentTargetProperty"] instanceof S.Typedef);
        return this["c_AssignmentTargetProperty"] as S.Typedef;
    },
    get typeof_AssignmentTargetProperty(): S.FieldType {
        return this.AssignmentTargetProperty.aliased;
    },


    get ObjectAssignmentTarget(): S.Iface {
        if (!this["c_ObjectAssignmentTarget"]) {
            const typeName = S.TypeName.make("ObjectAssignmentTarget");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "properties",
                /* ty = */ TArray(TUnion([TNamed("AssignmentTargetPropertyIdentifier"), TNamed("AssignmentTargetPropertyProperty")])),
                /* isLazy = */ false),
            ];
            this["c_ObjectAssignmentTarget"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ObjectAssignmentTarget"] instanceof S.Iface);
        return this["c_ObjectAssignmentTarget"] as S.Iface;
    },
    get typeof_ObjectAssignmentTarget(): S.FieldType {
        const fieldName = this.ObjectAssignmentTarget.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ClassExpression(): S.Iface {
        if (!this["c_ClassExpression"]) {
            const typeName = S.TypeName.make("ClassExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TOpt(TNamed("BindingIdentifier")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "super",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TNamed("ClassElement")),
                /* isLazy = */ false),
            ];
            this["c_ClassExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ClassExpression"] instanceof S.Iface);
        return this["c_ClassExpression"] as S.Iface;
    },
    get typeof_ClassExpression(): S.FieldType {
        const fieldName = this.ClassExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ClassDeclaration(): S.Iface {
        if (!this["c_ClassDeclaration"]) {
            const typeName = S.TypeName.make("ClassDeclaration");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "super",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TNamed("ClassElement")),
                /* isLazy = */ false),
            ];
            this["c_ClassDeclaration"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ClassDeclaration"] instanceof S.Iface);
        return this["c_ClassDeclaration"] as S.Iface;
    },
    get typeof_ClassDeclaration(): S.FieldType {
        const fieldName = this.ClassDeclaration.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ClassElement(): S.Iface {
        if (!this["c_ClassElement"]) {
            const typeName = S.TypeName.make("ClassElement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isStatic",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "method",
                /* ty = */ TUnion([TNamed("EagerMethod"), TNamed("LazyMethod"), TNamed("EagerGetter"), TNamed("LazyGetter"), TNamed("EagerSetter"), TNamed("LazySetter")]),
                /* isLazy = */ false),
            ];
            this["c_ClassElement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ClassElement"] instanceof S.Iface);
        return this["c_ClassElement"] as S.Iface;
    },
    get typeof_ClassElement(): S.FieldType {
        const fieldName = this.ClassElement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get Module(): S.Iface {
        if (!this["c_Module"]) {
            const typeName = S.TypeName.make("Module");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "scope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "items",
                /* ty = */ TArray(TUnion([TNamed("ImportNamespace"), TNamed("Import"), TNamed("ExportAllFrom"), TNamed("ExportFrom"), TNamed("ExportLocals"), TNamed("ExportDefault"), TNamed("Export"), TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_Module"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Module"] instanceof S.Iface);
        return this["c_Module"] as S.Iface;
    },
    get typeof_Module(): S.FieldType {
        const fieldName = this.Module.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get Import(): S.Iface {
        if (!this["c_Import"]) {
            const typeName = S.TypeName.make("Import");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "moduleSpecifier",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "defaultBinding",
                /* ty = */ TOpt(TNamed("BindingIdentifier")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "namedImports",
                /* ty = */ TArray(TNamed("ImportSpecifier")),
                /* isLazy = */ false),
            ];
            this["c_Import"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Import"] instanceof S.Iface);
        return this["c_Import"] as S.Iface;
    },
    get typeof_Import(): S.FieldType {
        const fieldName = this.Import.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ImportNamespace(): S.Iface {
        if (!this["c_ImportNamespace"]) {
            const typeName = S.TypeName.make("ImportNamespace");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "moduleSpecifier",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "defaultBinding",
                /* ty = */ TOpt(TNamed("BindingIdentifier")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "namespaceBinding",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            ];
            this["c_ImportNamespace"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ImportNamespace"] instanceof S.Iface);
        return this["c_ImportNamespace"] as S.Iface;
    },
    get typeof_ImportNamespace(): S.FieldType {
        const fieldName = this.ImportNamespace.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ImportSpecifier(): S.Iface {
        if (!this["c_ImportSpecifier"]) {
            const typeName = S.TypeName.make("ImportSpecifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TOpt(TStr),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            ];
            this["c_ImportSpecifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ImportSpecifier"] instanceof S.Iface);
        return this["c_ImportSpecifier"] as S.Iface;
    },
    get typeof_ImportSpecifier(): S.FieldType {
        const fieldName = this.ImportSpecifier.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ExportAllFrom(): S.Iface {
        if (!this["c_ExportAllFrom"]) {
            const typeName = S.TypeName.make("ExportAllFrom");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "moduleSpecifier",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_ExportAllFrom"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportAllFrom"] instanceof S.Iface);
        return this["c_ExportAllFrom"] as S.Iface;
    },
    get typeof_ExportAllFrom(): S.FieldType {
        const fieldName = this.ExportAllFrom.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ExportFrom(): S.Iface {
        if (!this["c_ExportFrom"]) {
            const typeName = S.TypeName.make("ExportFrom");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "namedExports",
                /* ty = */ TArray(TNamed("ExportFromSpecifier")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "moduleSpecifier",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_ExportFrom"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportFrom"] instanceof S.Iface);
        return this["c_ExportFrom"] as S.Iface;
    },
    get typeof_ExportFrom(): S.FieldType {
        const fieldName = this.ExportFrom.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ExportLocals(): S.Iface {
        if (!this["c_ExportLocals"]) {
            const typeName = S.TypeName.make("ExportLocals");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "namedExports",
                /* ty = */ TArray(TNamed("ExportLocalSpecifier")),
                /* isLazy = */ false),
            ];
            this["c_ExportLocals"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportLocals"] instanceof S.Iface);
        return this["c_ExportLocals"] as S.Iface;
    },
    get typeof_ExportLocals(): S.FieldType {
        const fieldName = this.ExportLocals.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get Export(): S.Iface {
        if (!this["c_Export"]) {
            const typeName = S.TypeName.make("Export");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "declaration",
                /* ty = */ TUnion([TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("ClassDeclaration"), TNamed("VariableDeclaration")]),
                /* isLazy = */ false),
            ];
            this["c_Export"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Export"] instanceof S.Iface);
        return this["c_Export"] as S.Iface;
    },
    get typeof_Export(): S.FieldType {
        const fieldName = this.Export.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ExportDefault(): S.Iface {
        if (!this["c_ExportDefault"]) {
            const typeName = S.TypeName.make("ExportDefault");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("ClassDeclaration"), TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_ExportDefault"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportDefault"] instanceof S.Iface);
        return this["c_ExportDefault"] as S.Iface;
    },
    get typeof_ExportDefault(): S.FieldType {
        const fieldName = this.ExportDefault.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ExportFromSpecifier(): S.Iface {
        if (!this["c_ExportFromSpecifier"]) {
            const typeName = S.TypeName.make("ExportFromSpecifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "exportedName",
                /* ty = */ TOpt(TStr),
                /* isLazy = */ false),
            ];
            this["c_ExportFromSpecifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportFromSpecifier"] instanceof S.Iface);
        return this["c_ExportFromSpecifier"] as S.Iface;
    },
    get typeof_ExportFromSpecifier(): S.FieldType {
        const fieldName = this.ExportFromSpecifier.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ExportLocalSpecifier(): S.Iface {
        if (!this["c_ExportLocalSpecifier"]) {
            const typeName = S.TypeName.make("ExportLocalSpecifier");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("IdentifierExpression"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "exportedName",
                /* ty = */ TOpt(TStr),
                /* isLazy = */ false),
            ];
            this["c_ExportLocalSpecifier"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExportLocalSpecifier"] instanceof S.Iface);
        return this["c_ExportLocalSpecifier"] as S.Iface;
    },
    get typeof_ExportLocalSpecifier(): S.FieldType {
        const fieldName = this.ExportLocalSpecifier.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get EagerMethod(): S.Iface {
        if (!this["c_EagerMethod"]) {
            const typeName = S.TypeName.make("EagerMethod");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionOrMethodContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerMethod"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerMethod"] instanceof S.Iface);
        return this["c_EagerMethod"] as S.Iface;
    },
    get typeof_EagerMethod(): S.FieldType {
        const fieldName = this.EagerMethod.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LazyMethod(): S.Iface {
        if (!this["c_LazyMethod"]) {
            const typeName = S.TypeName.make("LazyMethod");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionOrMethodContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyMethod"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyMethod"] instanceof S.Iface);
        return this["c_LazyMethod"] as S.Iface;
    },
    get typeof_LazyMethod(): S.FieldType {
        const fieldName = this.LazyMethod.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get EagerGetter(): S.Iface {
        if (!this["c_EagerGetter"]) {
            const typeName = S.TypeName.make("EagerGetter");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("GetterContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerGetter"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerGetter"] instanceof S.Iface);
        return this["c_EagerGetter"] as S.Iface;
    },
    get typeof_EagerGetter(): S.FieldType {
        const fieldName = this.EagerGetter.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LazyGetter(): S.Iface {
        if (!this["c_LazyGetter"]) {
            const typeName = S.TypeName.make("LazyGetter");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("GetterContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyGetter"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyGetter"] instanceof S.Iface);
        return this["c_LazyGetter"] as S.Iface;
    },
    get typeof_LazyGetter(): S.FieldType {
        const fieldName = this.LazyGetter.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get GetterContents(): S.Iface {
        if (!this["c_GetterContents"]) {
            const typeName = S.TypeName.make("GetterContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isThisCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_GetterContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_GetterContents"] instanceof S.Iface);
        return this["c_GetterContents"] as S.Iface;
    },
    get typeof_GetterContents(): S.FieldType {
        const fieldName = this.GetterContents.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get EagerSetter(): S.Iface {
        if (!this["c_EagerSetter"]) {
            const typeName = S.TypeName.make("EagerSetter");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("SetterContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerSetter"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerSetter"] instanceof S.Iface);
        return this["c_EagerSetter"] as S.Iface;
    },
    get typeof_EagerSetter(): S.FieldType {
        const fieldName = this.EagerSetter.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LazySetter(): S.Iface {
        if (!this["c_LazySetter"]) {
            const typeName = S.TypeName.make("LazySetter");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("SetterContents"),
                /* isLazy = */ false),
            ];
            this["c_LazySetter"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazySetter"] instanceof S.Iface);
        return this["c_LazySetter"] as S.Iface;
    },
    get typeof_LazySetter(): S.FieldType {
        const fieldName = this.LazySetter.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get SetterContents(): S.Iface {
        if (!this["c_SetterContents"]) {
            const typeName = S.TypeName.make("SetterContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isThisCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "parameterScope",
                /* ty = */ TNamed("AssertedParameterScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "param",
                /* ty = */ TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier"), TNamed("BindingWithInitializer")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_SetterContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SetterContents"] instanceof S.Iface);
        return this["c_SetterContents"] as S.Iface;
    },
    get typeof_SetterContents(): S.FieldType {
        const fieldName = this.SetterContents.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get DataProperty(): S.Iface {
        if (!this["c_DataProperty"]) {
            const typeName = S.TypeName.make("DataProperty");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TUnion([TNamed("ComputedPropertyName"), TNamed("LiteralPropertyName")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_DataProperty"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_DataProperty"] instanceof S.Iface);
        return this["c_DataProperty"] as S.Iface;
    },
    get typeof_DataProperty(): S.FieldType {
        const fieldName = this.DataProperty.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ShorthandProperty(): S.Iface {
        if (!this["c_ShorthandProperty"]) {
            const typeName = S.TypeName.make("ShorthandProperty");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("IdentifierExpression"),
                /* isLazy = */ false),
            ];
            this["c_ShorthandProperty"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ShorthandProperty"] instanceof S.Iface);
        return this["c_ShorthandProperty"] as S.Iface;
    },
    get typeof_ShorthandProperty(): S.FieldType {
        const fieldName = this.ShorthandProperty.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ComputedPropertyName(): S.Iface {
        if (!this["c_ComputedPropertyName"]) {
            const typeName = S.TypeName.make("ComputedPropertyName");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_ComputedPropertyName"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ComputedPropertyName"] instanceof S.Iface);
        return this["c_ComputedPropertyName"] as S.Iface;
    },
    get typeof_ComputedPropertyName(): S.FieldType {
        const fieldName = this.ComputedPropertyName.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LiteralPropertyName(): S.Iface {
        if (!this["c_LiteralPropertyName"]) {
            const typeName = S.TypeName.make("LiteralPropertyName");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "value",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_LiteralPropertyName"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralPropertyName"] instanceof S.Iface);
        return this["c_LiteralPropertyName"] as S.Iface;
    },
    get typeof_LiteralPropertyName(): S.FieldType {
        const fieldName = this.LiteralPropertyName.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LiteralBooleanExpression(): S.Iface {
        if (!this["c_LiteralBooleanExpression"]) {
            const typeName = S.TypeName.make("LiteralBooleanExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "value",
                /* ty = */ TBool,
                /* isLazy = */ false),
            ];
            this["c_LiteralBooleanExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralBooleanExpression"] instanceof S.Iface);
        return this["c_LiteralBooleanExpression"] as S.Iface;
    },
    get typeof_LiteralBooleanExpression(): S.FieldType {
        const fieldName = this.LiteralBooleanExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LiteralInfinityExpression(): S.Iface {
        if (!this["c_LiteralInfinityExpression"]) {
            const typeName = S.TypeName.make("LiteralInfinityExpression");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_LiteralInfinityExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralInfinityExpression"] instanceof S.Iface);
        return this["c_LiteralInfinityExpression"] as S.Iface;
    },
    get typeof_LiteralInfinityExpression(): S.FieldType {
        const fieldName = this.LiteralInfinityExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LiteralNullExpression(): S.Iface {
        if (!this["c_LiteralNullExpression"]) {
            const typeName = S.TypeName.make("LiteralNullExpression");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_LiteralNullExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralNullExpression"] instanceof S.Iface);
        return this["c_LiteralNullExpression"] as S.Iface;
    },
    get typeof_LiteralNullExpression(): S.FieldType {
        const fieldName = this.LiteralNullExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LiteralNumericExpression(): S.Iface {
        if (!this["c_LiteralNumericExpression"]) {
            const typeName = S.TypeName.make("LiteralNumericExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "value",
                /* ty = */ TF64,
                /* isLazy = */ false),
            ];
            this["c_LiteralNumericExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralNumericExpression"] instanceof S.Iface);
        return this["c_LiteralNumericExpression"] as S.Iface;
    },
    get typeof_LiteralNumericExpression(): S.FieldType {
        const fieldName = this.LiteralNumericExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LiteralRegExpExpression(): S.Iface {
        if (!this["c_LiteralRegExpExpression"]) {
            const typeName = S.TypeName.make("LiteralRegExpExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "pattern",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "flags",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_LiteralRegExpExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralRegExpExpression"] instanceof S.Iface);
        return this["c_LiteralRegExpExpression"] as S.Iface;
    },
    get typeof_LiteralRegExpExpression(): S.FieldType {
        const fieldName = this.LiteralRegExpExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LiteralStringExpression(): S.Iface {
        if (!this["c_LiteralStringExpression"]) {
            const typeName = S.TypeName.make("LiteralStringExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "value",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_LiteralStringExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LiteralStringExpression"] instanceof S.Iface);
        return this["c_LiteralStringExpression"] as S.Iface;
    },
    get typeof_LiteralStringExpression(): S.FieldType {
        const fieldName = this.LiteralStringExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ArrayExpression(): S.Iface {
        if (!this["c_ArrayExpression"]) {
            const typeName = S.TypeName.make("ArrayExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TOpt(TUnion([TNamed("SpreadElement"), TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]))),
                /* isLazy = */ false),
            ];
            this["c_ArrayExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ArrayExpression"] instanceof S.Iface);
        return this["c_ArrayExpression"] as S.Iface;
    },
    get typeof_ArrayExpression(): S.FieldType {
        const fieldName = this.ArrayExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get EagerArrowExpression(): S.Iface {
        if (!this["c_EagerArrowExpression"]) {
            const typeName = S.TypeName.make("EagerArrowExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TOpt(TArray(TNamed("Directive"))),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("ArrowExpressionContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerArrowExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerArrowExpression"] instanceof S.Iface);
        return this["c_EagerArrowExpression"] as S.Iface;
    },
    get typeof_EagerArrowExpression(): S.FieldType {
        const fieldName = this.EagerArrowExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LazyArrowExpression(): S.Iface {
        if (!this["c_LazyArrowExpression"]) {
            const typeName = S.TypeName.make("LazyArrowExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TOpt(TArray(TNamed("Directive"))),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("ArrowExpressionContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyArrowExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyArrowExpression"] instanceof S.Iface);
        return this["c_LazyArrowExpression"] as S.Iface;
    },
    get typeof_LazyArrowExpression(): S.FieldType {
        const fieldName = this.LazyArrowExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ArrowExpressionContents(): S.Iface {
        if (!this["c_ArrowExpressionContents"]) {
            const typeName = S.TypeName.make("ArrowExpressionContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "parameterScope",
                /* ty = */ TNamed("AssertedParameterScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "params",
                /* ty = */ TNamed("FormalParameters"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])), TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_ArrowExpressionContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ArrowExpressionContents"] instanceof S.Iface);
        return this["c_ArrowExpressionContents"] as S.Iface;
    },
    get typeof_ArrowExpressionContents(): S.FieldType {
        const fieldName = this.ArrowExpressionContents.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AssignmentExpression(): S.Iface {
        if (!this["c_AssignmentExpression"]) {
            const typeName = S.TypeName.make("AssignmentExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget"), TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_AssignmentExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AssignmentExpression"] instanceof S.Iface);
        return this["c_AssignmentExpression"] as S.Iface;
    },
    get typeof_AssignmentExpression(): S.FieldType {
        const fieldName = this.AssignmentExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get BinaryExpression(): S.Iface {
        if (!this["c_BinaryExpression"]) {
            const typeName = S.TypeName.make("BinaryExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "operator",
                /* ty = */ TNamed("BinaryOperator"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "left",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "right",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_BinaryExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BinaryExpression"] instanceof S.Iface);
        return this["c_BinaryExpression"] as S.Iface;
    },
    get typeof_BinaryExpression(): S.FieldType {
        const fieldName = this.BinaryExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get CallExpression(): S.Iface {
        if (!this["c_CallExpression"]) {
            const typeName = S.TypeName.make("CallExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "callee",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "arguments",
                /* ty = */ TArray(TUnion([TNamed("SpreadElement"), TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            ];
            this["c_CallExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_CallExpression"] instanceof S.Iface);
        return this["c_CallExpression"] as S.Iface;
    },
    get typeof_CallExpression(): S.FieldType {
        const fieldName = this.CallExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get CompoundAssignmentExpression(): S.Iface {
        if (!this["c_CompoundAssignmentExpression"]) {
            const typeName = S.TypeName.make("CompoundAssignmentExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "operator",
                /* ty = */ TNamed("CompoundAssignmentOperator"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_CompoundAssignmentExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_CompoundAssignmentExpression"] instanceof S.Iface);
        return this["c_CompoundAssignmentExpression"] as S.Iface;
    },
    get typeof_CompoundAssignmentExpression(): S.FieldType {
        const fieldName = this.CompoundAssignmentExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ComputedMemberExpression(): S.Iface {
        if (!this["c_ComputedMemberExpression"]) {
            const typeName = S.TypeName.make("ComputedMemberExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_ComputedMemberExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ComputedMemberExpression"] instanceof S.Iface);
        return this["c_ComputedMemberExpression"] as S.Iface;
    },
    get typeof_ComputedMemberExpression(): S.FieldType {
        const fieldName = this.ComputedMemberExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ConditionalExpression(): S.Iface {
        if (!this["c_ConditionalExpression"]) {
            const typeName = S.TypeName.make("ConditionalExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "consequent",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "alternate",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_ConditionalExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ConditionalExpression"] instanceof S.Iface);
        return this["c_ConditionalExpression"] as S.Iface;
    },
    get typeof_ConditionalExpression(): S.FieldType {
        const fieldName = this.ConditionalExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get EagerFunctionExpression(): S.Iface {
        if (!this["c_EagerFunctionExpression"]) {
            const typeName = S.TypeName.make("EagerFunctionExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TOpt(TNamed("BindingIdentifier")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionExpressionContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerFunctionExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerFunctionExpression"] instanceof S.Iface);
        return this["c_EagerFunctionExpression"] as S.Iface;
    },
    get typeof_EagerFunctionExpression(): S.FieldType {
        const fieldName = this.EagerFunctionExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LazyFunctionExpression(): S.Iface {
        if (!this["c_LazyFunctionExpression"]) {
            const typeName = S.TypeName.make("LazyFunctionExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TOpt(TNamed("BindingIdentifier")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionExpressionContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyFunctionExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyFunctionExpression"] instanceof S.Iface);
        return this["c_LazyFunctionExpression"] as S.Iface;
    },
    get typeof_LazyFunctionExpression(): S.FieldType {
        const fieldName = this.LazyFunctionExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get FunctionExpressionContents(): S.Iface {
        if (!this["c_FunctionExpressionContents"]) {
            const typeName = S.TypeName.make("FunctionExpressionContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isFunctionNameCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isThisCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "parameterScope",
                /* ty = */ TNamed("AssertedParameterScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "params",
                /* ty = */ TNamed("FormalParameters"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_FunctionExpressionContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_FunctionExpressionContents"] instanceof S.Iface);
        return this["c_FunctionExpressionContents"] as S.Iface;
    },
    get typeof_FunctionExpressionContents(): S.FieldType {
        const fieldName = this.FunctionExpressionContents.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get IdentifierExpression(): S.Iface {
        if (!this["c_IdentifierExpression"]) {
            const typeName = S.TypeName.make("IdentifierExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_IdentifierExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_IdentifierExpression"] instanceof S.Iface);
        return this["c_IdentifierExpression"] as S.Iface;
    },
    get typeof_IdentifierExpression(): S.FieldType {
        const fieldName = this.IdentifierExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get NewExpression(): S.Iface {
        if (!this["c_NewExpression"]) {
            const typeName = S.TypeName.make("NewExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "callee",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "arguments",
                /* ty = */ TArray(TUnion([TNamed("SpreadElement"), TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            ];
            this["c_NewExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_NewExpression"] instanceof S.Iface);
        return this["c_NewExpression"] as S.Iface;
    },
    get typeof_NewExpression(): S.FieldType {
        const fieldName = this.NewExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get NewTargetExpression(): S.Iface {
        if (!this["c_NewTargetExpression"]) {
            const typeName = S.TypeName.make("NewTargetExpression");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_NewTargetExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_NewTargetExpression"] instanceof S.Iface);
        return this["c_NewTargetExpression"] as S.Iface;
    },
    get typeof_NewTargetExpression(): S.FieldType {
        const fieldName = this.NewTargetExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ObjectExpression(): S.Iface {
        if (!this["c_ObjectExpression"]) {
            const typeName = S.TypeName.make("ObjectExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "properties",
                /* ty = */ TArray(TUnion([TNamed("EagerMethod"), TNamed("LazyMethod"), TNamed("EagerGetter"), TNamed("LazyGetter"), TNamed("EagerSetter"), TNamed("LazySetter"), TNamed("DataProperty"), TNamed("ShorthandProperty")])),
                /* isLazy = */ false),
            ];
            this["c_ObjectExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ObjectExpression"] instanceof S.Iface);
        return this["c_ObjectExpression"] as S.Iface;
    },
    get typeof_ObjectExpression(): S.FieldType {
        const fieldName = this.ObjectExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get UnaryExpression(): S.Iface {
        if (!this["c_UnaryExpression"]) {
            const typeName = S.TypeName.make("UnaryExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "operator",
                /* ty = */ TNamed("UnaryOperator"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "operand",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_UnaryExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_UnaryExpression"] instanceof S.Iface);
        return this["c_UnaryExpression"] as S.Iface;
    },
    get typeof_UnaryExpression(): S.FieldType {
        const fieldName = this.UnaryExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get StaticMemberExpression(): S.Iface {
        if (!this["c_StaticMemberExpression"]) {
            const typeName = S.TypeName.make("StaticMemberExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression"), TNamed("Super")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "property",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_StaticMemberExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_StaticMemberExpression"] instanceof S.Iface);
        return this["c_StaticMemberExpression"] as S.Iface;
    },
    get typeof_StaticMemberExpression(): S.FieldType {
        const fieldName = this.StaticMemberExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get TemplateExpression(): S.Iface {
        if (!this["c_TemplateExpression"]) {
            const typeName = S.TypeName.make("TemplateExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "tag",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "elements",
                /* ty = */ TArray(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression"), TNamed("TemplateElement")])),
                /* isLazy = */ false),
            ];
            this["c_TemplateExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_TemplateExpression"] instanceof S.Iface);
        return this["c_TemplateExpression"] as S.Iface;
    },
    get typeof_TemplateExpression(): S.FieldType {
        const fieldName = this.TemplateExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ThisExpression(): S.Iface {
        if (!this["c_ThisExpression"]) {
            const typeName = S.TypeName.make("ThisExpression");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_ThisExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ThisExpression"] instanceof S.Iface);
        return this["c_ThisExpression"] as S.Iface;
    },
    get typeof_ThisExpression(): S.FieldType {
        const fieldName = this.ThisExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get UpdateExpression(): S.Iface {
        if (!this["c_UpdateExpression"]) {
            const typeName = S.TypeName.make("UpdateExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isPrefix",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "operator",
                /* ty = */ TNamed("UpdateOperator"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "operand",
                /* ty = */ TUnion([TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")]),
                /* isLazy = */ false),
            ];
            this["c_UpdateExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_UpdateExpression"] instanceof S.Iface);
        return this["c_UpdateExpression"] as S.Iface;
    },
    get typeof_UpdateExpression(): S.FieldType {
        const fieldName = this.UpdateExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get YieldExpression(): S.Iface {
        if (!this["c_YieldExpression"]) {
            const typeName = S.TypeName.make("YieldExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            ];
            this["c_YieldExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_YieldExpression"] instanceof S.Iface);
        return this["c_YieldExpression"] as S.Iface;
    },
    get typeof_YieldExpression(): S.FieldType {
        const fieldName = this.YieldExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get YieldStarExpression(): S.Iface {
        if (!this["c_YieldStarExpression"]) {
            const typeName = S.TypeName.make("YieldStarExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_YieldStarExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_YieldStarExpression"] instanceof S.Iface);
        return this["c_YieldStarExpression"] as S.Iface;
    },
    get typeof_YieldStarExpression(): S.FieldType {
        const fieldName = this.YieldStarExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get AwaitExpression(): S.Iface {
        if (!this["c_AwaitExpression"]) {
            const typeName = S.TypeName.make("AwaitExpression");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_AwaitExpression"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_AwaitExpression"] instanceof S.Iface);
        return this["c_AwaitExpression"] as S.Iface;
    },
    get typeof_AwaitExpression(): S.FieldType {
        const fieldName = this.AwaitExpression.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get BreakStatement(): S.Iface {
        if (!this["c_BreakStatement"]) {
            const typeName = S.TypeName.make("BreakStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "label",
                /* ty = */ TOpt(TStr),
                /* isLazy = */ false),
            ];
            this["c_BreakStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_BreakStatement"] instanceof S.Iface);
        return this["c_BreakStatement"] as S.Iface;
    },
    get typeof_BreakStatement(): S.FieldType {
        const fieldName = this.BreakStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ContinueStatement(): S.Iface {
        if (!this["c_ContinueStatement"]) {
            const typeName = S.TypeName.make("ContinueStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "label",
                /* ty = */ TOpt(TStr),
                /* isLazy = */ false),
            ];
            this["c_ContinueStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ContinueStatement"] instanceof S.Iface);
        return this["c_ContinueStatement"] as S.Iface;
    },
    get typeof_ContinueStatement(): S.FieldType {
        const fieldName = this.ContinueStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get DebuggerStatement(): S.Iface {
        if (!this["c_DebuggerStatement"]) {
            const typeName = S.TypeName.make("DebuggerStatement");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_DebuggerStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_DebuggerStatement"] instanceof S.Iface);
        return this["c_DebuggerStatement"] as S.Iface;
    },
    get typeof_DebuggerStatement(): S.FieldType {
        const fieldName = this.DebuggerStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get DoWhileStatement(): S.Iface {
        if (!this["c_DoWhileStatement"]) {
            const typeName = S.TypeName.make("DoWhileStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]),
                /* isLazy = */ false),
            ];
            this["c_DoWhileStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_DoWhileStatement"] instanceof S.Iface);
        return this["c_DoWhileStatement"] as S.Iface;
    },
    get typeof_DoWhileStatement(): S.FieldType {
        const fieldName = this.DoWhileStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get EmptyStatement(): S.Iface {
        if (!this["c_EmptyStatement"]) {
            const typeName = S.TypeName.make("EmptyStatement");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_EmptyStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EmptyStatement"] instanceof S.Iface);
        return this["c_EmptyStatement"] as S.Iface;
    },
    get typeof_EmptyStatement(): S.FieldType {
        const fieldName = this.EmptyStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ExpressionStatement(): S.Iface {
        if (!this["c_ExpressionStatement"]) {
            const typeName = S.TypeName.make("ExpressionStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_ExpressionStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ExpressionStatement"] instanceof S.Iface);
        return this["c_ExpressionStatement"] as S.Iface;
    },
    get typeof_ExpressionStatement(): S.FieldType {
        const fieldName = this.ExpressionStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ForInOfBinding(): S.Iface {
        if (!this["c_ForInOfBinding"]) {
            const typeName = S.TypeName.make("ForInOfBinding");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "kind",
                /* ty = */ TNamed("VariableDeclarationKind"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier")]),
                /* isLazy = */ false),
            ];
            this["c_ForInOfBinding"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ForInOfBinding"] instanceof S.Iface);
        return this["c_ForInOfBinding"] as S.Iface;
    },
    get typeof_ForInOfBinding(): S.FieldType {
        const fieldName = this.ForInOfBinding.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ForInStatement(): S.Iface {
        if (!this["c_ForInStatement"]) {
            const typeName = S.TypeName.make("ForInStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "left",
                /* ty = */ TUnion([TNamed("ForInOfBinding"), TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget"), TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "right",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]),
                /* isLazy = */ false),
            ];
            this["c_ForInStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ForInStatement"] instanceof S.Iface);
        return this["c_ForInStatement"] as S.Iface;
    },
    get typeof_ForInStatement(): S.FieldType {
        const fieldName = this.ForInStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ForOfStatement(): S.Iface {
        if (!this["c_ForOfStatement"]) {
            const typeName = S.TypeName.make("ForOfStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "left",
                /* ty = */ TUnion([TNamed("ForInOfBinding"), TNamed("ObjectAssignmentTarget"), TNamed("ArrayAssignmentTarget"), TNamed("AssignmentTargetIdentifier"), TNamed("ComputedMemberAssignmentTarget"), TNamed("StaticMemberAssignmentTarget")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "right",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]),
                /* isLazy = */ false),
            ];
            this["c_ForOfStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ForOfStatement"] instanceof S.Iface);
        return this["c_ForOfStatement"] as S.Iface;
    },
    get typeof_ForOfStatement(): S.FieldType {
        const fieldName = this.ForOfStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ForStatement(): S.Iface {
        if (!this["c_ForStatement"]) {
            const typeName = S.TypeName.make("ForStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TOpt(TUnion([TNamed("VariableDeclaration"), TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "update",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]),
                /* isLazy = */ false),
            ];
            this["c_ForStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ForStatement"] instanceof S.Iface);
        return this["c_ForStatement"] as S.Iface;
    },
    get typeof_ForStatement(): S.FieldType {
        const fieldName = this.ForStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get IfStatement(): S.Iface {
        if (!this["c_IfStatement"]) {
            const typeName = S.TypeName.make("IfStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "consequent",
                /* ty = */ TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "alternate",
                /* ty = */ TOpt(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_IfStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_IfStatement"] instanceof S.Iface);
        return this["c_IfStatement"] as S.Iface;
    },
    get typeof_IfStatement(): S.FieldType {
        const fieldName = this.IfStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LabelledStatement(): S.Iface {
        if (!this["c_LabelledStatement"]) {
            const typeName = S.TypeName.make("LabelledStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "label",
                /* ty = */ TStr,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]),
                /* isLazy = */ false),
            ];
            this["c_LabelledStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LabelledStatement"] instanceof S.Iface);
        return this["c_LabelledStatement"] as S.Iface;
    },
    get typeof_LabelledStatement(): S.FieldType {
        const fieldName = this.LabelledStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ReturnStatement(): S.Iface {
        if (!this["c_ReturnStatement"]) {
            const typeName = S.TypeName.make("ReturnStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            ];
            this["c_ReturnStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ReturnStatement"] instanceof S.Iface);
        return this["c_ReturnStatement"] as S.Iface;
    },
    get typeof_ReturnStatement(): S.FieldType {
        const fieldName = this.ReturnStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get SwitchStatement(): S.Iface {
        if (!this["c_SwitchStatement"]) {
            const typeName = S.TypeName.make("SwitchStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "discriminant",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "cases",
                /* ty = */ TArray(TNamed("SwitchCase")),
                /* isLazy = */ false),
            ];
            this["c_SwitchStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SwitchStatement"] instanceof S.Iface);
        return this["c_SwitchStatement"] as S.Iface;
    },
    get typeof_SwitchStatement(): S.FieldType {
        const fieldName = this.SwitchStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get SwitchStatementWithDefault(): S.Iface {
        if (!this["c_SwitchStatementWithDefault"]) {
            const typeName = S.TypeName.make("SwitchStatementWithDefault");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "discriminant",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "preDefaultCases",
                /* ty = */ TArray(TNamed("SwitchCase")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "defaultCase",
                /* ty = */ TNamed("SwitchDefault"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "postDefaultCases",
                /* ty = */ TArray(TNamed("SwitchCase")),
                /* isLazy = */ false),
            ];
            this["c_SwitchStatementWithDefault"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SwitchStatementWithDefault"] instanceof S.Iface);
        return this["c_SwitchStatementWithDefault"] as S.Iface;
    },
    get typeof_SwitchStatementWithDefault(): S.FieldType {
        const fieldName = this.SwitchStatementWithDefault.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get ThrowStatement(): S.Iface {
        if (!this["c_ThrowStatement"]) {
            const typeName = S.TypeName.make("ThrowStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_ThrowStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_ThrowStatement"] instanceof S.Iface);
        return this["c_ThrowStatement"] as S.Iface;
    },
    get typeof_ThrowStatement(): S.FieldType {
        const fieldName = this.ThrowStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get TryCatchStatement(): S.Iface {
        if (!this["c_TryCatchStatement"]) {
            const typeName = S.TypeName.make("TryCatchStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Block"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "catchClause",
                /* ty = */ TNamed("CatchClause"),
                /* isLazy = */ false),
            ];
            this["c_TryCatchStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_TryCatchStatement"] instanceof S.Iface);
        return this["c_TryCatchStatement"] as S.Iface;
    },
    get typeof_TryCatchStatement(): S.FieldType {
        const fieldName = this.TryCatchStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get TryFinallyStatement(): S.Iface {
        if (!this["c_TryFinallyStatement"]) {
            const typeName = S.TypeName.make("TryFinallyStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Block"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "catchClause",
                /* ty = */ TOpt(TNamed("CatchClause")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "finalizer",
                /* ty = */ TNamed("Block"),
                /* isLazy = */ false),
            ];
            this["c_TryFinallyStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_TryFinallyStatement"] instanceof S.Iface);
        return this["c_TryFinallyStatement"] as S.Iface;
    },
    get typeof_TryFinallyStatement(): S.FieldType {
        const fieldName = this.TryFinallyStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get WhileStatement(): S.Iface {
        if (!this["c_WhileStatement"]) {
            const typeName = S.TypeName.make("WhileStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]),
                /* isLazy = */ false),
            ];
            this["c_WhileStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_WhileStatement"] instanceof S.Iface);
        return this["c_WhileStatement"] as S.Iface;
    },
    get typeof_WhileStatement(): S.FieldType {
        const fieldName = this.WhileStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get WithStatement(): S.Iface {
        if (!this["c_WithStatement"]) {
            const typeName = S.TypeName.make("WithStatement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "object",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]),
                /* isLazy = */ false),
            ];
            this["c_WithStatement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_WithStatement"] instanceof S.Iface);
        return this["c_WithStatement"] as S.Iface;
    },
    get typeof_WithStatement(): S.FieldType {
        const fieldName = this.WithStatement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get Block(): S.Iface {
        if (!this["c_Block"]) {
            const typeName = S.TypeName.make("Block");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "scope",
                /* ty = */ TNamed("AssertedBlockScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "statements",
                /* ty = */ TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_Block"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Block"] instanceof S.Iface);
        return this["c_Block"] as S.Iface;
    },
    get typeof_Block(): S.FieldType {
        const fieldName = this.Block.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get CatchClause(): S.Iface {
        if (!this["c_CatchClause"]) {
            const typeName = S.TypeName.make("CatchClause");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "bindingScope",
                /* ty = */ TNamed("AssertedBoundNamesScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TNamed("Block"),
                /* isLazy = */ false),
            ];
            this["c_CatchClause"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_CatchClause"] instanceof S.Iface);
        return this["c_CatchClause"] as S.Iface;
    },
    get typeof_CatchClause(): S.FieldType {
        const fieldName = this.CatchClause.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get Directive(): S.Iface {
        if (!this["c_Directive"]) {
            const typeName = S.TypeName.make("Directive");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "rawValue",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_Directive"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Directive"] instanceof S.Iface);
        return this["c_Directive"] as S.Iface;
    },
    get typeof_Directive(): S.FieldType {
        const fieldName = this.Directive.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get FormalParameters(): S.Iface {
        if (!this["c_FormalParameters"]) {
            const typeName = S.TypeName.make("FormalParameters");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "items",
                /* ty = */ TArray(TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier"), TNamed("BindingWithInitializer")])),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "rest",
                /* ty = */ TOpt(TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier")])),
                /* isLazy = */ false),
            ];
            this["c_FormalParameters"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_FormalParameters"] instanceof S.Iface);
        return this["c_FormalParameters"] as S.Iface;
    },
    get typeof_FormalParameters(): S.FieldType {
        const fieldName = this.FormalParameters.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get FunctionBody(): S.Typedef {
        if (!this["c_FunctionBody"]) {
            const typeName = S.TypeName.make("FunctionBody");
            const aliased = TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")]));
            this["c_FunctionBody"] = new S.Typedef(
                               typeName, aliased)
        }
        assert(this["c_FunctionBody"] instanceof S.Typedef);
        return this["c_FunctionBody"] as S.Typedef;
    },
    get typeof_FunctionBody(): S.FieldType {
        return this.FunctionBody.aliased;
    },


    get EagerFunctionDeclaration(): S.Iface {
        if (!this["c_EagerFunctionDeclaration"]) {
            const typeName = S.TypeName.make("EagerFunctionDeclaration");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "contents",
                /* ty = */ TNamed("FunctionOrMethodContents"),
                /* isLazy = */ false),
            ];
            this["c_EagerFunctionDeclaration"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_EagerFunctionDeclaration"] instanceof S.Iface);
        return this["c_EagerFunctionDeclaration"] as S.Iface;
    },
    get typeof_EagerFunctionDeclaration(): S.FieldType {
        const fieldName = this.EagerFunctionDeclaration.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get LazyFunctionDeclaration(): S.Iface {
        if (!this["c_LazyFunctionDeclaration"]) {
            const typeName = S.TypeName.make("LazyFunctionDeclaration");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isAsync",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "isGenerator",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "name",
                /* ty = */ TNamed("BindingIdentifier"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "content",
                /* ty = */ TNamed("FunctionOrMethodContents"),
                /* isLazy = */ false),
            ];
            this["c_LazyFunctionDeclaration"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_LazyFunctionDeclaration"] instanceof S.Iface);
        return this["c_LazyFunctionDeclaration"] as S.Iface;
    },
    get typeof_LazyFunctionDeclaration(): S.FieldType {
        const fieldName = this.LazyFunctionDeclaration.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get FunctionOrMethodContents(): S.Iface {
        if (!this["c_FunctionOrMethodContents"]) {
            const typeName = S.TypeName.make("FunctionOrMethodContents");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "isThisCaptured",
                /* ty = */ TBool,
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "parameterScope",
                /* ty = */ TNamed("AssertedParameterScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "params",
                /* ty = */ TNamed("FormalParameters"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "bodyScope",
                /* ty = */ TNamed("AssertedVarScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "body",
                /* ty = */ TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_FunctionOrMethodContents"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_FunctionOrMethodContents"] instanceof S.Iface);
        return this["c_FunctionOrMethodContents"] as S.Iface;
    },
    get typeof_FunctionOrMethodContents(): S.FieldType {
        const fieldName = this.FunctionOrMethodContents.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get Script(): S.Iface {
        if (!this["c_Script"]) {
            const typeName = S.TypeName.make("Script");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "scope",
                /* ty = */ TNamed("AssertedScriptGlobalScope"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "directives",
                /* ty = */ TArray(TNamed("Directive")),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "statements",
                /* ty = */ TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_Script"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Script"] instanceof S.Iface);
        return this["c_Script"] as S.Iface;
    },
    get typeof_Script(): S.FieldType {
        const fieldName = this.Script.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get SpreadElement(): S.Iface {
        if (!this["c_SpreadElement"]) {
            const typeName = S.TypeName.make("SpreadElement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "expression",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            ];
            this["c_SpreadElement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SpreadElement"] instanceof S.Iface);
        return this["c_SpreadElement"] as S.Iface;
    },
    get typeof_SpreadElement(): S.FieldType {
        const fieldName = this.SpreadElement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get Super(): S.Iface {
        if (!this["c_Super"]) {
            const typeName = S.TypeName.make("Super");
            const fields: Array<S.IfaceField> = [
            ];
            this["c_Super"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_Super"] instanceof S.Iface);
        return this["c_Super"] as S.Iface;
    },
    get typeof_Super(): S.FieldType {
        const fieldName = this.Super.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get SwitchCase(): S.Iface {
        if (!this["c_SwitchCase"]) {
            const typeName = S.TypeName.make("SwitchCase");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "test",
                /* ty = */ TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "consequent",
                /* ty = */ TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_SwitchCase"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SwitchCase"] instanceof S.Iface);
        return this["c_SwitchCase"] as S.Iface;
    },
    get typeof_SwitchCase(): S.FieldType {
        const fieldName = this.SwitchCase.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get SwitchDefault(): S.Iface {
        if (!this["c_SwitchDefault"]) {
            const typeName = S.TypeName.make("SwitchDefault");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "consequent",
                /* ty = */ TArray(TUnion([TNamed("Block"), TNamed("BreakStatement"), TNamed("ContinueStatement"), TNamed("ClassDeclaration"), TNamed("DebuggerStatement"), TNamed("EmptyStatement"), TNamed("ExpressionStatement"), TNamed("EagerFunctionDeclaration"), TNamed("LazyFunctionDeclaration"), TNamed("IfStatement"), TNamed("DoWhileStatement"), TNamed("ForInStatement"), TNamed("ForOfStatement"), TNamed("ForStatement"), TNamed("WhileStatement"), TNamed("LabelledStatement"), TNamed("ReturnStatement"), TNamed("SwitchStatement"), TNamed("SwitchStatementWithDefault"), TNamed("ThrowStatement"), TNamed("TryCatchStatement"), TNamed("TryFinallyStatement"), TNamed("VariableDeclaration"), TNamed("WithStatement")])),
                /* isLazy = */ false),
            ];
            this["c_SwitchDefault"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_SwitchDefault"] instanceof S.Iface);
        return this["c_SwitchDefault"] as S.Iface;
    },
    get typeof_SwitchDefault(): S.FieldType {
        const fieldName = this.SwitchDefault.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get TemplateElement(): S.Iface {
        if (!this["c_TemplateElement"]) {
            const typeName = S.TypeName.make("TemplateElement");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "rawValue",
                /* ty = */ TStr,
                /* isLazy = */ false),
            ];
            this["c_TemplateElement"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_TemplateElement"] instanceof S.Iface);
        return this["c_TemplateElement"] as S.Iface;
    },
    get typeof_TemplateElement(): S.FieldType {
        const fieldName = this.TemplateElement.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get VariableDeclaration(): S.Iface {
        if (!this["c_VariableDeclaration"]) {
            const typeName = S.TypeName.make("VariableDeclaration");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "kind",
                /* ty = */ TNamed("VariableDeclarationKind"),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "declarators",
                /* ty = */ TArray(TNamed("VariableDeclarator")),
                /* isLazy = */ false),
            ];
            this["c_VariableDeclaration"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_VariableDeclaration"] instanceof S.Iface);
        return this["c_VariableDeclaration"] as S.Iface;
    },
    get typeof_VariableDeclaration(): S.FieldType {
        const fieldName = this.VariableDeclaration.name;
        return S.FieldTypeNamed.make(fieldName);
    },


    get VariableDeclarator(): S.Iface {
        if (!this["c_VariableDeclarator"]) {
            const typeName = S.TypeName.make("VariableDeclarator");
            const fields: Array<S.IfaceField> = [
            new S.IfaceField(
                /* name = */ "binding",
                /* ty = */ TUnion([TNamed("ObjectBinding"), TNamed("ArrayBinding"), TNamed("BindingIdentifier")]),
                /* isLazy = */ false),
            new S.IfaceField(
                /* name = */ "init",
                /* ty = */ TOpt(TUnion([TNamed("LiteralBooleanExpression"), TNamed("LiteralInfinityExpression"), TNamed("LiteralNullExpression"), TNamed("LiteralNumericExpression"), TNamed("LiteralStringExpression"), TNamed("LiteralRegExpExpression"), TNamed("ArrayExpression"), TNamed("EagerArrowExpression"), TNamed("LazyArrowExpression"), TNamed("AssignmentExpression"), TNamed("BinaryExpression"), TNamed("CallExpression"), TNamed("CompoundAssignmentExpression"), TNamed("ComputedMemberExpression"), TNamed("ConditionalExpression"), TNamed("ClassExpression"), TNamed("EagerFunctionExpression"), TNamed("LazyFunctionExpression"), TNamed("IdentifierExpression"), TNamed("NewExpression"), TNamed("NewTargetExpression"), TNamed("ObjectExpression"), TNamed("UnaryExpression"), TNamed("StaticMemberExpression"), TNamed("TemplateExpression"), TNamed("ThisExpression"), TNamed("UpdateExpression"), TNamed("YieldExpression"), TNamed("YieldStarExpression"), TNamed("AwaitExpression")])),
                /* isLazy = */ false),
            ];
            this["c_VariableDeclarator"] = new S.Iface(typeName, fields, true);
        }
        assert(this["c_VariableDeclarator"] instanceof S.Iface);
        return this["c_VariableDeclarator"] as S.Iface;
    },
    get typeof_VariableDeclarator(): S.FieldType {
        const fieldName = this.VariableDeclarator.name;
        return S.FieldTypeNamed.make(fieldName);
    },


} // ReflectedSchema;


/*** Typed Interfaces ***/

export type Arguments = RoArr<(SpreadElement | Expression)>;


export type Identifier = string;


export type IdentifierName = string;


export type Label = string;


export enum VariableDeclarationKind {
   KwVar = "var",
   KwLet = "let",
   KwConst = "const",
} // enum VariableDeclarationKind



export enum CompoundAssignmentOperator {
   PlusAssign = "+=",
   MinusAssign = "-=",
   MulAssign = "*=",
   DivAssign = "/=",
   ModAssign = "%=",
   PowAssign = "**=",
   LshAssign = "<<=",
   RshAssign = ">>=",
   ArshAssign = ">>>=",
   BitorAssign = "|=",
   BitxorAssign = "^=",
   BitandAssign = "&=",
} // enum CompoundAssignmentOperator



export enum BinaryOperator {
   Comma = ",",
   LogicalOr = "||",
   LogicalAnd = "&&",
   Bitor = "|",
   Bitxor = "^",
   Bitand = "&",
   Equal = "==",
   NotEqual = "!=",
   StrictEqual = "===",
   NotStrictEqual = "!==",
   LessThan = "<",
   LessEqual = "<=",
   GreaterThan = ">",
   GreaterEqual = ">=",
   KwIn = "in",
   KwInstanceof = "instanceof",
   Lsh = "<<",
   Rsh = ">>",
   Arsh = ">>>",
   Plus = "+",
   Minus = "-",
   Mul = "*",
   Div = "/",
   Mod = "%",
   Pow = "**",
} // enum BinaryOperator



export enum UnaryOperator {
   Plus = "+",
   Minus = "-",
   LogicalNot = "!",
   Bitnot = "~",
   KwTypeof = "typeof",
   KwVoid = "void",
   KwDelete = "delete",
} // enum UnaryOperator



export enum UpdateOperator {
   PlusPlus = "++",
   MinusMinus = "--",
} // enum UpdateOperator



export enum AssertedDeclaredKind {
   KwVar = "var",
   NonConstLexical = "non-const lexical",
   ConstLexical = "const lexical",
} // enum AssertedDeclaredKind



export interface I_AssertedDeclaredName {
    readonly name: IdentifierName;
    readonly kind: AssertedDeclaredKind;
    readonly isCaptured: boolean;
} // I_AssertedDeclaredName

export class AssertedDeclaredName
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssertedDeclaredName;
    }
    readonly data: Ro<I_AssertedDeclaredName>;

    private constructor(data: Ro<I_AssertedDeclaredName>) {
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssertedDeclaredName>) {
        return new AssertedDeclaredName(data);
    }

}


export interface I_AssertedBoundName {
    readonly name: IdentifierName;
    readonly isCaptured: boolean;
} // I_AssertedBoundName

export class AssertedBoundName
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssertedBoundName;
    }
    readonly data: Ro<I_AssertedBoundName>;

    private constructor(data: Ro<I_AssertedBoundName>) {
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssertedBoundName>) {
        return new AssertedBoundName(data);
    }

}


export interface I_AssertedBlockScope {
    readonly declaredNames: RoArr<AssertedDeclaredName>;
    readonly hasDirectEval: boolean;
} // I_AssertedBlockScope

export class AssertedBlockScope
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssertedBlockScope;
    }
    readonly data: Ro<I_AssertedBlockScope>;

    private constructor(data: Ro<I_AssertedBlockScope>) {
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssertedBlockScope>) {
        return new AssertedBlockScope(data);
    }

}


export interface I_AssertedScriptGlobalScope {
    readonly declaredNames: RoArr<AssertedDeclaredName>;
    readonly hasDirectEval: boolean;
} // I_AssertedScriptGlobalScope

export class AssertedScriptGlobalScope
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssertedScriptGlobalScope;
    }
    readonly data: Ro<I_AssertedScriptGlobalScope>;

    private constructor(data: Ro<I_AssertedScriptGlobalScope>) {
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssertedScriptGlobalScope>) {
        return new AssertedScriptGlobalScope(data);
    }

}


export interface I_AssertedVarScope {
    readonly declaredNames: RoArr<AssertedDeclaredName>;
    readonly hasDirectEval: boolean;
} // I_AssertedVarScope

export class AssertedVarScope
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssertedVarScope;
    }
    readonly data: Ro<I_AssertedVarScope>;

    private constructor(data: Ro<I_AssertedVarScope>) {
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssertedVarScope>) {
        return new AssertedVarScope(data);
    }

}


export interface I_AssertedParameterScope {
    readonly boundNames: RoArr<AssertedBoundName>;
    readonly hasDirectEval: boolean;
    readonly isSimpleParameterList: boolean;
} // I_AssertedParameterScope

export class AssertedParameterScope
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssertedParameterScope;
    }
    readonly data: Ro<I_AssertedParameterScope>;

    private constructor(data: Ro<I_AssertedParameterScope>) {
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssertedParameterScope>) {
        return new AssertedParameterScope(data);
    }

}


export interface I_AssertedBoundNamesScope {
    readonly boundNames: RoArr<AssertedBoundName>;
    readonly hasDirectEval: boolean;
} // I_AssertedBoundNamesScope

export class AssertedBoundNamesScope
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssertedBoundNamesScope;
    }
    readonly data: Ro<I_AssertedBoundNamesScope>;

    private constructor(data: Ro<I_AssertedBoundNamesScope>) {
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssertedBoundNamesScope>) {
        return new AssertedBoundNamesScope(data);
    }

}


export type Program = (Script | Module);


export type IterationStatement = (DoWhileStatement | ForInStatement | ForOfStatement | ForStatement | WhileStatement);


export type Statement = (Block | BreakStatement | ContinueStatement | ClassDeclaration | DebuggerStatement | EmptyStatement | ExpressionStatement | FunctionDeclaration | IfStatement | IterationStatement | LabelledStatement | ReturnStatement | SwitchStatement | SwitchStatementWithDefault | ThrowStatement | TryCatchStatement | TryFinallyStatement | VariableDeclaration | WithStatement);


export type Literal = (LiteralBooleanExpression | LiteralInfinityExpression | LiteralNullExpression | LiteralNumericExpression | LiteralStringExpression);


export type Expression = (Literal | LiteralRegExpExpression | ArrayExpression | ArrowExpression | AssignmentExpression | BinaryExpression | CallExpression | CompoundAssignmentExpression | ComputedMemberExpression | ConditionalExpression | ClassExpression | FunctionExpression | IdentifierExpression | NewExpression | NewTargetExpression | ObjectExpression | UnaryExpression | StaticMemberExpression | TemplateExpression | ThisExpression | UpdateExpression | YieldExpression | YieldStarExpression | AwaitExpression);


export type PropertyName = (ComputedPropertyName | LiteralPropertyName);


export type MethodDefinition = (Method | Getter | Setter);


export type ObjectProperty = (MethodDefinition | DataProperty | ShorthandProperty);


export type ExportDeclaration = (ExportAllFrom | ExportFrom | ExportLocals | ExportDefault | Export);


export type ImportDeclaration = (ImportNamespace | Import);


export type FunctionDeclaration = (EagerFunctionDeclaration | LazyFunctionDeclaration);


export type FunctionExpression = (EagerFunctionExpression | LazyFunctionExpression);


export type Method = (EagerMethod | LazyMethod);


export type Getter = (EagerGetter | LazyGetter);


export type Setter = (EagerSetter | LazySetter);


export type ArrowExpression = (EagerArrowExpression | LazyArrowExpression);


export interface I_BindingIdentifier {
    readonly name: Identifier;
} // I_BindingIdentifier

export class BindingIdentifier
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_BindingIdentifier;
    }
    readonly data: Ro<I_BindingIdentifier>;

    private constructor(data: Ro<I_BindingIdentifier>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_BindingIdentifier>) {
        return new BindingIdentifier(data);
    }

}


export type BindingPattern = (ObjectBinding | ArrayBinding);


export type Binding = (BindingPattern | BindingIdentifier);


export type SimpleAssignmentTarget = (AssignmentTargetIdentifier | ComputedMemberAssignmentTarget | StaticMemberAssignmentTarget);


export type AssignmentTargetPattern = (ObjectAssignmentTarget | ArrayAssignmentTarget);


export type AssignmentTarget = (AssignmentTargetPattern | SimpleAssignmentTarget);


export type Parameter = (Binding | BindingWithInitializer);


export interface I_BindingWithInitializer {
    readonly binding: Binding;
    readonly init: Expression;
} // I_BindingWithInitializer

export class BindingWithInitializer
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_BindingWithInitializer;
    }
    readonly data: Ro<I_BindingWithInitializer>;

    private constructor(data: Ro<I_BindingWithInitializer>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_BindingWithInitializer>) {
        return new BindingWithInitializer(data);
    }

}


export interface I_AssignmentTargetIdentifier {
    readonly name: Identifier;
} // I_AssignmentTargetIdentifier

export class AssignmentTargetIdentifier
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssignmentTargetIdentifier;
    }
    readonly data: Ro<I_AssignmentTargetIdentifier>;

    private constructor(data: Ro<I_AssignmentTargetIdentifier>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssignmentTargetIdentifier>) {
        return new AssignmentTargetIdentifier(data);
    }

}


export interface I_ComputedMemberAssignmentTarget {
    readonly object: (Expression | Super);
    readonly expression: Expression;
} // I_ComputedMemberAssignmentTarget

export class ComputedMemberAssignmentTarget
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ComputedMemberAssignmentTarget;
    }
    readonly data: Ro<I_ComputedMemberAssignmentTarget>;

    private constructor(data: Ro<I_ComputedMemberAssignmentTarget>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ComputedMemberAssignmentTarget>) {
        return new ComputedMemberAssignmentTarget(data);
    }

}


export interface I_StaticMemberAssignmentTarget {
    readonly object: (Expression | Super);
    readonly property: IdentifierName;
} // I_StaticMemberAssignmentTarget

export class StaticMemberAssignmentTarget
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_StaticMemberAssignmentTarget;
    }
    readonly data: Ro<I_StaticMemberAssignmentTarget>;

    private constructor(data: Ro<I_StaticMemberAssignmentTarget>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_StaticMemberAssignmentTarget>) {
        return new StaticMemberAssignmentTarget(data);
    }

}


export interface I_ArrayBinding {
    readonly elements: RoArr<Opt<(Binding | BindingWithInitializer)>>;
    readonly rest: Opt<Binding>;
} // I_ArrayBinding

export class ArrayBinding
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ArrayBinding;
    }
    readonly data: Ro<I_ArrayBinding>;

    private constructor(data: Ro<I_ArrayBinding>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ArrayBinding>) {
        return new ArrayBinding(data);
    }

}


export interface I_BindingPropertyIdentifier {
    readonly binding: BindingIdentifier;
    readonly init: Opt<Expression>;
} // I_BindingPropertyIdentifier

export class BindingPropertyIdentifier
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_BindingPropertyIdentifier;
    }
    readonly data: Ro<I_BindingPropertyIdentifier>;

    private constructor(data: Ro<I_BindingPropertyIdentifier>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_BindingPropertyIdentifier>) {
        return new BindingPropertyIdentifier(data);
    }

}


export interface I_BindingPropertyProperty {
    readonly name: PropertyName;
    readonly binding: (Binding | BindingWithInitializer);
} // I_BindingPropertyProperty

export class BindingPropertyProperty
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_BindingPropertyProperty;
    }
    readonly data: Ro<I_BindingPropertyProperty>;

    private constructor(data: Ro<I_BindingPropertyProperty>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_BindingPropertyProperty>) {
        return new BindingPropertyProperty(data);
    }

}


export type BindingProperty = (BindingPropertyIdentifier | BindingPropertyProperty);


export interface I_ObjectBinding {
    readonly properties: RoArr<BindingProperty>;
} // I_ObjectBinding

export class ObjectBinding
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ObjectBinding;
    }
    readonly data: Ro<I_ObjectBinding>;

    private constructor(data: Ro<I_ObjectBinding>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ObjectBinding>) {
        return new ObjectBinding(data);
    }

}


export interface I_AssignmentTargetWithInitializer {
    readonly binding: AssignmentTarget;
    readonly init: Expression;
} // I_AssignmentTargetWithInitializer

export class AssignmentTargetWithInitializer
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssignmentTargetWithInitializer;
    }
    readonly data: Ro<I_AssignmentTargetWithInitializer>;

    private constructor(data: Ro<I_AssignmentTargetWithInitializer>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssignmentTargetWithInitializer>) {
        return new AssignmentTargetWithInitializer(data);
    }

}


export interface I_ArrayAssignmentTarget {
    readonly elements: RoArr<Opt<(AssignmentTarget | AssignmentTargetWithInitializer)>>;
    readonly rest: Opt<AssignmentTarget>;
} // I_ArrayAssignmentTarget

export class ArrayAssignmentTarget
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ArrayAssignmentTarget;
    }
    readonly data: Ro<I_ArrayAssignmentTarget>;

    private constructor(data: Ro<I_ArrayAssignmentTarget>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ArrayAssignmentTarget>) {
        return new ArrayAssignmentTarget(data);
    }

}


export interface I_AssignmentTargetPropertyIdentifier {
    readonly binding: AssignmentTargetIdentifier;
    readonly init: Opt<Expression>;
} // I_AssignmentTargetPropertyIdentifier

export class AssignmentTargetPropertyIdentifier
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssignmentTargetPropertyIdentifier;
    }
    readonly data: Ro<I_AssignmentTargetPropertyIdentifier>;

    private constructor(data: Ro<I_AssignmentTargetPropertyIdentifier>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssignmentTargetPropertyIdentifier>) {
        return new AssignmentTargetPropertyIdentifier(data);
    }

}


export interface I_AssignmentTargetPropertyProperty {
    readonly name: PropertyName;
    readonly binding: (AssignmentTarget | AssignmentTargetWithInitializer);
} // I_AssignmentTargetPropertyProperty

export class AssignmentTargetPropertyProperty
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssignmentTargetPropertyProperty;
    }
    readonly data: Ro<I_AssignmentTargetPropertyProperty>;

    private constructor(data: Ro<I_AssignmentTargetPropertyProperty>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssignmentTargetPropertyProperty>) {
        return new AssignmentTargetPropertyProperty(data);
    }

}


export type AssignmentTargetProperty = (AssignmentTargetPropertyIdentifier | AssignmentTargetPropertyProperty);


export interface I_ObjectAssignmentTarget {
    readonly properties: RoArr<AssignmentTargetProperty>;
} // I_ObjectAssignmentTarget

export class ObjectAssignmentTarget
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ObjectAssignmentTarget;
    }
    readonly data: Ro<I_ObjectAssignmentTarget>;

    private constructor(data: Ro<I_ObjectAssignmentTarget>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ObjectAssignmentTarget>) {
        return new ObjectAssignmentTarget(data);
    }

}


export interface I_ClassExpression {
    readonly name: Opt<BindingIdentifier>;
    readonly super: Opt<Expression>;
    readonly elements: RoArr<ClassElement>;
} // I_ClassExpression

export class ClassExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ClassExpression;
    }
    readonly data: Ro<I_ClassExpression>;

    private constructor(data: Ro<I_ClassExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ClassExpression>) {
        return new ClassExpression(data);
    }

}


export interface I_ClassDeclaration {
    readonly name: BindingIdentifier;
    readonly super: Opt<Expression>;
    readonly elements: RoArr<ClassElement>;
} // I_ClassDeclaration

export class ClassDeclaration
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ClassDeclaration;
    }
    readonly data: Ro<I_ClassDeclaration>;

    private constructor(data: Ro<I_ClassDeclaration>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ClassDeclaration>) {
        return new ClassDeclaration(data);
    }

}


export interface I_ClassElement {
    readonly isStatic: boolean;
    readonly method: MethodDefinition;
} // I_ClassElement

export class ClassElement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ClassElement;
    }
    readonly data: Ro<I_ClassElement>;

    private constructor(data: Ro<I_ClassElement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ClassElement>) {
        return new ClassElement(data);
    }

}


export interface I_Module {
    readonly scope: AssertedVarScope;
    readonly directives: RoArr<Directive>;
    readonly items: RoArr<(ImportDeclaration | ExportDeclaration | Statement)>;
} // I_Module

export class Module
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_Module;
    }
    readonly data: Ro<I_Module>;

    private constructor(data: Ro<I_Module>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_Module>) {
        return new Module(data);
    }

}


export interface I_Import {
    readonly moduleSpecifier: string;
    readonly defaultBinding: Opt<BindingIdentifier>;
    readonly namedImports: RoArr<ImportSpecifier>;
} // I_Import

export class Import
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_Import;
    }
    readonly data: Ro<I_Import>;

    private constructor(data: Ro<I_Import>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_Import>) {
        return new Import(data);
    }

}


export interface I_ImportNamespace {
    readonly moduleSpecifier: string;
    readonly defaultBinding: Opt<BindingIdentifier>;
    readonly namespaceBinding: BindingIdentifier;
} // I_ImportNamespace

export class ImportNamespace
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ImportNamespace;
    }
    readonly data: Ro<I_ImportNamespace>;

    private constructor(data: Ro<I_ImportNamespace>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ImportNamespace>) {
        return new ImportNamespace(data);
    }

}


export interface I_ImportSpecifier {
    readonly name: Opt<IdentifierName>;
    readonly binding: BindingIdentifier;
} // I_ImportSpecifier

export class ImportSpecifier
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ImportSpecifier;
    }
    readonly data: Ro<I_ImportSpecifier>;

    private constructor(data: Ro<I_ImportSpecifier>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ImportSpecifier>) {
        return new ImportSpecifier(data);
    }

}


export interface I_ExportAllFrom {
    readonly moduleSpecifier: string;
} // I_ExportAllFrom

export class ExportAllFrom
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ExportAllFrom;
    }
    readonly data: Ro<I_ExportAllFrom>;

    private constructor(data: Ro<I_ExportAllFrom>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ExportAllFrom>) {
        return new ExportAllFrom(data);
    }

}


export interface I_ExportFrom {
    readonly namedExports: RoArr<ExportFromSpecifier>;
    readonly moduleSpecifier: string;
} // I_ExportFrom

export class ExportFrom
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ExportFrom;
    }
    readonly data: Ro<I_ExportFrom>;

    private constructor(data: Ro<I_ExportFrom>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ExportFrom>) {
        return new ExportFrom(data);
    }

}


export interface I_ExportLocals {
    readonly namedExports: RoArr<ExportLocalSpecifier>;
} // I_ExportLocals

export class ExportLocals
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ExportLocals;
    }
    readonly data: Ro<I_ExportLocals>;

    private constructor(data: Ro<I_ExportLocals>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ExportLocals>) {
        return new ExportLocals(data);
    }

}


export interface I_Export {
    readonly declaration: (FunctionDeclaration | ClassDeclaration | VariableDeclaration);
} // I_Export

export class Export
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_Export;
    }
    readonly data: Ro<I_Export>;

    private constructor(data: Ro<I_Export>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_Export>) {
        return new Export(data);
    }

}


export interface I_ExportDefault {
    readonly body: (FunctionDeclaration | ClassDeclaration | Expression);
} // I_ExportDefault

export class ExportDefault
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ExportDefault;
    }
    readonly data: Ro<I_ExportDefault>;

    private constructor(data: Ro<I_ExportDefault>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ExportDefault>) {
        return new ExportDefault(data);
    }

}


export interface I_ExportFromSpecifier {
    readonly name: IdentifierName;
    readonly exportedName: Opt<IdentifierName>;
} // I_ExportFromSpecifier

export class ExportFromSpecifier
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ExportFromSpecifier;
    }
    readonly data: Ro<I_ExportFromSpecifier>;

    private constructor(data: Ro<I_ExportFromSpecifier>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ExportFromSpecifier>) {
        return new ExportFromSpecifier(data);
    }

}


export interface I_ExportLocalSpecifier {
    readonly name: IdentifierExpression;
    readonly exportedName: Opt<IdentifierName>;
} // I_ExportLocalSpecifier

export class ExportLocalSpecifier
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ExportLocalSpecifier;
    }
    readonly data: Ro<I_ExportLocalSpecifier>;

    private constructor(data: Ro<I_ExportLocalSpecifier>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ExportLocalSpecifier>) {
        return new ExportLocalSpecifier(data);
    }

}


export interface I_EagerMethod {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionOrMethodContents;
} // I_EagerMethod

export class EagerMethod
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_EagerMethod;
    }
    readonly data: Ro<I_EagerMethod>;

    private constructor(data: Ro<I_EagerMethod>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_EagerMethod>) {
        return new EagerMethod(data);
    }

}


export interface I_LazyMethod {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionOrMethodContents;
} // I_LazyMethod

export class LazyMethod
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LazyMethod;
    }
    readonly data: Ro<I_LazyMethod>;

    private constructor(data: Ro<I_LazyMethod>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LazyMethod>) {
        return new LazyMethod(data);
    }

}


export interface I_EagerGetter {
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: GetterContents;
} // I_EagerGetter

export class EagerGetter
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_EagerGetter;
    }
    readonly data: Ro<I_EagerGetter>;

    private constructor(data: Ro<I_EagerGetter>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_EagerGetter>) {
        return new EagerGetter(data);
    }

}


export interface I_LazyGetter {
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: GetterContents;
} // I_LazyGetter

export class LazyGetter
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LazyGetter;
    }
    readonly data: Ro<I_LazyGetter>;

    private constructor(data: Ro<I_LazyGetter>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LazyGetter>) {
        return new LazyGetter(data);
    }

}


export interface I_GetterContents {
    readonly isThisCaptured: boolean;
    readonly bodyScope: AssertedVarScope;
    readonly body: FunctionBody;
} // I_GetterContents

export class GetterContents
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_GetterContents;
    }
    readonly data: Ro<I_GetterContents>;

    private constructor(data: Ro<I_GetterContents>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_GetterContents>) {
        return new GetterContents(data);
    }

}


export interface I_EagerSetter {
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: SetterContents;
} // I_EagerSetter

export class EagerSetter
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_EagerSetter;
    }
    readonly data: Ro<I_EagerSetter>;

    private constructor(data: Ro<I_EagerSetter>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_EagerSetter>) {
        return new EagerSetter(data);
    }

}


export interface I_LazySetter {
    readonly name: PropertyName;
    readonly directives: RoArr<Directive>;
    readonly contents: SetterContents;
} // I_LazySetter

export class LazySetter
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LazySetter;
    }
    readonly data: Ro<I_LazySetter>;

    private constructor(data: Ro<I_LazySetter>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LazySetter>) {
        return new LazySetter(data);
    }

}


export interface I_SetterContents {
    readonly isThisCaptured: boolean;
    readonly parameterScope: AssertedParameterScope;
    readonly param: Parameter;
    readonly bodyScope: AssertedVarScope;
    readonly body: FunctionBody;
} // I_SetterContents

export class SetterContents
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_SetterContents;
    }
    readonly data: Ro<I_SetterContents>;

    private constructor(data: Ro<I_SetterContents>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_SetterContents>) {
        return new SetterContents(data);
    }

}


export interface I_DataProperty {
    readonly name: PropertyName;
    readonly expression: Expression;
} // I_DataProperty

export class DataProperty
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_DataProperty;
    }
    readonly data: Ro<I_DataProperty>;

    private constructor(data: Ro<I_DataProperty>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_DataProperty>) {
        return new DataProperty(data);
    }

}


export interface I_ShorthandProperty {
    readonly name: IdentifierExpression;
} // I_ShorthandProperty

export class ShorthandProperty
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ShorthandProperty;
    }
    readonly data: Ro<I_ShorthandProperty>;

    private constructor(data: Ro<I_ShorthandProperty>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ShorthandProperty>) {
        return new ShorthandProperty(data);
    }

}


export interface I_ComputedPropertyName {
    readonly expression: Expression;
} // I_ComputedPropertyName

export class ComputedPropertyName
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ComputedPropertyName;
    }
    readonly data: Ro<I_ComputedPropertyName>;

    private constructor(data: Ro<I_ComputedPropertyName>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ComputedPropertyName>) {
        return new ComputedPropertyName(data);
    }

}


export interface I_LiteralPropertyName {
    readonly value: string;
} // I_LiteralPropertyName

export class LiteralPropertyName
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LiteralPropertyName;
    }
    readonly data: Ro<I_LiteralPropertyName>;

    private constructor(data: Ro<I_LiteralPropertyName>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LiteralPropertyName>) {
        return new LiteralPropertyName(data);
    }

}


export interface I_LiteralBooleanExpression {
    readonly value: boolean;
} // I_LiteralBooleanExpression

export class LiteralBooleanExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LiteralBooleanExpression;
    }
    readonly data: Ro<I_LiteralBooleanExpression>;

    private constructor(data: Ro<I_LiteralBooleanExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LiteralBooleanExpression>) {
        return new LiteralBooleanExpression(data);
    }

}


export interface I_LiteralInfinityExpression {
} // I_LiteralInfinityExpression

export class LiteralInfinityExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LiteralInfinityExpression;
    }
    readonly data: Ro<I_LiteralInfinityExpression>;

    private constructor(data: Ro<I_LiteralInfinityExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LiteralInfinityExpression>) {
        return new LiteralInfinityExpression(data);
    }

}


export interface I_LiteralNullExpression {
} // I_LiteralNullExpression

export class LiteralNullExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LiteralNullExpression;
    }
    readonly data: Ro<I_LiteralNullExpression>;

    private constructor(data: Ro<I_LiteralNullExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LiteralNullExpression>) {
        return new LiteralNullExpression(data);
    }

}


export interface I_LiteralNumericExpression {
    readonly value: number;
} // I_LiteralNumericExpression

export class LiteralNumericExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LiteralNumericExpression;
    }
    readonly data: Ro<I_LiteralNumericExpression>;

    private constructor(data: Ro<I_LiteralNumericExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LiteralNumericExpression>) {
        return new LiteralNumericExpression(data);
    }

}


export interface I_LiteralRegExpExpression {
    readonly pattern: string;
    readonly flags: string;
} // I_LiteralRegExpExpression

export class LiteralRegExpExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LiteralRegExpExpression;
    }
    readonly data: Ro<I_LiteralRegExpExpression>;

    private constructor(data: Ro<I_LiteralRegExpExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LiteralRegExpExpression>) {
        return new LiteralRegExpExpression(data);
    }

}


export interface I_LiteralStringExpression {
    readonly value: string;
} // I_LiteralStringExpression

export class LiteralStringExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LiteralStringExpression;
    }
    readonly data: Ro<I_LiteralStringExpression>;

    private constructor(data: Ro<I_LiteralStringExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LiteralStringExpression>) {
        return new LiteralStringExpression(data);
    }

}


export interface I_ArrayExpression {
    readonly elements: RoArr<Opt<(SpreadElement | Expression)>>;
} // I_ArrayExpression

export class ArrayExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ArrayExpression;
    }
    readonly data: Ro<I_ArrayExpression>;

    private constructor(data: Ro<I_ArrayExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ArrayExpression>) {
        return new ArrayExpression(data);
    }

}


export interface I_EagerArrowExpression {
    readonly isAsync: boolean;
    readonly directives: Opt<RoArr<Directive>>;
    readonly contents: ArrowExpressionContents;
} // I_EagerArrowExpression

export class EagerArrowExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_EagerArrowExpression;
    }
    readonly data: Ro<I_EagerArrowExpression>;

    private constructor(data: Ro<I_EagerArrowExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_EagerArrowExpression>) {
        return new EagerArrowExpression(data);
    }

}


export interface I_LazyArrowExpression {
    readonly isAsync: boolean;
    readonly directives: Opt<RoArr<Directive>>;
    readonly contents: ArrowExpressionContents;
} // I_LazyArrowExpression

export class LazyArrowExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LazyArrowExpression;
    }
    readonly data: Ro<I_LazyArrowExpression>;

    private constructor(data: Ro<I_LazyArrowExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LazyArrowExpression>) {
        return new LazyArrowExpression(data);
    }

}


export interface I_ArrowExpressionContents {
    readonly parameterScope: AssertedParameterScope;
    readonly params: FormalParameters;
    readonly bodyScope: AssertedVarScope;
    readonly body: (FunctionBody | Expression);
} // I_ArrowExpressionContents

export class ArrowExpressionContents
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ArrowExpressionContents;
    }
    readonly data: Ro<I_ArrowExpressionContents>;

    private constructor(data: Ro<I_ArrowExpressionContents>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ArrowExpressionContents>) {
        return new ArrowExpressionContents(data);
    }

}


export interface I_AssignmentExpression {
    readonly binding: AssignmentTarget;
    readonly expression: Expression;
} // I_AssignmentExpression

export class AssignmentExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AssignmentExpression;
    }
    readonly data: Ro<I_AssignmentExpression>;

    private constructor(data: Ro<I_AssignmentExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AssignmentExpression>) {
        return new AssignmentExpression(data);
    }

}


export interface I_BinaryExpression {
    readonly operator: BinaryOperator;
    readonly left: Expression;
    readonly right: Expression;
} // I_BinaryExpression

export class BinaryExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_BinaryExpression;
    }
    readonly data: Ro<I_BinaryExpression>;

    private constructor(data: Ro<I_BinaryExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_BinaryExpression>) {
        return new BinaryExpression(data);
    }

}


export interface I_CallExpression {
    readonly callee: (Expression | Super);
    readonly arguments: Arguments;
} // I_CallExpression

export class CallExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_CallExpression;
    }
    readonly data: Ro<I_CallExpression>;

    private constructor(data: Ro<I_CallExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_CallExpression>) {
        return new CallExpression(data);
    }

}


export interface I_CompoundAssignmentExpression {
    readonly operator: CompoundAssignmentOperator;
    readonly binding: SimpleAssignmentTarget;
    readonly expression: Expression;
} // I_CompoundAssignmentExpression

export class CompoundAssignmentExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_CompoundAssignmentExpression;
    }
    readonly data: Ro<I_CompoundAssignmentExpression>;

    private constructor(data: Ro<I_CompoundAssignmentExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_CompoundAssignmentExpression>) {
        return new CompoundAssignmentExpression(data);
    }

}


export interface I_ComputedMemberExpression {
    readonly object: (Expression | Super);
    readonly expression: Expression;
} // I_ComputedMemberExpression

export class ComputedMemberExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ComputedMemberExpression;
    }
    readonly data: Ro<I_ComputedMemberExpression>;

    private constructor(data: Ro<I_ComputedMemberExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ComputedMemberExpression>) {
        return new ComputedMemberExpression(data);
    }

}


export interface I_ConditionalExpression {
    readonly test: Expression;
    readonly consequent: Expression;
    readonly alternate: Expression;
} // I_ConditionalExpression

export class ConditionalExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ConditionalExpression;
    }
    readonly data: Ro<I_ConditionalExpression>;

    private constructor(data: Ro<I_ConditionalExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ConditionalExpression>) {
        return new ConditionalExpression(data);
    }

}


export interface I_EagerFunctionExpression {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: Opt<BindingIdentifier>;
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionExpressionContents;
} // I_EagerFunctionExpression

export class EagerFunctionExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_EagerFunctionExpression;
    }
    readonly data: Ro<I_EagerFunctionExpression>;

    private constructor(data: Ro<I_EagerFunctionExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_EagerFunctionExpression>) {
        return new EagerFunctionExpression(data);
    }

}


export interface I_LazyFunctionExpression {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: Opt<BindingIdentifier>;
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionExpressionContents;
} // I_LazyFunctionExpression

export class LazyFunctionExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LazyFunctionExpression;
    }
    readonly data: Ro<I_LazyFunctionExpression>;

    private constructor(data: Ro<I_LazyFunctionExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LazyFunctionExpression>) {
        return new LazyFunctionExpression(data);
    }

}


export interface I_FunctionExpressionContents {
    readonly isFunctionNameCaptured: boolean;
    readonly isThisCaptured: boolean;
    readonly parameterScope: AssertedParameterScope;
    readonly params: FormalParameters;
    readonly bodyScope: AssertedVarScope;
    readonly body: FunctionBody;
} // I_FunctionExpressionContents

export class FunctionExpressionContents
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_FunctionExpressionContents;
    }
    readonly data: Ro<I_FunctionExpressionContents>;

    private constructor(data: Ro<I_FunctionExpressionContents>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_FunctionExpressionContents>) {
        return new FunctionExpressionContents(data);
    }

}


export interface I_IdentifierExpression {
    readonly name: Identifier;
} // I_IdentifierExpression

export class IdentifierExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_IdentifierExpression;
    }
    readonly data: Ro<I_IdentifierExpression>;

    private constructor(data: Ro<I_IdentifierExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_IdentifierExpression>) {
        return new IdentifierExpression(data);
    }

}


export interface I_NewExpression {
    readonly callee: Expression;
    readonly arguments: Arguments;
} // I_NewExpression

export class NewExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_NewExpression;
    }
    readonly data: Ro<I_NewExpression>;

    private constructor(data: Ro<I_NewExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_NewExpression>) {
        return new NewExpression(data);
    }

}


export interface I_NewTargetExpression {
} // I_NewTargetExpression

export class NewTargetExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_NewTargetExpression;
    }
    readonly data: Ro<I_NewTargetExpression>;

    private constructor(data: Ro<I_NewTargetExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_NewTargetExpression>) {
        return new NewTargetExpression(data);
    }

}


export interface I_ObjectExpression {
    readonly properties: RoArr<ObjectProperty>;
} // I_ObjectExpression

export class ObjectExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ObjectExpression;
    }
    readonly data: Ro<I_ObjectExpression>;

    private constructor(data: Ro<I_ObjectExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ObjectExpression>) {
        return new ObjectExpression(data);
    }

}


export interface I_UnaryExpression {
    readonly operator: UnaryOperator;
    readonly operand: Expression;
} // I_UnaryExpression

export class UnaryExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_UnaryExpression;
    }
    readonly data: Ro<I_UnaryExpression>;

    private constructor(data: Ro<I_UnaryExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_UnaryExpression>) {
        return new UnaryExpression(data);
    }

}


export interface I_StaticMemberExpression {
    readonly object: (Expression | Super);
    readonly property: IdentifierName;
} // I_StaticMemberExpression

export class StaticMemberExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_StaticMemberExpression;
    }
    readonly data: Ro<I_StaticMemberExpression>;

    private constructor(data: Ro<I_StaticMemberExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_StaticMemberExpression>) {
        return new StaticMemberExpression(data);
    }

}


export interface I_TemplateExpression {
    readonly tag: Opt<Expression>;
    readonly elements: RoArr<(Expression | TemplateElement)>;
} // I_TemplateExpression

export class TemplateExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_TemplateExpression;
    }
    readonly data: Ro<I_TemplateExpression>;

    private constructor(data: Ro<I_TemplateExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_TemplateExpression>) {
        return new TemplateExpression(data);
    }

}


export interface I_ThisExpression {
} // I_ThisExpression

export class ThisExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ThisExpression;
    }
    readonly data: Ro<I_ThisExpression>;

    private constructor(data: Ro<I_ThisExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ThisExpression>) {
        return new ThisExpression(data);
    }

}


export interface I_UpdateExpression {
    readonly isPrefix: boolean;
    readonly operator: UpdateOperator;
    readonly operand: SimpleAssignmentTarget;
} // I_UpdateExpression

export class UpdateExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_UpdateExpression;
    }
    readonly data: Ro<I_UpdateExpression>;

    private constructor(data: Ro<I_UpdateExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_UpdateExpression>) {
        return new UpdateExpression(data);
    }

}


export interface I_YieldExpression {
    readonly expression: Opt<Expression>;
} // I_YieldExpression

export class YieldExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_YieldExpression;
    }
    readonly data: Ro<I_YieldExpression>;

    private constructor(data: Ro<I_YieldExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_YieldExpression>) {
        return new YieldExpression(data);
    }

}


export interface I_YieldStarExpression {
    readonly expression: Expression;
} // I_YieldStarExpression

export class YieldStarExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_YieldStarExpression;
    }
    readonly data: Ro<I_YieldStarExpression>;

    private constructor(data: Ro<I_YieldStarExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_YieldStarExpression>) {
        return new YieldStarExpression(data);
    }

}


export interface I_AwaitExpression {
    readonly expression: Expression;
} // I_AwaitExpression

export class AwaitExpression
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_AwaitExpression;
    }
    readonly data: Ro<I_AwaitExpression>;

    private constructor(data: Ro<I_AwaitExpression>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_AwaitExpression>) {
        return new AwaitExpression(data);
    }

}


export interface I_BreakStatement {
    readonly label: Opt<Label>;
} // I_BreakStatement

export class BreakStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_BreakStatement;
    }
    readonly data: Ro<I_BreakStatement>;

    private constructor(data: Ro<I_BreakStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_BreakStatement>) {
        return new BreakStatement(data);
    }

}


export interface I_ContinueStatement {
    readonly label: Opt<Label>;
} // I_ContinueStatement

export class ContinueStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ContinueStatement;
    }
    readonly data: Ro<I_ContinueStatement>;

    private constructor(data: Ro<I_ContinueStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ContinueStatement>) {
        return new ContinueStatement(data);
    }

}


export interface I_DebuggerStatement {
} // I_DebuggerStatement

export class DebuggerStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_DebuggerStatement;
    }
    readonly data: Ro<I_DebuggerStatement>;

    private constructor(data: Ro<I_DebuggerStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_DebuggerStatement>) {
        return new DebuggerStatement(data);
    }

}


export interface I_DoWhileStatement {
    readonly test: Expression;
    readonly body: Statement;
} // I_DoWhileStatement

export class DoWhileStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_DoWhileStatement;
    }
    readonly data: Ro<I_DoWhileStatement>;

    private constructor(data: Ro<I_DoWhileStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_DoWhileStatement>) {
        return new DoWhileStatement(data);
    }

}


export interface I_EmptyStatement {
} // I_EmptyStatement

export class EmptyStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_EmptyStatement;
    }
    readonly data: Ro<I_EmptyStatement>;

    private constructor(data: Ro<I_EmptyStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_EmptyStatement>) {
        return new EmptyStatement(data);
    }

}


export interface I_ExpressionStatement {
    readonly expression: Expression;
} // I_ExpressionStatement

export class ExpressionStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ExpressionStatement;
    }
    readonly data: Ro<I_ExpressionStatement>;

    private constructor(data: Ro<I_ExpressionStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ExpressionStatement>) {
        return new ExpressionStatement(data);
    }

}


export interface I_ForInOfBinding {
    readonly kind: VariableDeclarationKind;
    readonly binding: Binding;
} // I_ForInOfBinding

export class ForInOfBinding
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ForInOfBinding;
    }
    readonly data: Ro<I_ForInOfBinding>;

    private constructor(data: Ro<I_ForInOfBinding>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ForInOfBinding>) {
        return new ForInOfBinding(data);
    }

}


export interface I_ForInStatement {
    readonly left: (ForInOfBinding | AssignmentTarget);
    readonly right: Expression;
    readonly body: Statement;
} // I_ForInStatement

export class ForInStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ForInStatement;
    }
    readonly data: Ro<I_ForInStatement>;

    private constructor(data: Ro<I_ForInStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ForInStatement>) {
        return new ForInStatement(data);
    }

}


export interface I_ForOfStatement {
    readonly left: (ForInOfBinding | AssignmentTarget);
    readonly right: Expression;
    readonly body: Statement;
} // I_ForOfStatement

export class ForOfStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ForOfStatement;
    }
    readonly data: Ro<I_ForOfStatement>;

    private constructor(data: Ro<I_ForOfStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ForOfStatement>) {
        return new ForOfStatement(data);
    }

}


export interface I_ForStatement {
    readonly init: Opt<(VariableDeclaration | Expression)>;
    readonly test: Opt<Expression>;
    readonly update: Opt<Expression>;
    readonly body: Statement;
} // I_ForStatement

export class ForStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ForStatement;
    }
    readonly data: Ro<I_ForStatement>;

    private constructor(data: Ro<I_ForStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ForStatement>) {
        return new ForStatement(data);
    }

}


export interface I_IfStatement {
    readonly test: Expression;
    readonly consequent: Statement;
    readonly alternate: Opt<Statement>;
} // I_IfStatement

export class IfStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_IfStatement;
    }
    readonly data: Ro<I_IfStatement>;

    private constructor(data: Ro<I_IfStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_IfStatement>) {
        return new IfStatement(data);
    }

}


export interface I_LabelledStatement {
    readonly label: Label;
    readonly body: Statement;
} // I_LabelledStatement

export class LabelledStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LabelledStatement;
    }
    readonly data: Ro<I_LabelledStatement>;

    private constructor(data: Ro<I_LabelledStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LabelledStatement>) {
        return new LabelledStatement(data);
    }

}


export interface I_ReturnStatement {
    readonly expression: Opt<Expression>;
} // I_ReturnStatement

export class ReturnStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ReturnStatement;
    }
    readonly data: Ro<I_ReturnStatement>;

    private constructor(data: Ro<I_ReturnStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ReturnStatement>) {
        return new ReturnStatement(data);
    }

}


export interface I_SwitchStatement {
    readonly discriminant: Expression;
    readonly cases: RoArr<SwitchCase>;
} // I_SwitchStatement

export class SwitchStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_SwitchStatement;
    }
    readonly data: Ro<I_SwitchStatement>;

    private constructor(data: Ro<I_SwitchStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_SwitchStatement>) {
        return new SwitchStatement(data);
    }

}


export interface I_SwitchStatementWithDefault {
    readonly discriminant: Expression;
    readonly preDefaultCases: RoArr<SwitchCase>;
    readonly defaultCase: SwitchDefault;
    readonly postDefaultCases: RoArr<SwitchCase>;
} // I_SwitchStatementWithDefault

export class SwitchStatementWithDefault
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_SwitchStatementWithDefault;
    }
    readonly data: Ro<I_SwitchStatementWithDefault>;

    private constructor(data: Ro<I_SwitchStatementWithDefault>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_SwitchStatementWithDefault>) {
        return new SwitchStatementWithDefault(data);
    }

}


export interface I_ThrowStatement {
    readonly expression: Expression;
} // I_ThrowStatement

export class ThrowStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_ThrowStatement;
    }
    readonly data: Ro<I_ThrowStatement>;

    private constructor(data: Ro<I_ThrowStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_ThrowStatement>) {
        return new ThrowStatement(data);
    }

}


export interface I_TryCatchStatement {
    readonly body: Block;
    readonly catchClause: CatchClause;
} // I_TryCatchStatement

export class TryCatchStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_TryCatchStatement;
    }
    readonly data: Ro<I_TryCatchStatement>;

    private constructor(data: Ro<I_TryCatchStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_TryCatchStatement>) {
        return new TryCatchStatement(data);
    }

}


export interface I_TryFinallyStatement {
    readonly body: Block;
    readonly catchClause: Opt<CatchClause>;
    readonly finalizer: Block;
} // I_TryFinallyStatement

export class TryFinallyStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_TryFinallyStatement;
    }
    readonly data: Ro<I_TryFinallyStatement>;

    private constructor(data: Ro<I_TryFinallyStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_TryFinallyStatement>) {
        return new TryFinallyStatement(data);
    }

}


export interface I_WhileStatement {
    readonly test: Expression;
    readonly body: Statement;
} // I_WhileStatement

export class WhileStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_WhileStatement;
    }
    readonly data: Ro<I_WhileStatement>;

    private constructor(data: Ro<I_WhileStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_WhileStatement>) {
        return new WhileStatement(data);
    }

}


export interface I_WithStatement {
    readonly object: Expression;
    readonly body: Statement;
} // I_WithStatement

export class WithStatement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_WithStatement;
    }
    readonly data: Ro<I_WithStatement>;

    private constructor(data: Ro<I_WithStatement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_WithStatement>) {
        return new WithStatement(data);
    }

}


export interface I_Block {
    readonly scope: AssertedBlockScope;
    readonly statements: RoArr<Statement>;
} // I_Block

export class Block
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_Block;
    }
    readonly data: Ro<I_Block>;

    private constructor(data: Ro<I_Block>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_Block>) {
        return new Block(data);
    }

}


export interface I_CatchClause {
    readonly bindingScope: AssertedBoundNamesScope;
    readonly binding: Binding;
    readonly body: Block;
} // I_CatchClause

export class CatchClause
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_CatchClause;
    }
    readonly data: Ro<I_CatchClause>;

    private constructor(data: Ro<I_CatchClause>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_CatchClause>) {
        return new CatchClause(data);
    }

}


export interface I_Directive {
    readonly rawValue: string;
} // I_Directive

export class Directive
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_Directive;
    }
    readonly data: Ro<I_Directive>;

    private constructor(data: Ro<I_Directive>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_Directive>) {
        return new Directive(data);
    }

}


export interface I_FormalParameters {
    readonly items: RoArr<Parameter>;
    readonly rest: Opt<Binding>;
} // I_FormalParameters

export class FormalParameters
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_FormalParameters;
    }
    readonly data: Ro<I_FormalParameters>;

    private constructor(data: Ro<I_FormalParameters>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_FormalParameters>) {
        return new FormalParameters(data);
    }

}


export type FunctionBody = RoArr<Statement>;


export interface I_EagerFunctionDeclaration {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: BindingIdentifier;
    readonly directives: RoArr<Directive>;
    readonly contents: FunctionOrMethodContents;
} // I_EagerFunctionDeclaration

export class EagerFunctionDeclaration
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_EagerFunctionDeclaration;
    }
    readonly data: Ro<I_EagerFunctionDeclaration>;

    private constructor(data: Ro<I_EagerFunctionDeclaration>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_EagerFunctionDeclaration>) {
        return new EagerFunctionDeclaration(data);
    }

}


export interface I_LazyFunctionDeclaration {
    readonly isAsync: boolean;
    readonly isGenerator: boolean;
    readonly name: BindingIdentifier;
    readonly directives: RoArr<Directive>;
    readonly content: FunctionOrMethodContents;
} // I_LazyFunctionDeclaration

export class LazyFunctionDeclaration
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_LazyFunctionDeclaration;
    }
    readonly data: Ro<I_LazyFunctionDeclaration>;

    private constructor(data: Ro<I_LazyFunctionDeclaration>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_LazyFunctionDeclaration>) {
        return new LazyFunctionDeclaration(data);
    }

}


export interface I_FunctionOrMethodContents {
    readonly isThisCaptured: boolean;
    readonly parameterScope: AssertedParameterScope;
    readonly params: FormalParameters;
    readonly bodyScope: AssertedVarScope;
    readonly body: FunctionBody;
} // I_FunctionOrMethodContents

export class FunctionOrMethodContents
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_FunctionOrMethodContents;
    }
    readonly data: Ro<I_FunctionOrMethodContents>;

    private constructor(data: Ro<I_FunctionOrMethodContents>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_FunctionOrMethodContents>) {
        return new FunctionOrMethodContents(data);
    }

}


export interface I_Script {
    readonly scope: AssertedScriptGlobalScope;
    readonly directives: RoArr<Directive>;
    readonly statements: RoArr<Statement>;
} // I_Script

export class Script
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_Script;
    }
    readonly data: Ro<I_Script>;

    private constructor(data: Ro<I_Script>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_Script>) {
        return new Script(data);
    }

}


export interface I_SpreadElement {
    readonly expression: Expression;
} // I_SpreadElement

export class SpreadElement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_SpreadElement;
    }
    readonly data: Ro<I_SpreadElement>;

    private constructor(data: Ro<I_SpreadElement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_SpreadElement>) {
        return new SpreadElement(data);
    }

}


export interface I_Super {
} // I_Super

export class Super
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_Super;
    }
    readonly data: Ro<I_Super>;

    private constructor(data: Ro<I_Super>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_Super>) {
        return new Super(data);
    }

}


export interface I_SwitchCase {
    readonly test: Expression;
    readonly consequent: RoArr<Statement>;
} // I_SwitchCase

export class SwitchCase
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_SwitchCase;
    }
    readonly data: Ro<I_SwitchCase>;

    private constructor(data: Ro<I_SwitchCase>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_SwitchCase>) {
        return new SwitchCase(data);
    }

}


export interface I_SwitchDefault {
    readonly consequent: RoArr<Statement>;
} // I_SwitchDefault

export class SwitchDefault
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_SwitchDefault;
    }
    readonly data: Ro<I_SwitchDefault>;

    private constructor(data: Ro<I_SwitchDefault>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_SwitchDefault>) {
        return new SwitchDefault(data);
    }

}


export interface I_TemplateElement {
    readonly rawValue: string;
} // I_TemplateElement

export class TemplateElement
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_TemplateElement;
    }
    readonly data: Ro<I_TemplateElement>;

    private constructor(data: Ro<I_TemplateElement>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_TemplateElement>) {
        return new TemplateElement(data);
    }

}


export interface I_VariableDeclaration {
    readonly kind: VariableDeclarationKind;
    readonly declarators: RoArr<VariableDeclarator>;
} // I_VariableDeclaration

export class VariableDeclaration
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_VariableDeclaration;
    }
    readonly data: Ro<I_VariableDeclaration>;

    private constructor(data: Ro<I_VariableDeclaration>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_VariableDeclaration>) {
        return new VariableDeclaration(data);
    }

}


export interface I_VariableDeclarator {
    readonly binding: Binding;
    readonly init: Opt<Expression>;
} // I_VariableDeclarator

export class VariableDeclarator
  extends BaseNode
  implements S.Instance
{
    get iface$(): S.Iface {
        return ReflectedSchema.typeof_VariableDeclarator;
    }
    readonly data: Ro<I_VariableDeclarator>;

    private constructor(data: Ro<I_VariableDeclarator>) {
    super();
        this.data = Object.freeze(data);
        Object.freeze(this);
    }


    static make(data: Ro<I_VariableDeclarator>) {
        return new VariableDeclarator(data);
    }

}


